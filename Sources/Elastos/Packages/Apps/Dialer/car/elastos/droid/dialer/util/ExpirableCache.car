module
{
    namespace Elastos {
    namespace Droid {
    namespace Dialer {
    namespace Util {

    /**
     * A cached value stored inside the cache.
     * <p>
     * It provides access to the value stored in the cache but also allows to check whether the
     * value is expired.
     *
     * @param <V> the type of value stored in the cache
     */
    interface IExpirableCacheCachedValue{
        /** Returns the value stored in the cache for a given key. */
        GetValue(
            [out] IInterface** value);

        /**
         * Checks whether the value, while still being present in the cache, is expired.
         *
         * @return true if the value is expired
         */
        IsExpired(
            [out] Boolean* result);
    }

    interface IExpirableCache {
        /**
         * Returns the cached value for the given key, or null if no value exists.
         * <p>
         * The cached value gives access both to the value associated with the key and whether it is
         * expired or not.
         * <p>
         * If not interested in whether the value is expired, use {@link #getPossiblyExpired(Object)}
         * instead.
         * <p>
         * If only wants values that are not expired, use {@link #get(Object)} instead.
         *
         * @param key the key to look up
         */
        GetCachedValue(
            [in] IInterface* key,
            [out] IExpirableCacheCachedValue** value);

        /**
         * Returns the value for the given key, or null if no value exists.
         * <p>
         * When using this method, it is not possible to determine whether the value is expired or not.
         * Use {@link #getCachedValue(Object)} to achieve that instead. However, if using
         * {@link #getCachedValue(Object)} to determine if an item is expired, one should use the item
         * within the {@link CachedValue} and not call {@link #getPossiblyExpired(Object)} to get the
         * value afterwards, since that is not guaranteed to return the same value or that the newly
         * returned value is in the same state.
         *
         * @param key the key to look up
         */
        GetPossiblyExpired(
            [in] IInterface* key,
            [out] IInterface** value);

        /**
         * Returns the value for the given key only if it is not expired, or null if no value exists or
         * is expired.
         * <p>
         * This method will return null if either there is no value associated with this key or if the
         * associated value is expired.
         *
         * @param key the key to look up
         */
        // @NeededForTesting
        Get(
            [in] IInterface* key,
            [out] IInterface** value);

        /**
         * Puts an item in the cache.
         * <p>
         * Newly added item will not be expired until {@link #expireAll()} is next called.
         *
         * @param key the key to look up
         * @param value the value to associate with the key
         */
        Put(
            [in] IInterface* key,
            [in] IInterface* value);

        /**
         * Mark all items currently in the cache as expired.
         * <p>
         * Newly added items after this call will be marked as not expired.
         * <p>
         * Expiring the items in the cache does not imply they will be evicted.
         */
        ExpireAll();

        /**
         * Creates a new {@link CachedValue} instance to be stored in this cache.
         * <p>
         * Implementation of {@link LruCache#create(K)} can use this method to create a new entry.
         */
        NewCachedValue(
            [in] IInterface* value,
            [out] IExpirableCacheCachedValue** cached);
    }

    interface IExpirableCacheHelper {
        /**
         * Creates a new {@link ExpirableCache} that wraps the given {@link LruCache}.
         * <p>
         * The created cache takes ownership of the cache passed in as an argument.
         *
         * @param <K> the type of the keys
         * @param <V> the type of the values
         * @param cache the cache to store the value in
         * @return the newly created expirable cache
         * @throws IllegalArgumentException if the cache is not empty
         */
        Create(
            [in] IInterface* lruCache,
            [out] IExpirableCache** result);

        /**
         * Creates a new {@link ExpirableCache} with the given maximum size.
         *
         * @param <K> the type of the keys
         * @param <V> the type of the values
         * @return the newly created expirable cache
         */
        Create(
            [in] Int32 maxSize,
            [out] IExpirableCache** result);
    }

    } // Util
    } // Dialer
    } // Droid
    } // Elastos
}
