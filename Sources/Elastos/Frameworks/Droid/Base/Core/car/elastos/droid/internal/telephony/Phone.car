
module
{
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Net.ILinkProperties;
    interface Elastos.Droid.Net.INetworkCapabilities;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Os.IMessage;
    interface Elastos.Droid.Os.IBundle;
    interface Elastos.Droid.Telephony.IServiceState;
    interface Elastos.Droid.Telephony.ICellLocation;
    interface Elastos.Droid.Telephony.ISignalStrength;
    interface Elastos.Droid.Internal.Telephony.ImsPhone.IImsPhone;
    interface Elastos.Droid.Internal.Telephony.Uicc.IIsimRecords;
    interface Elastos.Droid.Internal.Telephony.Uicc.IUiccCard;
    interface Elastos.Droid.Internal.Telephony.Uicc.IUsimServiceTable;

    using interface Elastos.Utility.IList;

    namespace Elastos {
    namespace Droid {
    namespace Internal {
    namespace Telephony {

    enum IPhoneDataActivityState {
        /**
         * The state of a data activity.
         * <ul>
         * <li>NONE = No traffic</li>
         * <li>DATAIN = Receiving IP ppp traffic</li>
         * <li>DATAOUT = Sending IP ppp traffic</li>
         * <li>DATAINANDOUT = Both receiving and sending IP ppp traffic</li>
         * <li>DORMANT = The data connection is still active,
                                     but physical link is down</li>
         * </ul>
         */
        IPhoneDataActivityState_NONE,
        IPhoneDataActivityState_DATAIN,
        IPhoneDataActivityState_DATAOUT,
        IPhoneDataActivityState_DATAINANDOUT,
        IPhoneDataActivityState_DORMANT
    }

    enum IPhoneSuppService {
        IPhoneSuppService_UNKNOWN,
        IPhoneSuppService_SWITCH,
        IPhoneSuppService_SEPARATE,
        IPhoneSuppService_TRANSFER,
        IPhoneSuppService_CONFERENCE,
        IPhoneSuppService_REJECT,
        IPhoneSuppService_HANGUP
    }

    /**
     * Internal interface used to control the phone; SDK developers cannot
     * obtain this interface.
     *
     * {@hide}
     *
     */
    [local, deprecated]
    interface IPhone {

        /** used to enable additional debug messages */
        const Boolean DEBUG_PHONE = TRUE;

        // "Features" accessible through the connectivity manager
        const String FEATURE_ENABLE_MMS = "enableMMS";
        const String FEATURE_ENABLE_SUPL = "enableSUPL";
        const String FEATURE_ENABLE_DUN = "enableDUN";
        const String FEATURE_ENABLE_HIPRI = "enableHIPRI";
        const String FEATURE_ENABLE_DUN_ALWAYS = "enableDUNAlways";
        const String FEATURE_ENABLE_FOTA = "enableFOTA";
        const String FEATURE_ENABLE_IMS = "enableIMS";
        const String FEATURE_ENABLE_CBS = "enableCBS";
        const String FEATURE_ENABLE_EMERGENCY = "enableEmergency";

        /**
         * Optional reasons for disconnect and connect
         */
        const String REASON_ROAMING_ON = "roamingOn";
        const String REASON_ROAMING_OFF = "roamingOff";
        const String REASON_DATA_DISABLED = "dataDisabled";
        const String REASON_DATA_ENABLED = "dataEnabled";
        const String REASON_DATA_ATTACHED = "dataAttached";
        const String REASON_DATA_DETACHED = "dataDetached";
        const String REASON_CDMA_DATA_ATTACHED = "cdmaDataAttached";
        const String REASON_CDMA_DATA_DETACHED = "cdmaDataDetached";
        const String REASON_APN_CHANGED = "apnChanged";
        const String REASON_APN_SWITCHED = "apnSwitched";
        const String REASON_APN_FAILED = "apnFailed";
        const String REASON_RESTORE_DEFAULT_APN = "restoreDefaultApn";
        const String REASON_RADIO_TURNED_OFF = "radioTurnedOff";
        const String REASON_PDP_RESET = "pdpReset";
        const String REASON_VOICE_CALL_ENDED = "2GVoiceCallEnded";
        const String REASON_VOICE_CALL_STARTED = "2GVoiceCallStarted";
        const String REASON_PS_RESTRICT_ENABLED = "psRestrictEnabled";
        const String REASON_PS_RESTRICT_DISABLED = "psRestrictDisabled";
        const String REASON_SIM_LOADED = "simLoaded";
        const String REASON_NW_TYPE_CHANGED = "nwTypeChanged";
        const String REASON_DATA_DEPENDENCY_MET = "dependencyMet";
        const String REASON_DATA_DEPENDENCY_UNMET = "dependencyUnmet";
        const String REASON_LOST_DATA_CONNECTION = "lostDataConnection";
        const String REASON_CONNECTED = "connected";
        const String REASON_NV_READY = "nvReady";
        const String REASON_SINGLE_PDN_ARBITRATION = "SinglePdnArbitration";
        const String REASON_DATA_SPECIFIC_DISABLED = "specificDisabled";
        const String REASON_IWLAN_AVAILABLE = "iwlanAvailable";

        // Used for band mode selection methods
        const Int32 BM_UNSPECIFIED = 0; // selected by baseband automatically
        const Int32 BM_EURO_BAND   = 1; // GSM-900 / DCS-1800 / WCDMA-IMT-2000
        const Int32 BM_US_BAND     = 2; // GSM-850 / PCS-1900 / WCDMA-850 / WCDMA-PCS-1900
        const Int32 BM_JPN_BAND    = 3; // WCDMA-800 / WCDMA-IMT-2000
        const Int32 BM_AUS_BAND    = 4; // GSM-900 / DCS-1800 / WCDMA-850 / WCDMA-IMT-2000
        const Int32 BM_AUS2_BAND   = 5; // GSM-900 / DCS-1800 / WCDMA-850
        const Int32 BM_BOUNDARY    = 6; // upper band boundary

        // Used for preferred network type
        // Note NT_* substitute RILConstants.NETWORK_MODE_* above the Phone
        const Int32 NT_MODE_WCDMA_PREF   = 0; // IRILConstants::NETWORK_MODE_WCDMA_PREF;
        const Int32 NT_MODE_GSM_ONLY     = 1; // IRILConstants::NETWORK_MODE_GSM_ONLY;
        const Int32 NT_MODE_WCDMA_ONLY   = 2; // IRILConstants::NETWORK_MODE_WCDMA_ONLY;
        const Int32 NT_MODE_GSM_UMTS     = 3; // IRILConstants::NETWORK_MODE_GSM_UMTS;

        const Int32 NT_MODE_CDMA         = 4; // IRILConstants::NETWORK_MODE_CDMA;

        const Int32 NT_MODE_CDMA_NO_EVDO = 5; // IRILConstants::NETWORK_MODE_CDMA_NO_EVDO;
        const Int32 NT_MODE_EVDO_NO_CDMA = 6; // IRILConstants::NETWORK_MODE_EVDO_NO_CDMA;
        const Int32 NT_MODE_GLOBAL       = 7; // IRILConstants::NETWORK_MODE_GLOBAL;

        const Int32 NT_MODE_LTE_CDMA_AND_EVDO        = 8; // IRILConstants::NETWORK_MODE_LTE_CDMA_EVDO;
        const Int32 NT_MODE_LTE_GSM_WCDMA            = 9; // IRILConstants::NETWORK_MODE_LTE_GSM_WCDMA;
        const Int32 NT_MODE_LTE_CDMA_EVDO_GSM_WCDMA  = 10; // IRILConstants::NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA;
        const Int32 NT_MODE_LTE_ONLY                 = 11; // IRILConstants::NETWORK_MODE_LTE_ONLY;
        const Int32 NT_MODE_LTE_WCDMA                = 12; // IRILConstants::NETWORK_MODE_LTE_WCDMA;
        const Int32 PREFERRED_NT_MODE                = 0; // IRILConstants::PREFERRED_NETWORK_MODE;

        // const Int32 NT_MODE_TD_SCDMA_ONLY            = IRILConstants::NETWORK_MODE_TD_SCDMA_ONLY;
        // const Int32 NT_MODE_TD_SCDMA_WCDMA           = IRILConstants::NETWORK_MODE_TD_SCDMA_WCDMA;
        // const Int32 NT_MODE_TD_SCDMA_LTE             = IRILConstants::NETWORK_MODE_TD_SCDMA_LTE;
        // const Int32 NT_MODE_TD_SCDMA_GSM             = IRILConstants::NETWORK_MODE_TD_SCDMA_GSM;
        // const Int32 NT_MODE_TD_SCDMA_GSM_LTE         = IRILConstants::NETWORK_MODE_TD_SCDMA_GSM_LTE;
        // const Int32 NT_MODE_TD_SCDMA_GSM_WCDMA       = IRILConstants::NETWORK_MODE_TD_SCDMA_GSM_WCDMA;
        // const Int32 NT_MODE_TD_SCDMA_WCDMA_LTE       = IRILConstants::NETWORK_MODE_TD_SCDMA_WCDMA_LTE;
        // const Int32 NT_MODE_TD_SCDMA_GSM_WCDMA_LTE   = IRILConstants::NETWORK_MODE_TD_SCDMA_GSM_WCDMA_LTE;
        // const Int32 NT_MODE_TD_SCDMA_CDMA_EVDO_GSM_WCDMA =
        //         IRILConstants::NETWORK_MODE_TD_SCDMA_CDMA_EVDO_GSM_WCDMA;
        // const Int32 NT_MODE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA =
        //         IRILConstants::NETWORK_MODE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA;

        // Used for CDMA roaming mode
        const Int32 CDMA_RM_HOME        = 0;  // Home Networks only, as defined in PRL
        const Int32 CDMA_RM_AFFILIATED  = 1;  // Roaming an Affiliated networks, as defined in PRL
        const Int32 CDMA_RM_ANY         = 2;  // Roaming on Any Network, as defined in PRL

        // Used for CDMA subscription mode
        const Int32 CDMA_SUBSCRIPTION_UNKNOWN  =-1; // Unknown
        const Int32 CDMA_SUBSCRIPTION_RUIM_SIM = 0; // RUIM/SIM (default)
        const Int32 CDMA_SUBSCRIPTION_NV       = 1; // NV -> non-volatile memory

        const Int32 PREFERRED_CDMA_SUBSCRIPTION = CDMA_SUBSCRIPTION_NV;

        const Int32 TTY_MODE_OFF = 0;
        const Int32 TTY_MODE_FULL = 1;
        const Int32 TTY_MODE_HCO = 2;
        const Int32 TTY_MODE_VCO = 3;

        /**
         * CDMA OTA PROVISION STATUS, the same as RIL_CDMA_OTA_Status in ril.h
         */

        const Int32 CDMA_OTA_PROVISION_STATUS_SPL_UNLOCKED = 0;
        const Int32 CDMA_OTA_PROVISION_STATUS_SPC_RETRIES_EXCEEDED = 1;
        const Int32 CDMA_OTA_PROVISION_STATUS_A_KEY_EXCHANGED = 2;
        const Int32 CDMA_OTA_PROVISION_STATUS_SSD_UPDATED = 3;
        const Int32 CDMA_OTA_PROVISION_STATUS_NAM_DOWNLOADED = 4;
        const Int32 CDMA_OTA_PROVISION_STATUS_MDN_DOWNLOADED = 5;
        const Int32 CDMA_OTA_PROVISION_STATUS_IMSI_DOWNLOADED = 6;
        const Int32 CDMA_OTA_PROVISION_STATUS_PRL_DOWNLOADED = 7;
        const Int32 CDMA_OTA_PROVISION_STATUS_COMMITTED = 8;
        const Int32 CDMA_OTA_PROVISION_STATUS_OTAPA_STARTED = 9;
        const Int32 CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED = 10;
        const Int32 CDMA_OTA_PROVISION_STATUS_OTAPA_ABORTED = 11;

        /**
         * Get the current ServiceState. Use
         * <code>registerForServiceStateChanged</code> to be informed of
         * updates.
         */
        GetServiceState(
            [out] IServiceState** result);

        /**
         * Get the current CellLocation.
         */
        GetCellLocation(
            [out] ICellLocation** result);

        /**
         * @return all available cell information or null if none.
         */
        GetAllCellInfo(
            [out] IList** result);

        /**
         * Sets the minimum time in milli-seconds between {@link PhoneStateListener#onCellInfoChanged
         * PhoneStateListener.onCellInfoChanged} will be invoked.
         *
         * The default, 0, means invoke onCellInfoChanged when any of the reported
         * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue
         * A onCellInfoChanged.
         *
         * @param rateInMillis the rate
         */
        SetCellInfoListRate(
            [in] Int32 rateInMillis);

        /**
         * Get the current for the default apn DataState. No change notification
         * exists at this interface -- use
         * {@link android.telephony.PhoneStateListener} instead.
         */
        GetDataConnectionState(
            [out] PhoneConstantsDataState* result);

        /**
         * Get the current DataState. No change notification exists at this
         * interface -- use
         * {@link android.telephony.PhoneStateListener} instead.
         * @param apnType specify for which apn to get connection state info.
         */
        GetDataConnectionState(
            [in] String apnType,
            [out] PhoneConstantsDataState* result);

        /**
         * Get the current DataActivityState. No change notification exists at this
         * interface -- use
         * {@link android.telephony.TelephonyManager} instead.
         */
        GetDataActivityState(
            [out] IPhoneDataActivityState* result);

        /**
         * Gets the context for the phone, as set at initialization time.
         */
        GetContext(
            [out] IContext** result);

        /**
         * Disables the DNS check (i.e., allows "0.0.0.0").
         * Useful for lab testing environment.
         * @param b true disables the check, false enables.
         */
        DisableDnsCheck(
            [in] Boolean b);

        /**
         * Returns true if the DNS check is currently disabled.
         */
        IsDnsCheckDisabled(
            [out] Boolean* result);

        /**
         * Get current coarse-grained voice call state.
         * Use {@link #registerForPreciseCallStateChanged(Handler, int, Object)
         * registerForPreciseCallStateChanged()} for change notification. <p>
         * If the phone has an active call and call waiting occurs,
         * then the phone state is RINGING not OFFHOOK
         * <strong>Note:</strong>
         * This registration point provides notification of finer-grained
         * changes.<p>
         *
         */
        GetState(
            [out] PhoneConstantsState* result);

        /**
         * Returns a string identifier for this phone interface for parties
         *  outside the phone app process.
         *  @return The string name.
         */
        GetPhoneName(
            [out] String* result);

        /**
         * Return a numerical identifier for the phone radio interface.
         * @return PHONE_TYPE_XXX as defined above.
         */
        GetPhoneType(
            [out] Int32* result);

        /**
         * Returns an array of string identifiers for the APN types serviced by the
         * currently active.
         *  @return The string array will always return at least one entry, Phone.APN_TYPE_DEFAULT.
         * TODO: Revisit if we always should return at least one entry.
         */
        GetActiveApnTypes(
            [out, callee] ArrayOf<String>* result);

        /**
         * Returns string for the active APN host.
         *  @return type as a string or null if none.
         */
        GetActiveApnHost(
            [in] String apnType,
            [out] String* result);

        /**
         * Return the LinkProperties for the named apn or null if not available
         */
        GetLinkProperties(
            [in] String apnType,
            [out] ILinkProperties** result);

        /**
         * Return the NetworkCapabilities
         */
        GetNetworkCapabilities(
            [in] String apnType,
            [out] INetworkCapabilities** result);

        /**
         * Get current signal strength. No change notification available on this
         * interface. Use <code>PhoneStateNotifier</code> or an equivalent.
         * An ASU is 0-31 or -1 if unknown (for GSM, dBm = -113 - 2 * asu).
         * The following special values are defined:</p>
         * <ul><li>0 means "-113 dBm or less".</li>
         * <li>31 means "-51 dBm or greater".</li></ul>
         *
         * @return Current signal strength as SignalStrength
         */
        GetSignalStrength(
            [out] ISignalStrength** result);

        /**
         * Notifies when a previously untracked non-ringing/waiting connection has appeared.
         * This is likely due to some other entity (eg, SIM card application) initiating a call.
         */
        RegisterForUnknownConnection(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for unknown connection notifications.
         */
        UnregisterForUnknownConnection(
            [in] IHandler* h);

        /**
         * Notifies when a Handover happens due to SRVCC or Silent Redial
         */
        RegisterForHandoverStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for handover state notifications
         */
        UnregisterForHandoverStateChanged(
            [in] IHandler* h);

        /**
         * Register for getting notifications for change in the Call State {@link Call.State}
         * This is called PreciseCallState because the call state is more precise than the
         * {@link PhoneConstants.State} which can be obtained using the {@link PhoneStateListener}
         *
         * Resulting events will have an AsyncResult in <code>Message.obj</code>.
         * AsyncResult.userData will be set to the obj argument here.
         * The <em>h</em> parameter is held only by a weak reference.
         */
        RegisterForPreciseCallStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for voice call state change notifications.
         * Extraneous calls are tolerated silently.
         */
        UnregisterForPreciseCallStateChanged(
            [in] IHandler* h);

        /**
         * Notifies when a new ringing or waiting connection has appeared.<p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = a Connection. <p>
         *  Please check Connection.isRinging() to make sure the Connection
         *  has not dropped since this message was posted.
         *  If Connection.isRinging() is true, then
         *   Connection.getCall() == Phone.getRingingCall()
         */
        RegisterForNewRingingConnection(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for new ringing connection notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForNewRingingConnection(
            [in] IHandler* h);

        /**
         * Notifies when phone's video capabilities changes <p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = true if phone supports video calling <p>
         */
        RegisterForVideoCapabilityChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for video capability changed notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForVideoCapabilityChanged(
            [in] IHandler* h);

        /**
         * Notifies when an incoming call rings.<p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = a Connection. <p>
         */
        RegisterForIncomingRing(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for ring notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForIncomingRing(
            [in] IHandler* h);

        /**
         * Notifies when out-band ringback tone is needed.<p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = boolean, true to start play ringback tone
         *                       and false to stop. <p>
         */
        RegisterForRingbackTone(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for ringback tone notification.
         */
        UnregisterForRingbackTone(
            [in] IHandler* h);

        /**
         * Notifies when out-band on-hold tone is needed.<p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = boolean, true to start play on-hold tone
         *                       and false to stop. <p>
         */
        RegisterForOnHoldTone(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for on-hold tone notification.
         */
        UnregisterForOnHoldTone(
            [in] IHandler* h);

        /**
         * Registers the handler to reset the uplink mute state to get
         * uplink audio.
         */
        RegisterForResendIncallMute(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for resend incall mute notifications.
         */
        UnregisterForResendIncallMute(
            [in] IHandler* h);

        /**
         * Notifies when a voice connection has disconnected, either due to local
         * or remote hangup or error.
         *
         *  Messages received from this will have the following members:<p>
         *  <ul><li>Message.obj will be an AsyncResult</li>
         *  <li>AsyncResult.userObj = obj</li>
         *  <li>AsyncResult.result = a Connection object that is
         *  no longer connected.</li></ul>
         */
        RegisterForDisconnect(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for voice disconnection notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForDisconnect(
            [in] IHandler* h);

        /**
         * Register for notifications of initiation of a new MMI code request.
         * MMI codes for GSM are discussed in 3GPP TS 22.030.<p>
         *
         * Example: If Phone.dial is called with "*#31#", then the app will
         * be notified here.<p>
         *
         * The returned <code>Message.obj</code> will contain an AsyncResult.
         *
         * <code>obj.result</code> will be an "MmiCode" object.
         */
        RegisterForMmiInitiate(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for new MMI initiate notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForMmiInitiate(
            [in] IHandler* h);

        /**
         * Register for notifications that an MMI request has completed
         * its network activity and is in its final state. This may mean a state
         * of COMPLETE, FAILED, or CANCELLED.
         *
         * <code>Message.obj</code> will contain an AsyncResult.
         * <code>obj.result</code> will be an "MmiCode" object
         */
        RegisterForMmiComplete(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for MMI complete notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForMmiComplete(
            [in] IHandler* h);

        /**
         * Registration point for Ecm timer reset
         * @param h handler to notify
         * @param what user-defined message code
         * @param obj placed in Message.obj
         */
        RegisterForEcmTimerReset(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notification for Ecm timer reset
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForEcmTimerReset(
            [in] IHandler* h);

        /**
         * Returns a list of MMI codes that are pending. (They have initiated
         * but have not yet completed).
         * Presently there is only ever one.
         * Use <code>registerForMmiInitiate</code>
         * and <code>registerForMmiComplete</code> for change notification.
         */
        GetPendingMmiCodes(
            [out] IList** result);

        /**
         * Sends user response to a USSD REQUEST message.  An MmiCode instance
         * representing this response is sent to handlers registered with
         * registerForMmiInitiate.
         *
         * @param ussdMessge    Message to send in the response.
         */
        SendUssdResponse(
            [in] String ussdMessge);

        /**
         * Register for ServiceState changed.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a ServiceState instance
         */
        RegisterForServiceStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for ServiceStateChange notification.
         * Extraneous calls are tolerated silently
         */
        UnregisterForServiceStateChanged(
            [in] IHandler* h);

        /**
         * Register for Supplementary Service notifications from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a SuppServiceNotification instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForSuppServiceNotification(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for Supplementary Service notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForSuppServiceNotification(
            [in] IHandler* h);

        /**
         * Register for notifications when a supplementary service attempt fails.
         * Message.obj will contain an AsyncResult.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForSuppServiceFailed(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notifications when a supplementary service attempt fails.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForSuppServiceFailed(
            [in] IHandler* h);

        /**
         * Register for notifications when a sInCall VoicePrivacy is enabled
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForInCallVoicePrivacyOn(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unegister for notifications when a sInCall VoicePrivacy is enabled
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForInCallVoicePrivacyOn(
            [in] IHandler* h);

        /**
         * Register for notifications when a sInCall VoicePrivacy is disabled
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForInCallVoicePrivacyOff(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notifications when a sInCall VoicePrivacy is disabled
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForInCallVoicePrivacyOff(
            [in] IHandler* h);

        /**
         * Register for notifications when CDMA OTA Provision status change
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForCdmaOtaStatusChange(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notifications when CDMA OTA Provision status change
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForCdmaOtaStatusChange(
            [in] IHandler* h);

        /**
         * Registration point for subscription info ready
         * @param h handler to notify
         * @param what what code of message when delivered
         * @param obj placed in Message.obj
         */
        RegisterForSubscriptionInfoReady(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notifications for subscription info
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForSubscriptionInfoReady(
            [in] IHandler* h);

        /**
         * Registration point for Sim records loaded
         * @param h handler to notify
         * @param what what code of message when delivered
         * @param obj placed in Message.obj
         */
        RegisterForSimRecordsLoaded(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregister for notifications for Sim records loaded
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForSimRecordsLoaded(
            [in] IHandler* h);

        /**
         * Returns SIM record load state. Use
         * <code>getSimCard().registerForReady()</code> for change notification.
         *
         * @return true if records from the SIM have been loaded and are
         * available (if applicable). If not applicable to the underlying
         * technology, returns true as well.
         */
        GetIccRecordsLoaded(
            [out] Boolean* result);

        /**
         * Returns the ICC card interface for this phone, or null
         * if not applicable to underlying technology.
         */
        GetIccCard(
            [out] IIccCard** result);

        /**
         * Answers a ringing or waiting call. Active calls, if any, go on hold.
         * Answering occurs asynchronously, and final notification occurs via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         *
         * @param videoState The video state in which to answer the call.
         * @exception CallStateException when no call is ringing or waiting
         */
        AcceptCall(
            [in] Int32 videoState);

        /**
         * Deflects a ringing or waiting IMS call.
         *
         * @param number The number to deflect to.
         * @exception CallStateException when no IMS call is ringing or waiting
         */
        DeflectCall(
            [in] String number);

        /**
         * Reject (ignore) a ringing call. In GSM, this means UDUB
         * (User Determined User Busy). Reject occurs asynchronously,
         * and final notification occurs via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         *
         * @exception CallStateException when no call is ringing or waiting
         */
        RejectCall();

        /**
         * Places any active calls on hold, and makes any held calls
         *  active. Switch occurs asynchronously and may fail.
         * Final notification occurs via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         *
         * @exception CallStateException if a call is ringing, waiting, or
         * dialing/alerting. In these cases, this operation may not be performed.
         */
        SwitchHoldingAndActive();

        /**
         * Whether or not the phone can conference in the current phone
         * state--that is, one call holding and one call active.
         * @return true if the phone can conference; false otherwise.
         */
        CanConference(
            [out] Boolean* result);

        /**
         * Conferences holding and active. Conference occurs asynchronously
         * and may fail. Final notification occurs via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         *
         * @exception CallStateException if canConference() would return false.
         * In these cases, this operation may not be performed.
         */
        Conference();

        /**
         * Enable or disable enhanced Voice Privacy (VP). If enhanced VP is
         * disabled, normal VP is enabled.
         *
         * @param enable whether true or false to enable or disable.
         * @param onComplete a callback message when the action is completed.
         */
        EnableEnhancedVoicePrivacy(
            [in] Boolean enbl,
            [in] IMessage* onComplete);

        /**
         * Get the currently set Voice Privacy (VP) mode.
         *
         * @param onComplete a callback message when the action is completed.
         */
        GetEnhancedVoicePrivacy(
            [in] IMessage* onComplete);

        /**
         * Whether or not the phone can do explicit call transfer in the current
         * phone state--that is, one call holding and one call active.
         * @return true if the phone can do explicit call transfer; false otherwise.
         */
        CanTransfer(
            [out] Boolean* result);

        /**
         * Connects the two calls and disconnects the subscriber from both calls
         * Explicit Call Transfer occurs asynchronously
         * and may fail. Final notification occurs via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         *
         * @exception CallStateException if canTransfer() would return false.
         * In these cases, this operation may not be performed.
         */
        ExplicitCallTransfer();

        /**
         * Clears all DISCONNECTED connections from Call connection lists.
         * Calls that were in the DISCONNECTED state become idle. This occurs
         * synchronously.
         */
        ClearDisconnected();

        /**
         * Gets the foreground call object, which represents all connections that
         * are dialing or active (all connections
         * that have their audio path connected).<p>
         *
         * The foreground call is a singleton object. It is constant for the life
         * of this phone. It is never null.<p>
         *
         * The foreground call will only ever be in one of these states:
         * IDLE, ACTIVE, DIALING, ALERTING, or DISCONNECTED.
         *
         * State change notification is available via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         */
        GetForegroundCall(
            [out] ICall** result);

        /**
         * Gets the background call object, which represents all connections that
         * are holding (all connections that have been accepted or connected, but
         * do not have their audio path connected). <p>
         *
         * The background call is a singleton object. It is constant for the life
         * of this phone object . It is never null.<p>
         *
         * The background call will only ever be in one of these states:
         * IDLE, HOLDING or DISCONNECTED.
         *
         * State change notification is available via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         */
        GetBackgroundCall(
            [out] ICall** result);

        /**
         * Gets the ringing call object, which represents an incoming
         * connection (if present) that is pending answer/accept. (This connection
         * may be RINGING or WAITING, and there may be only one.)<p>

         * The ringing call is a singleton object. It is constant for the life
         * of this phone. It is never null.<p>
         *
         * The ringing call will only ever be in one of these states:
         * IDLE, INCOMING, WAITING or DISCONNECTED.
         *
         * State change notification is available via
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}.
         */
        GetRingingCall(
            [out] ICall** result);

        /**
         * Initiate a new voice connection. This happens asynchronously, so you
         * cannot assume the audio path is connected (or a call index has been
         * assigned) until PhoneStateChanged notification has occurred.
         *
         * @param dialString The dial string.
         * @param videoState The desired video state for the connection.
         * @exception CallStateException if a new outgoing call is not currently
         * possible because no more call slots exist or a call exists that is
         * dialing, alerting, ringing, or waiting.  Other errors are
         * handled asynchronously.
         */
        Dial(
            [in] String dialString,
            [in] Int32 videoState,
            [out] IConnection** result);

        /**
         * Initiate a new voice connection. This happens asynchronously, so you
         * cannot assume the audio path is connected (or a call index has been
         * assigned) until PhoneStateChanged notification has occurred.
         *
         * @param dialString The dial string.
         * @param videoState The desired video state for the connection.
         * @param extras Additional (meta) call information.
         *        OEMs can pass call extras (additional call info) Bundle
         *        in the following format:
         *        1) All values in the Bundle must be of type String
         *        2) Keys for the values are defined in ImsCallProfile.java
         * @exception CallStateException if a new outgoing call is not currently
         *                possible because no more call slots exist or a call exists
         *                that is dialing, alerting, ringing, or waiting. Other
         *                errors are handled asynchronously.
         */
        Dial(
            [in] String dialString,
            [in] Int32 videoState,
            [in] IBundle* extras,
            [out] IConnection** result);

        /**
         * Initiate a new voice connection with supplementary User to User
         * Information. This happens asynchronously, so you cannot assume the audio
         * path is connected (or a call index has been assigned) until
         * PhoneStateChanged notification has occurred.
         *
         * @param dialString The dial string.
         * @param uusInfo The UUSInfo.
         * @param videoState The desired video state for the connection.
         * @exception CallStateException if a new outgoing call is not currently
         *                possible because no more call slots exist or a call exists
         *                that is dialing, alerting, ringing, or waiting. Other
         *                errors are handled asynchronously.
         */
        Dial(
            [in] String dialString,
            [in] IUUSInfo* uusInfo,
            [in] Int32 videoState,
            [out] IConnection** result);

        /**
         * Initiate to add a participant in an IMS call.
         * This happens asynchronously, so you cannot assume the audio path is
         * connected (or a call index has been assigned) until PhoneStateChanged
         * notification has occurred.
         *
         * @exception CallStateException if a new outgoing call is not currently
         *                possible because no more call slots exist or a call exists
         *                that is dialing, alerting, ringing, or waiting. Other
         *                errors are handled asynchronously.
         */
        AddParticipant(
            [in] String dialString);

        /**
         * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated
         * without SEND (so <code>dial</code> is not appropriate).
         *
         * @param dialString the MMI command to be executed.
         * @return true if MMI command is executed.
         */
        HandlePinMmi(
            [in] String dialString,
            [out] Boolean* result);

        /**
         * Handles in-call MMI commands. While in a call, or while receiving a
         * call, use this to execute MMI commands.
         * see 3GPP 20.030, section 6.5.5.1 for specs on the allowed MMI commands.
         *
         * @param command the MMI command to be executed.
         * @return true if the MMI command is executed.
         * @throws CallStateException
         */
        HandleInCallMmiCommands(
            [in] String command,
            [out] Boolean* result);

        /**
         * Play a DTMF tone on the active call. Ignored if there is no active call.
         * @param c should be one of 0-9, '*' or '#'. Other values will be
         * silently ignored.
         */
        SendDtmf(
            [in] Char32 c);

        /**
         * Start to paly a DTMF tone on the active call. Ignored if there is no active call
         * or there is a playing DTMF tone.
         * @param c should be one of 0-9, '*' or '#'. Other values will be
         * silently ignored.
         */
        StartDtmf(
            [in] Char32 c);

        /**
         * Stop the playing DTMF tone. Ignored if there is no playing DTMF
         * tone or no active call.
         */
        StopDtmf();

        /**
         * send burst DTMF tone, it can send the string as single character or multiple character
         * ignore if there is no active call or not valid digits string.
         * Valid digit means only includes characters ISO-LATIN characters 0-9, *, #
         * The difference between sendDtmf and sendBurstDtmf is sendDtmf only sends one character,
         * this api can send single character and multiple character, also, this api has response
         * back to caller.
         *
         * @param dtmfString is string representing the dialing digit(s) in the active call
         * @param on the DTMF ON length in milliseconds, or 0 for default
         * @param off the DTMF OFF length in milliseconds, or 0 for default
         * @param onComplete is the callback message when the action is processed by BP
         *
         */
        SendBurstDtmf(
            [in] String dtmfString,
            [in] Int32 on,
            [in] Int32 off,
            [in] IMessage* onComplete);

        /**
         * Sets the radio power on/off state (off is sometimes
         * called "airplane mode"). Current state can be gotten via
         * {@link #getServiceState()}.{@link
         * android.telephony.ServiceState#getState() getState()}.
         * <strong>Note: </strong>This request is asynchronous.
         * getServiceState().getState() will not change immediately after this call.
         * registerForServiceStateChanged() to find out when the
         * request is complete.
         *
         * @param power true means "on", false means "off".
         */
        SetRadioPower(
            [in] Boolean power);

        /**
         * Get voice message waiting indicator status. No change notification
         * available on this interface. Use PhoneStateNotifier or similar instead.
         *
         * @return true if there is a voice message waiting
         */
        GetMessageWaitingIndicator(
            [out] Boolean* result);

        /**
         * Get voice call forwarding indicator status. No change notification
         * available on this interface. Use PhoneStateNotifier or similar instead.
         *
         * @return true if there is a voice call forwarding
         */
        GetCallForwardingIndicator(
            [out] Boolean* result);

        /**
         * Get the line 1 phone number (MSISDN). For CDMA phones, the MDN is returned
         * and {@link #getMsisdn()} will return the MSISDN on CDMA/LTE phones.<p>
         *
         * @return phone number. May return null if not
         * available or the SIM is not ready
         */
        GetLine1Number(
            [out] String* result);

        /**
         * Returns the alpha tag associated with the msisdn number.
         * If there is no alpha tag associated or the record is not yet available,
         * returns a default localized string. <p>
         */
        GetLine1AlphaTag(
            [out] String* result);

        /**
         * Sets the MSISDN phone number in the SIM card.
         *
         * @param alphaTag the alpha tag associated with the MSISDN phone number
         *        (see getMsisdnAlphaTag)
         * @param number the new MSISDN phone number to be set on the SIM.
         * @param onComplete a callback message when the action is completed.
         */
        SetLine1Number(
            [in] String alphaTag,
            [in] String number,
            [in] IMessage* onComplete);

        /**
         * Get the voice mail access phone number. Typically dialed when the
         * user holds the "1" key in the phone app. May return null if not
         * available or the SIM is not ready.<p>
         */
        GetVoiceMailNumber(
            [out] String* result);

        /**
         * Returns unread voicemail count. This count is shown when the  voicemail
         * notification is expanded.<p>
         */
        GetVoiceMessageCount(
            [out] Int32* result);

        /**
         * Returns the alpha tag associated with the voice mail number.
         * If there is no alpha tag associated or the record is not yet available,
         * returns a default localized string. <p>
         *
         * Please use this value instead of some other localized string when
         * showing a name for this number in the UI. For example, call log
         * entries should show this alpha tag. <p>
         *
         * Usage of this alpha tag in the UI is a common carrier requirement.
         */
        GetVoiceMailAlphaTag(
            [out] String* result);

        /**
         * setVoiceMailNumber
         * sets the voicemail number in the SIM card.
         *
         * @param alphaTag the alpha tag associated with the voice mail number
         *        (see getVoiceMailAlphaTag)
         * @param voiceMailNumber the new voicemail number to be set on the SIM.
         * @param onComplete a callback message when the action is completed.
         */
        SetVoiceMailNumber(
            [in] String alphaTag,
            [in] String voiceMailNumber,
            [in] IMessage* onComplete);

        /**
         * getCallForwardingOptions
         * gets a call forwarding option. The return value of
         * ((AsyncResult)onComplete.obj) is an array of CallForwardInfo.
         *
         * @param commandInterfaceCFReason is one of the valid call forwarding
         *        CF_REASONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param onComplete a callback message when the action is completed.
         *        @see com.android.internal.telephony.CallForwardInfo for details.
         */
        GetCallForwardingOption(
            [in] Int32 commandInterfaceCFReason,
            [in] IMessage* onComplete);

        /**
         * getCallForwardingUncondTimerOptions
         * gets a call forwarding option. The return value of
         * ((AsyncResult)onComplete.obj) is an array of CallForwardInfo.
         *
         * @param commandInterfaceCFReason is one of the valid call forwarding
         *        CF_REASONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param onComplete a callback message when the action is completed.
         *        @see com.android.internal.telephony.CallForwardInfo for details.
         */
        GetCallForwardingUncondTimerOption(
            [in] Int32 commandInterfaceCFReason,
            [in] IMessage* onComplete);

        /**
         * setCallForwardingOptions
         * sets a call forwarding option.
         *
         * @param commandInterfaceCFReason is one of the valid call forwarding
         *        CF_REASONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param commandInterfaceCFAction is one of the valid call forwarding
         *        CF_ACTIONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param dialingNumber is the target phone number to forward calls to
         * @param timerSeconds is used by CFNRy to indicate the timeout before
         *        forwarding is attempted.
         * @param onComplete a callback message when the action is completed.
         */
        SetCallForwardingOption(
            [in] Int32 commandInterfaceCFReason,
            [in] Int32 commandInterfaceCFAction,
            [in] String dialingNumber,
            [in] Int32 timerSeconds,
            [in] IMessage* onComplete);

        /**
         * setCallForwardingUncondTimerOptions
         * sets a call forwarding unconditional Timer option.
         *
         * @param startHour indicates starting hour
         * @param startMinute indicates starting minute
         * @param endHour indicates ending hour
         * @param endMinute indicates ending minute
         * @param commandInterfaceCFReason is one of the valid call forwarding
         *        CF_REASONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param commandInterfaceCFAction is one of the valid call forwarding
         *        CF_ACTIONS, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface.</code>
         * @param dialingNumber is the target phone number to forward calls to
         * @param onComplete a callback message when the action is completed.
         */
        SetCallForwardingUncondTimerOption(
            [in] Int32 startHour,
            [in] Int32 startMinute,
            [in] Int32 endHour,
            [in] Int32 endMinute,
            [in] Int32 commandInterfaceCFReason,
            [in] Int32 commandInterfaceCFAction,
            [in] String dialingNumber,
            [in] IMessage* onComplete);

        /**
         * getOutgoingCallerIdDisplay
         * gets outgoing caller id display. The return value of
         * ((AsyncResult)onComplete.obj) is an array of int, with a length of 2.
         *
         * @param onComplete a callback message when the action is completed.
         *        @see com.android.internal.telephony.CommandsInterface#getCLIR for details.
         */
        GetOutgoingCallerIdDisplay(
            [in] IMessage* onComplete);

        /**
         * setOutgoingCallerIdDisplay
         * sets a call forwarding option.
         *
         * @param commandInterfaceCLIRMode is one of the valid call CLIR
         *        modes, as defined in
         *        <code>com.android.internal.telephony.CommandsInterface./code>
         * @param onComplete a callback message when the action is completed.
         */
        SetOutgoingCallerIdDisplay(
            [in] Int32 commandInterfaceCLIRMode,
            [in] IMessage* onComplete);

        /**
         * getCallWaiting
         * gets call waiting activation state. The return value of
         * ((AsyncResult)onComplete.obj) is an array of int, with a length of 1.
         *
         * @param onComplete a callback message when the action is completed.
         *        @see com.android.internal.telephony.CommandsInterface#queryCallWaiting for details.
         */
        GetCallWaiting(
            [in] IMessage* onComplete);

        /**
         * setCallWaiting
         * sets a call forwarding option.
         *
         * @param enable is a Boolean representing the state that you are
         *        requesting, true for enabled, false for disabled.
         * @param onComplete a callback message when the action is completed.
         */
        SetCallWaiting(
            [in] Boolean enbl,
            [in] IMessage* onComplete);

        /**
         * Scan available networks. This method is asynchronous; .
         * On completion, <code>response.obj</code> is set to an AsyncResult with
         * one of the following members:.<p>
         *<ul>
         * <li><code>response.obj.result</code> will be a <code>List</code> of
         * <code>OperatorInfo</code> objects, or</li>
         * <li><code>response.obj.exception</code> will be set with an exception
         * on failure.</li>
         * </ul>
         */
        GetAvailableNetworks(
            [in] IMessage* response);

        /**
         * Switches network selection mode to "automatic", re-scanning and
         * re-selecting a network if appropriate.
         *
         * @param response The message to dispatch when the network selection
         * is complete.
         *
         * @see #selectNetworkManually(OperatorInfo, android.os.Message )
         */
        SetNetworkSelectionModeAutomatic(
            [in] IMessage* response);

        /**
         * Manually selects a network. <code>response</code> is
         * dispatched when this is complete.  <code>response.obj</code> will be
         * an AsyncResult, and <code>response.obj.exception</code> will be non-null
         * on failure.
         *
         * @see #setNetworkSelectionModeAutomatic(Message)
         */
        SelectNetworkManually(
            [in] IOperatorInfo* network,
            [in] IMessage* response);

        /**
         *  Requests to set the preferred network type for searching and registering
         * (CS/PS domain, RAT, and operation mode)
         * @param networkType one of  NT_*_TYPE
         * @param response is callback message
         */
        SetPreferredNetworkType(
            [in] Int32 networkType,
            [in] IMessage* response);

        /**
         *  Query the preferred network type setting
         *
         * @param response is callback message to report one of  NT_*_TYPE
         */
        GetPreferredNetworkType(
            [in] IMessage* response);

        /**
         * Gets the default SMSC address.
         *
         * @param result Callback message contains the SMSC address.
         */
        GetSmscAddress(
            [in] IMessage* result);

        /**
         * Sets the default SMSC address.
         *
         * @param address new SMSC address
         * @param result Callback message is empty on completion
         */
        SetSmscAddress(
            [in] String address,
            [in] IMessage* result);

        /**
         * Query neighboring cell IDs.  <code>response</code> is dispatched when
         * this is complete.  <code>response.obj</code> will be an AsyncResult,
         * and <code>response.obj.exception</code> will be non-null on failure.
         * On success, <code>AsyncResult.result</code> will be a <code>String[]</code>
         * containing the neighboring cell IDs.  Index 0 will contain the count
         * of available cell IDs.  Cell IDs are in hexadecimal format.
         *
         * @param response callback message that is dispatched when the query
         * completes.
         */
        GetNeighboringCids(
            [in] IMessage* response);

        /**
         * Sets an event to be fired when the telephony system processes
         * a post-dial character on an outgoing call.<p>
         *
         * Messages of type <code>what</code> will be sent to <code>h</code>.
         * The <code>obj</code> field of these Message's will be instances of
         * <code>AsyncResult</code>. <code>Message.obj.result</code> will be
         * a Connection object.<p>
         *
         * Message.arg1 will be the post dial character being processed,
         * or 0 ('\0') if end of string.<p>
         *
         * If Connection.getPostDialState() == WAIT,
         * the application must call
         * {@link com.android.internal.telephony.Connection#proceedAfterWaitChar()
         * Connection.proceedAfterWaitChar()} or
         * {@link com.android.internal.telephony.Connection#cancelPostDial()
         * Connection.cancelPostDial()}
         * for the telephony system to continue playing the post-dial
         * DTMF sequence.<p>
         *
         * If Connection.getPostDialState() == WILD,
         * the application must call
         * {@link com.android.internal.telephony.Connection#proceedAfterWildChar
         * Connection.proceedAfterWildChar()}
         * or
         * {@link com.android.internal.telephony.Connection#cancelPostDial()
         * Connection.cancelPostDial()}
         * for the telephony system to continue playing the
         * post-dial DTMF sequence.<p>
         *
         * Only one post dial character handler may be set. <p>
         * Calling this method with "h" equal to null unsets this handler.<p>
         */
        SetOnPostDialCharacter(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Mutes or unmutes the microphone for the active call. The microphone
         * is automatically unmuted if a call is answered, dialed, or resumed
         * from a holding state.
         *
         * @param muted true to mute the microphone,
         * false to activate the microphone.
         */
        SetMute(
            [in] Boolean muted);

        /**
         * Gets current mute status. Use
         * {@link #registerForPreciseCallStateChanged(android.os.Handler, int,
         * java.lang.Object) registerForPreciseCallStateChanged()}
         * as a change notifcation, although presently phone state changed is not
         * fired when setMute() is called.
         *
         * @return true is muting, false is unmuting
         */
        GetMute(
            [out] Boolean* result);

        /**
         * Enables or disables echo suppression.
         */
        SetEchoSuppressionEnabled();

        /**
         * Invokes RIL_REQUEST_OEM_HOOK_RAW on RIL implementation.
         *
         * @param data The data for the request.
         * @param response <strong>On success</strong>,
         * (byte[])(((AsyncResult)response.obj).result)
         * <strong>On failure</strong>,
         * (((AsyncResult)response.obj).result) == null and
         * (((AsyncResult)response.obj).exception) being an instance of
         * com.android.internal.telephony.gsm.CommandException
         *
         * @see #invokeOemRilRequestRaw(byte[], android.os.Message)
         */
        InvokeOemRilRequestRaw(
            [in] ArrayOf<Byte>* data,
            [in] IMessage* response);

        /**
         * Invokes RIL_REQUEST_OEM_HOOK_Strings on RIL implementation.
         *
         * @param strings The strings to make available as the request data.
         * @param response <strong>On success</strong>, "response" bytes is
         * made available as:
         * (String[])(((AsyncResult)response.obj).result).
         * <strong>On failure</strong>,
         * (((AsyncResult)response.obj).result) == null and
         * (((AsyncResult)response.obj).exception) being an instance of
         * com.android.internal.telephony.gsm.CommandException
         *
         * @see #invokeOemRilRequestStrings(java.lang.String[], android.os.Message)
         */
        InvokeOemRilRequestStrings(
            [in] ArrayOf<String>* strings,
            [in] IMessage* response);

        /**
         * Get the current active Data Call list
         *
         * @param response <strong>On success</strong>, "response" bytes is
         * made available as:
         * (String[])(((AsyncResult)response.obj).result).
         * <strong>On failure</strong>,
         * (((AsyncResult)response.obj).result) == null and
         * (((AsyncResult)response.obj).exception) being an instance of
         * com.android.internal.telephony.gsm.CommandException
         */
        GetDataCallList(
            [in] IMessage* response);

        /**
         * Update the ServiceState CellLocation for current network registration.
         */
        UpdateServiceLocation();

        /**
         * Enable location update notifications.
         */
        EnableLocationUpdates();

        /**
         * Disable location update notifications.
         */
        DisableLocationUpdates();

        /**
         * For unit tests; don't send notifications to "Phone"
         * mailbox registrants if true.
         */
        SetUnitTestMode(
            [in] Boolean f);

        /**
         * @return true If unit test mode is enabled
         */
        GetUnitTestMode(
            [out] Boolean* result);

        /**
         * Assign a specified band for RF configuration.
         *
         * @param bandMode one of BM_*_BAND
         * @param response is callback message
         */
        SetBandMode(
            [in] Int32 bandMode,
            [in] IMessage* response);

        /**
         * Query the list of band mode supported by RF.
         *
         * @param response is callback message
         *        ((AsyncResult)response.obj).result  is an int[] where int[0] is
         *        the size of the array and the rest of each element representing
         *        one available BM_*_BAND
         */
        QueryAvailableBandMode(
            [in] IMessage* response);

        /**
         * @return true if enable data connection on roaming
         */
        GetDataRoamingEnabled(
            [out] Boolean* result);

        /**
         * @param enable set true if enable data connection on roaming
         */
        SetDataRoamingEnabled(
            [in] Boolean enbl);

        /**
         * @return true if user has enabled data
         */
        GetDataEnabled(
            [out] Boolean* result);

        /**
         * @param @enable set {@code true} if enable data connection
         */
        SetDataEnabled(
            [in] Boolean enbl);

        /**
         *  Query the CDMA roaming preference setting
         *
         * @param response is callback message to report one of  CDMA_RM_*
         */
        QueryCdmaRoamingPreference(
            [in] IMessage* response);

        /**
         *  Requests to set the CDMA roaming preference
         * @param cdmaRoamingType one of  CDMA_RM_*
         * @param response is callback message
         */
        SetCdmaRoamingPreference(
            [in] Int32 cdmaRoamingType,
            [in] IMessage* response);

        /**
         *  Requests to set the CDMA subscription mode
         * @param cdmaSubscriptionType one of  CDMA_SUBSCRIPTION_*
         * @param response is callback message
         */
        SetCdmaSubscription(
            [in] Int32 cdmaSubscriptionType,
            [in] IMessage* response);

        /**
         * If this is a simulated phone interface, returns a SimulatedRadioControl.
         * @return SimulatedRadioControl if this is a simulated interface;
         * otherwise, null.
         */
        // GetSimulatedRadioControl(
        //    [out] ISimulatedRadioControl** result);

        /**
         * Report on whether data connectivity is allowed.
         */
        IsDataConnectivityPossible(
            [out] Boolean* result);

        /**
         * Report on whether on-demand data connectivity is allowed.
         */
        IsOnDemandDataPossible(
            [in] String apnType,
            [out] Boolean* result);

        /**
         * Report on whether data connectivity is allowed for an APN.
         */
        IsDataConnectivityPossible(
            [in] String apnType,
            [out] Boolean* result);

        /**
         * Retrieves the unique device ID, e.g., IMEI for GSM phones and MEID for CDMA phones.
         */
        GetDeviceId(
            [out] String* result);

        /**
         * Retrieves the software version number for the device, e.g., IMEI/SV
         * for GSM phones.
         */
        GetDeviceSvn(
            [out] String* result);

        /**
         * Retrieves the unique subscriber ID, e.g., IMSI for GSM phones.
         */
        GetSubscriberId(
            [out] String* result);

        /**
         * Retrieves the Group Identifier Level1 for GSM phones.
         */
        GetGroupIdLevel1(
            [out] String* result);

        /**
         * Retrieves the serial number of the ICC, if applicable.
         */
        GetIccSerialNumber(
            [out] String* result);

        /* CDMA support methods */

        /**
         * Retrieves the MIN for CDMA phones.
         */
        GetCdmaMin(
            [out] String* result);

        /**
         * Check if subscription data has been assigned to mMin
         *
         * return true if MIN info is ready; false otherwise.
         */
        IsMinInfoReady(
            [out] Boolean* result);

        /**
         *  Retrieves PRL Version for CDMA phones
         */
        GetCdmaPrlVersion(
            [out] String* result);

        /**
         * Retrieves the ESN for CDMA phones.
         */
        GetEsn(
            [out] String* result);

        /**
         * Retrieves MEID for CDMA phones.
         */
        GetMeid(
            [out] String* result);

        /**
         * Retrieves the MSISDN from the UICC. For GSM/UMTS phones, this is equivalent to
         * {@link #getLine1Number()}. For CDMA phones, {@link #getLine1Number()} returns
         * the MDN, so this method is provided to return the MSISDN on CDMA/LTE phones.
         */
        GetMsisdn(
            [out] String* result);

        /**
         * Retrieves IMEI for phones. Returns null if IMEI is not set.
         */
        GetImei(
            [out] String* result);

        /**
         * Retrieves the PhoneSubInfo of the Phone
         */
        GetPhoneSubInfo(
            [out] IPhoneSubInfo** result);

        /**
         * Retrieves the IccPhoneBookInterfaceManager of the Phone
         */
        GetIccPhoneBookInterfaceManager(
            [out] IIccPhoneBookInterfaceManager** result);

        /**
         * setTTYMode
         * sets a TTY mode option.
         * @param ttyMode is a one of the following:
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_OFF}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_FULL}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_HCO}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_VCO}
         * @param onComplete a callback message when the action is completed
         */
        SetTTYMode(
            [in] Int32 ttyMode,
            [in] IMessage* onComplete);

        /**
         * setUiTTYMode
         * sets a TTY mode option.
         * @param ttyMode is a one of the following:
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_OFF}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_FULL}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_HCO}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_VCO}
         * @param onComplete a callback message when the action is completed
         */
        SetUiTTYMode(
            [in] Int32 uiTtyMode,
            [in] IMessage* onComplete);

        /**
         * queryTTYMode
         * query the status of the TTY mode
         *
         * @param onComplete a callback message when the action is completed.
         */
        QueryTTYMode(
            [in] IMessage* onComplete);

        /**
         * Activate or deactivate cell broadcast SMS.
         *
         * @param activate
         *            0 = activate, 1 = deactivate
         * @param response
         *            Callback message is empty on completion
         */
        ActivateCellBroadcastSms(
            [in] Int32 activate,
            [in] IMessage* response);

        /**
         * Query the current configuration of cdma cell broadcast SMS.
         *
         * @param response
         *            Callback message is empty on completion
         */
        GetCellBroadcastSmsConfig(
            [in] IMessage* response);

        /**
         * Configure cell broadcast SMS.
         *
         * TODO: Change the configValuesArray to a RIL_BroadcastSMSConfig
         *
         * @param response
         *            Callback message is empty on completion
         */
        SetCellBroadcastSmsConfig(
            [in] ArrayOf<Int32>* configValuesArray,
            [in] IMessage* response);

        NotifyDataActivity();

        /**
         * Returns the CDMA ERI icon index to display
         */
        GetCdmaEriIconIndex(
            [out] Int32* result);

        /**
         * Returns the CDMA ERI icon mode,
         * 0 - ON
         * 1 - FLASHING
         */
        GetCdmaEriIconMode(
            [out] Int32* result);

        /**
         * Returns the CDMA ERI text,
         */
        GetCdmaEriText(
            [out] String* result);

        /**
         * request to exit emergency call back mode
         * the caller should use setOnECMModeExitResponse
         * to receive the emergency callback mode exit response
         */
        ExitEmergencyCallbackMode();

        /**
         * this decides if the dial number is OTA(Over the air provision) number or not
         * @param dialStr is string representing the dialing digit(s)
         * @return  true means the dialStr is OTA number, and false means the dialStr is not OTA number
         */
        IsOtaSpNumber(
            [in] String dialStr,
            [out] Boolean* result);

        /**
         * Returns true if OTA Service Provisioning needs to be performed.
         */
        NeedsOtaServiceProvisioning(
            [out] Boolean* result);

        /**
         * Register for notifications when CDMA call waiting comes
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForCallWaiting(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unegister for notifications when CDMA Call waiting comes
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForCallWaiting(
            [in] IHandler* h);

        /**
         * Register for signal information notifications from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a SuppServiceNotification instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForSignalInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for signal information notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForSignalInfo(
            [in] IHandler* h);

        /**
         * Register for display information notifications from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a SuppServiceNotification instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForDisplayInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for display information notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForDisplayInfo(
            [in] IHandler* h);

        /**
         * Register for CDMA number information record notification from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a CdmaInformationRecords.CdmaNumberInfoRec
         * instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForNumberInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for number information record notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForNumberInfo(
            [in] IHandler* h);

        /**
         * Register for CDMA redirected number information record notification
         * from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a CdmaInformationRecords.CdmaRedirectingNumberInfoRec
         * instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForRedirectedNumberInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for redirected number information record notification.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForRedirectedNumberInfo(
            [in] IHandler* h);

        /**
         * Register for CDMA line control information record notification
         * from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a CdmaInformationRecords.CdmaLineControlInfoRec
         * instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForLineControlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for line control information notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForLineControlInfo(
            [in] IHandler* h);

        /**
         * Register for CDMA T53 CLIR information record notifications
         * from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a CdmaInformationRecords.CdmaT53ClirInfoRec
         * instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterFoT53ClirlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for T53 CLIR information record notification
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForT53ClirInfo(
            [in] IHandler* h);

        /**
         * Register for CDMA T53 audio control information record notifications
         * from the network.
         * Message.obj will contain an AsyncResult.
         * AsyncResult.result will be a CdmaInformationRecords.CdmaT53AudioControlInfoRec
         * instance.
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForT53AudioControlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for T53 audio control information record notifications.
         * Extraneous calls are tolerated silently
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnregisterForT53AudioControlInfo(
            [in] IHandler* h);

        /**
         * registers for exit emergency call back mode request response
         *
         * @param h Handler that receives the notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnEcbModeExitResponse(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Unregisters for exit emergency call back mode request response
         *
         * @param h Handler to be removed from the registrant list.
         */
        UnsetOnEcbModeExitResponse(
            [in] IHandler* h);

        /**
         * Return if the current radio is LTE on CDMA. This
         * is a tri-state return value as for a period of time
         * the mode may be unknown.
         *
         * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}
         * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}
         */
        GetLteOnCdmaMode(
            [out] Int32* result);

        /**
         * Return if the current radio is LTE on GSM
         * @hide
         */
        GetLteOnGsmMode(
            [out] Int32* result);

        /**
         * TODO: Adding a function for each property is not good.
         * A fucntion of type getPhoneProp(propType) where propType is an
         * enum of GSM+CDMA+LTE props would be a better approach.
         *
         * Get "Restriction of menu options for manual PLMN selection" bit
         * status from EF_CSP data, this belongs to "Value Added Services Group".
         * @return true if this bit is set or EF_CSP data is unavailable,
         * false otherwise
         */
        IsCspPlmnEnabled(
            [out] Boolean* result);

        /* Checks if manual network selection is allowed
         * @return true if manual network selection is allowed
         * @return false if manual network selection is not allowed
         */
        IsManualNetSelAllowed(
            [out] Boolean* result);

        /**
         * Return an interface to retrieve the ISIM records for IMS, if available.
         * @return the interface to retrieve the ISIM records, or null if not supported
         */
        GetIsimRecords(
            [out] IIsimRecords** result);

        /**
         * Sets the SIM voice message waiting indicator records.
         * @param line GSM Subscriber Profile Number, one-based. Only '1' is supported
         * @param countWaiting The number of messages waiting, if known. Use
         *                     -1 to indicate that an unknown number of
         *                      messages are waiting
         */
        SetVoiceMessageWaiting(
            [in] Int32 line,
            [in] Int32 countWaiting);

        /**
         * Gets the USIM service table from the UICC, if present and available.
         * @return an interface to the UsimServiceTable record, or null if not available
         */
        GetUsimServiceTable(
            [out] IUsimServiceTable** result);

        /**
         * Gets the Uicc card corresponding to this phone.
         * @return the UiccCard object corresponding to the phone ID.
         */
        GetUiccCard(
            [out] IUiccCard** result);

        /**
         * Unregister from all events it registered for and dispose objects
         * created by this object.
         */
        Dispose();

        /**
         * Remove references to external object stored in this object.
         */
        RemoveReferences();

        GetCallBarringOption(
            [in] String facility,
            [in] String password,
            [in] IMessage* onComplete);

        SetCallBarringOption(
            [in] String facility,
            [in] Boolean lockState,
            [in] String password,
            [in] IMessage* onComplete);

        RequestChangeCbPsw(
            [in] String facility,
            [in] String oldPwd,
            [in] String newPwd,
            [in] IMessage* result);

        /**
         * Update the phone object if the voice radio technology has changed
         *
         * @param voiceRadioTech The new voice radio technology
         */
        UpdatePhoneObject(
            [in] Int32 voiceRadioTech);

        /**
         * Read one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.
         * Used for device configuration by some CDMA operators.
         *
         * @param itemID the ID of the item to read
         * @param response callback message with the String response in the obj field
         */
        NvReadItem(
            [in] Int32 itemID,
            [in] IMessage* response);

        /**
         * Write one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.
         * Used for device configuration by some CDMA operators.
         *
         * @param itemID the ID of the item to read
         * @param itemValue the value to write, as a String
         * @param response Callback message.
         */
        NvWriteItem(
            [in] Int32 itemID,
            [in] String itemValue,
            [in] IMessage* response);

        /**
         * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.
         * Used for device configuration by some CDMA operators.
         *
         * @param preferredRoamingList byte array containing the new PRL
         * @param response Callback message.
         */
        NvWriteCdmaPrl(
            [in] ArrayOf<Byte>* preferredRoamingList,
            [in] IMessage* response);

        /**
         * Perform the specified type of NV config reset. The radio will be taken offline
         * and the device must be rebooted after erasing the NV. Used for device
         * configuration by some CDMA operators.
         *
         * @param resetType reset type: 1: reload NV reset, 2: erase NV reset, 3: factory NV reset
         * @param response Callback message.
         */
        NvResetConfig(
            [in] Int32 resetType,
            [in] IMessage* response);

        /*
         * Returns the subscription id.
         */
        GetSubId(
            [out] Int64* result);

        /*
         * Returns the phone id.
         */
        GetPhoneId(
            [out] Int32* result);

        /**
         * Get P-CSCF address from PCO after data connection is established or modified.
         * @param apnType the apnType, "ims" for IMS APN, "emergency" for EMERGENCY APN
         */
        GetPcscfAddress(
            [in] String apnType,
            [out, callee] ArrayOf<String>* result);

        /**
         * Set IMS registration state
         */
        SetImsRegistrationState(
            [in] Boolean registered);

        /**
         * Return the ImsPhone phone co-managed with this phone
         * @return an instance of an ImsPhone phone
         */
        GetImsPhone(
            [out] IPhone** result);

        /**
         * Release the local instance of the ImsPhone and disconnect from
         * the phone.
         * @return the instance of the ImsPhone phone previously owned
         */
        RelinquishOwnershipOfImsPhone(
            [out] IImsPhone** result);

        /**
         * Take ownership and wire-up the input ImsPhone
         * @param imsPhone ImsPhone to be used.
         */
        AcquireOwnershipOfImsPhone(
            [in] IImsPhone* imsPhone);

        /**
         * Return the service state of mImsPhone if it is STATE_IN_SERVICE
         * otherwise return the current voice service state
         */
        GetVoicePhoneServiceState(
            [out] Int32* result);

        /**
         * Override the service provider name and the operator name for the current ICCID.
         */
        SetOperatorBrandOverride(
            [in] String brand,
            [out] Boolean* result);

        /**
         * Is Radio Present on the device and is it accessible
         */
        IsRadioAvailable(
            [out] Boolean* result);

        /**
         * shutdown Radio gracefully
         */
        ShutdownRadio();

        /** Request to update the current local call hold state.
         * @param lchStatus, true if call is in lch state
         */
        SetLocalCallHold(
            [in] Int32 lchStatus);

        IsImsVtCallPresent(
            [out] Boolean* result);
    }

    }//Telephony
    }//Internal
    }//Droid
    }//Elastos

}
