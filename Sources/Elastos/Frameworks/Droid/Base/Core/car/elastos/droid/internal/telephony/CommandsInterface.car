
module
{
    interface Elastos.Droid.Os.IMessage;
    interface Elastos.Droid.Os.IHandler;
    interface Elastos.Droid.Internal.Telephony.Gsm.ISmsBroadcastConfigInfo;
    interface Elastos.Droid.Internal.Telephony.Cdma.ICdmaSmsBroadcastConfigInfo;
    // interface Elastos.Droid.Internal.Telephony.DataConnection.IDataProfile;

    namespace Elastos {
    namespace Droid {
    namespace Internal {
    namespace Telephony {

    enum ICommandsInterfaceRadioState {
        RADIO_OFF,         /* Radio explicitly powered off (eg CFUN=0) */
        RADIO_UNAVAILABLE, /* Radio unavailable (eg, resetting or not booted) */
        RADIO_ON          /* Radio is on */

        // public boolean isOn() /* and available...*/ {
        //     return this == RADIO_ON;
        // }

        // public boolean isAvailable() {
        //     return this != RADIO_UNAVAILABLE;
        // }
    }

    [deprecated, local]
    interface ICommandsInterface {

        //***** Constants

        // Used as parameter to dial() and setCLIR() below
        const Int32 CLIR_DEFAULT = 0;      // "use subscription default value"
        const Int32 CLIR_INVOCATION = 1;   // (restrict CLI presentation)
        const Int32 CLIR_SUPPRESSION = 2;  // (allow CLI presentation)


        // Used as parameters for call forward methods below
        const Int32 CF_ACTION_DISABLE          = 0;
        const Int32 CF_ACTION_ENABLE           = 1;
    //  const Int32 CF_ACTION_UNUSED           = 2;
        const Int32 CF_ACTION_REGISTRATION     = 3;
        const Int32 CF_ACTION_ERASURE          = 4;

        const Int32 CF_REASON_UNCONDITIONAL    = 0;
        const Int32 CF_REASON_BUSY             = 1;
        const Int32 CF_REASON_NO_REPLY         = 2;
        const Int32 CF_REASON_NOT_REACHABLE    = 3;
        const Int32 CF_REASON_ALL              = 4;
        const Int32 CF_REASON_ALL_CONDITIONAL  = 5;

        // Used for call barring methods below
        const String CB_FACILITY_BAOC         = "AO";
        const String CB_FACILITY_BAOIC        = "OI";
        const String CB_FACILITY_BAOICxH      = "OX";
        const String CB_FACILITY_BAIC         = "AI";
        const String CB_FACILITY_BAICr        = "IR";
        const String CB_FACILITY_BA_ALL       = "AB";
        const String CB_FACILITY_BA_MO        = "AG";
        const String CB_FACILITY_BA_MT        = "AC";
        const String CB_FACILITY_BA_SIM       = "SC";
        const String CB_FACILITY_BA_FD        = "FD";


        // Used for various supp services apis
        // See 27.007 +CCFC or +CLCK
        const Int32 SERVICE_CLASS_NONE     = 0; // no user input
        const Int32 SERVICE_CLASS_VOICE    = 1; // (1 << 0);
        const Int32 SERVICE_CLASS_DATA     = 2; // (1 << 1); //synonym for 16+32+64+128
        const Int32 SERVICE_CLASS_FAX      = 4; // (1 << 2);
        const Int32 SERVICE_CLASS_SMS      = 8; // (1 << 3);
        const Int32 SERVICE_CLASS_DATA_SYNC = 16; // (1 << 4);
        const Int32 SERVICE_CLASS_DATA_ASYNC = 32; // (1 << 5);
        const Int32 SERVICE_CLASS_PACKET   = 64; // (1 << 6);
        const Int32 SERVICE_CLASS_PAD      = 128; // (1 << 7);
        const Int32 SERVICE_CLASS_MAX      = 128; // (1 << 7); // Max SERVICE_CLASS value

        // Numeric representation of string values returned
        // by messages sent to setOnUSSD handler
        const Int32 USSD_MODE_NOTIFY       = 0;
        const Int32 USSD_MODE_REQUEST      = 1;

        // GSM SMS fail cause for acknowledgeLastIncomingSMS. From TS 23.040, 9.2.3.22.
        const Int32 GSM_SMS_FAIL_CAUSE_MEMORY_CAPACITY_EXCEEDED    = 0xD3;
        const Int32 GSM_SMS_FAIL_CAUSE_USIM_APP_TOOLKIT_BUSY       = 0xD4;
        const Int32 GSM_SMS_FAIL_CAUSE_USIM_DATA_DOWNLOAD_ERROR    = 0xD5;
        const Int32 GSM_SMS_FAIL_CAUSE_UNSPECIFIED_ERROR           = 0xFF;

        // CDMA SMS fail cause for acknowledgeLastIncomingCdmaSms.  From TS N.S0005, 6.5.2.125.
        const Int32 CDMA_SMS_FAIL_CAUSE_INVALID_TELESERVICE_ID     = 4;
        const Int32 CDMA_SMS_FAIL_CAUSE_RESOURCE_SHORTAGE          = 35;
        const Int32 CDMA_SMS_FAIL_CAUSE_OTHER_TERMINAL_PROBLEM     = 39;
        const Int32 CDMA_SMS_FAIL_CAUSE_ENCODING_PROBLEM           = 96;

        //***** Methods
        GetRadioState(
            [out] ICommandsInterfaceRadioState* result);

        /**
         * response.obj.result is an int[2]
         *
         * response.obj.result[0] is IMS registration state
         *                        0 - Not registered
         *                        1 - Registered
         * response.obj.result[1] is of type RILConstants.GSM_PHONE or
         *                                    RILConstants.CDMA_PHONE
         */
        GetImsRegistrationState(
            [in] IMessage* result);

        /**
         * Fires on any RadioState transition
         * Always fires immediately as well
         *
         * do not attempt to calculate transitions by storing getRadioState() values
         * on previous invocations of this notification. Instead, use the other
         * registration methods
         */
        RegisterForRadioStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForRadioStateChanged(
            [in] IHandler* h);

        RegisterForVoiceRadioTechChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForVoiceRadioTechChanged(
            [in] IHandler* h);

        RegisterForImsNetworkStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForImsNetworkStateChanged(
            [in] IHandler* h);

        /**
         * Fires on any transition into RadioState.isOn()
         * Fires immediately if currently in that state
         * In general, actions should be idempotent. State may change
         * before event is received.
         */
        RegisterForOn(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForOn(
            [in] IHandler* h);

        /**
         * Fires on any transition out of RadioState.isAvailable()
         * Fires immediately if currently in that state
         * In general, actions should be idempotent. State may change
         * before event is received.
         */
        RegisterForAvailable(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForAvailable(
            [in] IHandler* h);

        /**
         * Fires on any transition into !RadioState.isAvailable()
         * Fires immediately if currently in that state
         * In general, actions should be idempotent. State may change
         * before event is received.
         */
        RegisterForNotAvailable(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForNotAvailable(
            [in] IHandler* h);

        /**
         * Fires on any transition into RADIO_OFF or !RadioState.isAvailable()
         * Fires immediately if currently in that state
         * In general, actions should be idempotent. State may change
         * before event is received.
         */
        RegisterForOffOrNotAvailable(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForOffOrNotAvailable(
            [in] IHandler* h);

        /**
         * Fires on any change in ICC status
         */
        RegisterForIccStatusChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForIccStatusChanged(
            [in] IHandler* h);

        RegisterForCallStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCallStateChanged(
            [in] IHandler* h);

        RegisterForVoiceNetworkStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForVoiceNetworkStateChanged(
            [in] IHandler* h);

        RegisterForDataNetworkStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForDataNetworkStateChanged(
            [in] IHandler* h);

        /** InCall voice privacy notifications */
        RegisterForInCallVoicePrivacyOn(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForInCallVoicePrivacyOn(
            [in] IHandler* h);

        RegisterForInCallVoicePrivacyOff(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForInCallVoicePrivacyOff(
            [in] IHandler* h);

        /** Single Radio Voice Call State progress notifications */
        RegisterForSrvccStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForSrvccStateChanged(
            [in] IHandler* h);

        /**
         * Handlers for subscription status change indications.
         *
         * @param h Handler for subscription status change messages.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForSubscriptionStatusChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForSubscriptionStatusChanged(
            [in] IHandler* h);

        /**
         * fires on any change in hardware configuration.
         */
        RegisterForHardwareConfigChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForHardwareConfigChanged(
            [in] IHandler* h);

        /**
         * unlike the register* methods, there's only one new 3GPP format SMS handler.
         * if you need to unregister, you should also tell the radio to stop
         * sending SMS's to you (via AT+CNMI)
         *
         * AsyncResult.result is a String containing the SMS PDU
         */
        SetOnNewGsmSms(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnNewGsmSms(
            [in] IHandler* h);

        /**
         * unlike the register* methods, there's only one new 3GPP2 format SMS handler.
         * if you need to unregister, you should also tell the radio to stop
         * sending SMS's to you (via AT+CNMI)
         *
         * AsyncResult.result is a String containing the SMS PDU
         */
        SetOnNewCdmaSms(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnNewCdmaSms(
            [in] IHandler* h);

        /**
         * Set the handler for SMS Cell Broadcast messages.
         *
         * AsyncResult.result is a byte array containing the SMS-CB PDU
         */
        SetOnNewGsmBroadcastSms(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnNewGsmBroadcastSms(
            [in] IHandler* h);

        /**
         * Register for NEW_SMS_ON_SIM unsolicited message
         *
         * AsyncResult.result is an int array containing the index of new SMS
         */
        SetOnSmsOnSim(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnSmsOnSim(
            [in] IHandler* h);

        /**
         * Register for NEW_SMS_STATUS_REPORT unsolicited message
         *
         * AsyncResult.result is a String containing the status report PDU
         */
        SetOnSmsStatus(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnSmsStatus(
            [in] IHandler* h);

        /**
         * unlike the register* methods, there's only one NITZ time handler
         *
         * AsyncResult.result is an Object[]
         * ((Object[])AsyncResult.result)[0] is a String containing the NITZ time string
         * ((Object[])AsyncResult.result)[1] is a Long containing the milliseconds since boot as
         *                                   returned by elapsedRealtime() when this NITZ time
         *                                   was posted.
         *
         * Please note that the delivery of this message may be delayed several
         * seconds on system startup
         */
        SetOnNITZTime(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnNITZTime(
            [in] IHandler* h);

        /**
         * unlike the register* methods, there's only one USSD notify handler
         *
         * Represents the arrival of a USSD "notify" message, which may
         * or may not have been triggered by a previous USSD send
         *
         * AsyncResult.result is a String[]
         * ((String[])(AsyncResult.result))[0] contains status code
         *      "0"   USSD-Notify -- text in ((const char **)data)[1]
         *      "1"   USSD-Request -- text in ((const char **)data)[1]
         *      "2"   Session terminated by network
         *      "3"   other local client (eg, SIM Toolkit) has responded
         *      "4"   Operation not supported
         *      "5"   Network timeout
         *
         * ((String[])(AsyncResult.result))[1] contains the USSD message
         * The numeric representations of these are in USSD_MODE_*
         */
        SetOnUSSD(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnUSSD(
            [in] IHandler* h);

        /**
         * unlike the register* methods, there's only one signal strength handler
         * AsyncResult.result is an int[2]
         * response.obj.result[0] is received signal strength (0-31, 99)
         * response.obj.result[1] is  bit error rate (0-7, 99)
         * as defined in TS 27.007 8.5
         */
        SetOnSignalStrengthUpdate(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnSignalStrengthUpdate(
            [in] IHandler* h);

        /**
         * Sets the handler for SIM/RUIM SMS storage full unsolicited message.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnIccSmsFull(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnIccSmsFull(
            [in] IHandler* h);

        /**
         * Sets the handler for SIM Refresh notifications.
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForIccRefresh(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForIccRefresh(
            [in] IHandler* h);

        SetOnIccRefresh(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnsetOnIccRefresh(
            [in] IHandler* h);

        /**
         * Sets the handler for RING notifications.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCallRing(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCallRing(
            [in] IHandler* h);

        /**
         * Sets the handler for RESTRICTED_STATE changed notification,
         * eg, for Domain Specific Access Control
         * unlike the register* methods, there's only one signal strength handler
         *
         * AsyncResult.result is an int[1]
         * response.obj.result[0] is a bitmask of RIL_RESTRICTED_STATE_* values
         */
        SetOnRestrictedStateChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnRestrictedStateChanged(
            [in] IHandler* h);

        /**
         * Sets the handler for Supplementary Service Notifications.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnSuppServiceNotification(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnSuppServiceNotification(
            [in] IHandler* h);

        /**
         * Sets the handler for Session End Notifications for CAT.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCatSessionEnd(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatSessionEnd(
            [in] IHandler* h);

        /**
         * Sets the handler for Proactive Commands for CAT.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCatProactiveCmd(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatProactiveCmd(
            [in] IHandler* h);

        /**
         * Sets the handler for Event Notifications for CAT.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCatEvent(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatEvent(
            [in] IHandler* h);

        /**
         * Sets the handler for Call Set Up Notifications for CAT.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCatCallSetUp(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatCallSetUp(
            [in] IHandler* h);

        /**
         * Enables/disbables supplementary service related notifications from
         * the network.
         *
         * @param enable true to enable notifications, false to disable.
         * @param result Message to be posted when command completes.
         */
        SetSuppServiceNotifications(
            [in] Boolean enbl,
            [in] IMessage* result);

        //void unSetSuppServiceNotifications(IHandler* h);

        /**
         * Sets the handler for Alpha Notification during STK Call Control.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnCatCcAlphaNotify(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatCcAlphaNotify(
            [in] IHandler* h);

        /**
         * Sets the handler for notifying Suplementary Services (SS)
         * Data during STK Call Control.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        SetOnSs(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnSs(
            [in] IHandler* h);

        /**
         * Sets the handler for Event Notifications for CDMA Display Info.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForDisplayInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForDisplayInfo(
            [in] IHandler* h);

        /**
         * Sets the handler for Event Notifications for CallWaiting Info.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForCallWaitingInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCallWaitingInfo(
            [in] IHandler* h);

        /**
         * Sets the handler for Event Notifications for Signal Info.
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForSignalInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForSignalInfo(
            [in] IHandler* h);

        /**
         * Registers the handler for CDMA number information record
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForNumberInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForNumberInfo(
            [in] IHandler* h);

        /**
         * Registers the handler for CDMA redirected number Information record
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForRedirectedNumberInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForRedirectedNumberInfo(
            [in] IHandler* h);

        /**
         * Registers the handler for CDMA line control information record
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForLineControlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForLineControlInfo(
            [in] IHandler* h);

        /**
         * Registers the handler for CDMA T53 CLIR information record
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterFoT53ClirlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForT53ClirInfo(
            [in] IHandler* h);

        /**
         * Registers the handler for CDMA T53 audio control information record
         * Unlike the register* methods, there's only one notification handler
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForT53AudioControlInfo(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForT53AudioControlInfo(
            [in] IHandler* h);

        /**
         * Fires on if Modem enters Emergency Callback mode
         */
        SetEmergencyCallbackMode(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        /**
         * Fires on any CDMA OTA provision status change
         */
        RegisterForCdmaOtaProvision(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCdmaOtaProvision(
            [in] IHandler* h);

        /**
         * Registers the handler when out-band ringback tone is needed.<p>
         *
         *  Messages received from this:
         *  Message.obj will be an AsyncResult
         *  AsyncResult.userObj = obj
         *  AsyncResult.result = boolean. <p>
         */
        RegisterForRingbackTone(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForRingbackTone(
            [in] IHandler* h);

        /**
         * Registers the handler when mute/unmute need to be resent to get
         * uplink audio during a call.<p>
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         *
         */
        RegisterForResendIncallMute(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForResendIncallMute(
            [in] IHandler* h);

        /**
         * Registers the handler for when Cdma subscription changed events
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         *
         */
        RegisterForCdmaSubscriptionChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCdmaSubscriptionChanged(
            [in] IHandler* h);

        /**
         * Registers the handler for when Cdma prl changed events
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         *
         */
        RegisterForCdmaPrlChanged(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCdmaPrlChanged(
            [in] IHandler* h);

        /**
         * Registers the handler for when Cdma prl changed events
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         *
         */
        RegisterForExitEmergencyCallbackMode(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForExitEmergencyCallbackMode(
            [in] IHandler* h);

        /**
         * Registers the handler for RIL_UNSOL_RIL_CONNECT events.
         *
         * When ril connects or disconnects a message is sent to the registrant
         * which contains an AsyncResult, ar, in msg.obj. The ar.result is an
         * Integer which is the version of the ril or -1 if the ril disconnected.
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForRilConnected(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForRilConnected(
            [in] IHandler* h);

        /**
         * Supply the ICC PIN to the ICC card
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC will be PUK locked.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPin(
            [in] String pin,
            [in] IMessage* result);

        /**
         * Supply the PIN for the app with this AID on the ICC card
         *
         *  AID (Application ID), See ETSI 102.221 8.1 and 101.220 4
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC will be PUK locked.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPinForApp(
            [in] String pin,
            [in] String aid,
            [in] IMessage* result);

        /**
         * Supply the ICC PUK and newPin to the ICC card
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC is permanently disabled.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPuk(
            [in] String puk,
            [in] String newPin,
            [in] IMessage* result);

        /**
         * Supply the PUK, new pin for the app with this AID on the ICC card
         *
         *  AID (Application ID), See ETSI 102.221 8.1 and 101.220 4
         *
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC is permanently disabled.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPukForApp(
            [in] String puk,
            [in] String newPin,
            [in] String aid,
            [in] IMessage* result);

        /**
         * Supply the ICC PIN2 to the ICC card
         * Only called following operation where ICC_PIN2 was
         * returned as a a failure from a previous operation
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC will be PUK locked.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPin2(
            [in] String pin2,
            [in] IMessage* result);

        /**
         * Supply the PIN2 for the app with this AID on the ICC card
         * Only called following operation where ICC_PIN2 was
         * returned as a a failure from a previous operation
         *
         *  AID (Application ID), See ETSI 102.221 8.1 and 101.220 4
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC will be PUK locked.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPin2ForApp(
            [in] String pin2,
            [in] String aid,
            [in] IMessage* result);

        /**
         * Supply the SIM PUK2 to the SIM card
         * Only called following operation where SIM_PUK2 was
         * returned as a a failure from a previous operation
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC is permanently disabled.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPuk2(
            [in] String puk2,
            [in] String newPin2,
            [in] IMessage* result);

        /**
         * Supply the PUK2, newPin2 for the app with this AID on the ICC card
         * Only called following operation where SIM_PUK2 was
         * returned as a a failure from a previous operation
         *
         *  AID (Application ID), See ETSI 102.221 8.1 and 101.220 4
         *
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  This exception is CommandException with an error of PASSWORD_INCORRECT
         *  if the password is incorrect
         *
         *  ar.result is an optional array of integers where the first entry
         *  is the number of attempts remaining before the ICC is permanently disabled.
         *
         * ar.exception and ar.result are null on success
         */
        SupplyIccPuk2ForApp(
            [in] String puk2,
            [in] String newPin2,
            [in] String aid,
            [in] IMessage* result);

        // TODO: Add java doc and indicate that msg.arg1 contains the number of attempts remaining.
        ChangeIccPin(
            [in] String oldPin,
            [in] String newPin,
            [in] IMessage* result);

        ChangeIccPinForApp(
            [in] String oldPin,
            [in] String newPin,
            [in] String aidPtr,
            [in] IMessage* result);

        ChangeIccPin2(
            [in] String oldPin2,
            [in] String newPin2,
            [in] IMessage* result);

        ChangeIccPin2ForApp(
            [in] String oldPin2,
            [in] String newPin2,
            [in] String aidPtr,
            [in] IMessage* result);

        ChangeBarringPassword(
            [in] String facility,
            [in] String oldPwd,
            [in] String newPwd,
            [in] IMessage* result);

        SupplyDepersonalization(
            [in] String netpin,
            [in] String type,
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result contains a List of DriverCall
         *      The ar.result List is sorted by DriverCall.index
         */
        GetCurrentCalls(
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result contains a List of DataCallResponse
         *  @deprecated Do not use.
         */
        GetPDPContextList(
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result contains a List of DataCallResponse
         */
        GetDataCallList(
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         *
         * CLIR_DEFAULT     == on "use subscription default value"
         * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
         * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
         */
        Dial(
            [in] String address,
            [in] Int32 clirMode,
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         *
         * CLIR_DEFAULT     == on "use subscription default value"
         * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
         * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
         */
        Dial(
            [in] String address,
            [in] Int32 clirMode,
            [in] IUUSInfo* uusInfo,
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is String containing IMSI on success
         */
        GetIMSI(
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is String containing IMSI on success
         */
        GetIMSIForApp(
            [in] String aid,
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is String containing IMEI on success
         */
        GetIMEI(
            [in] IMessage* result);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is String containing IMEISV on success
         */
        GetIMEISV(
            [in] IMessage* result);

        /**
         * Hang up one individual connection.
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         *
         *  3GPP 22.030 6.5.5
         *  "Releases a specific active call X"
         */
        HangupConnection(
            [in] Int32 gsmIndex,
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         *  "Releases all held calls or sets User Determined User Busy (UDUB)
         *   for a waiting call."
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        HangupWaitingOrBackground(
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         * "Releases all active calls (if any exist) and accepts
         *  the other (held or waiting) call."
         *
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        HangupForegroundResumeBackground(
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         * "Places all active calls (if any exist) on hold and accepts
         *  the other (held or waiting) call."
         *
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        SwitchWaitingOrHoldingAndActive(
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         * "Adds a held call to the conversation"
         *
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        Conference(
            [in] IMessage* result);

        /**
         * Set preferred Voice Privacy (VP).
         *
         * @param enable true is enhanced and false is normal VP
         * @param result is a callback message
         */
        SetPreferredVoicePrivacy(
            [in] Boolean enbl,
            [in] IMessage* result);

        /**
         * Get currently set preferred Voice Privacy (VP) mode.
         *
         * @param result is a callback message
         */
        GetPreferredVoicePrivacy(
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         * "Places all active calls on hold except call X with which
         *  communication shall be supported."
         */
        SeparateConnection(
            [in] Int32 gsmIndex,
            [in] IMessage* result);

        /**
         *
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        AcceptCall(
            [in] IMessage* result);

        /**
         *  also known as UDUB
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        RejectCall(
            [in] IMessage* result);

        /**
         * 3GPP 22.030 6.5.5
         * "Connects the two calls and disconnects the subscriber from both calls"
         *
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        ExplicitCallTransfer(
            [in] IMessage* result);

        /**
         * cause code returned as int[0] in Message.obj.response
         * Returns integer cause code defined in TS 24.008
         * Annex H or closest approximation.
         * Most significant codes:
         * - Any defined in 22.001 F.4 (for generating busy/congestion)
         * - Cause 68: ACM >= ACMMax
         */
        GetLastCallFailCause(
            [in] IMessage* result);

        /**
         * Reason for last PDP context deactivate or failure to activate
         * cause code returned as int[0] in Message.obj.response
         * returns an integer cause code defined in TS 24.008
         * section 6.1.3.1.3 or close approximation
         * @deprecated Do not use.
         */
        GetLastPdpFailCause(
            [in] IMessage* result);

        /**
         * The preferred new alternative to getLastPdpFailCause
         * that is also CDMA-compatible.
         */
        GetLastDataCallFailCause(
            [in] IMessage* result);

        SetMute(
            [in] Boolean enableMute,
            [in] IMessage* response);

        GetMute(
            [in] IMessage* response);

        /**
         * response.obj is an AsyncResult
         * response.obj.result is an int[2]
         * response.obj.result[0] is received signal strength (0-31, 99)
         * response.obj.result[1] is  bit error rate (0-7, 99)
         * as defined in TS 27.007 8.5
         */
        GetSignalStrength(
            [in] IMessage* response);

        /**
         * response.obj.result is an int[3]
         * response.obj.result[0] is registration state 0-5 from TS 27.007 7.2
         * response.obj.result[1] is LAC if registered or -1 if not
         * response.obj.result[2] is CID if registered or -1 if not
         * valid LAC and CIDs are 0x0000 - 0xffff
         *
         * Please note that registration state 4 ("unknown") is treated
         * as "out of service" above
         */
        GetVoiceRegistrationState(
            [in] IMessage* response);

        /**
         * response.obj.result is an int[3]
         * response.obj.result[0] is registration state 0-5 from TS 27.007 7.2
         * response.obj.result[1] is LAC if registered or -1 if not
         * response.obj.result[2] is CID if registered or -1 if not
         * valid LAC and CIDs are 0x0000 - 0xffff
         *
         * Please note that registration state 4 ("unknown") is treated
         * as "out of service" above
         */
        GetDataRegistrationState(
            [in] IMessage* response);

        /**
         * response.obj.result is a String[3]
         * response.obj.result[0] is long alpha or null if unregistered
         * response.obj.result[1] is short alpha or null if unregistered
         * response.obj.result[2] is numeric or null if unregistered
         */
        GetOperator(
            [in] IMessage* response);

        /**
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        SendDtmf(
            [in] Char32 c,
            [in] IMessage* result);

        /**
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        StartDtmf(
            [in] Char32 c,
            [in] IMessage* result);

        /**
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        StopDtmf(
            [in] IMessage* result);

        /**
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result is null on success and failure
         */
        SendBurstDtmf(
            [in] String dtmfString,
            [in] Int32 on,
            [in] Int32 off,
            [in] IMessage* result);

        /**
         * smscPDU is smsc address in PDU form GSM BCD format prefixed
         *      by a length byte (as expected by TS 27.005) or NULL for default SMSC
         * pdu is SMS in PDU format as an ASCII hex string
         *      less the SMSC address
         */
        SendSMS(
            [in] String smscPDU,
            [in] String pdu,
            [in] IMessage* response);

        /**
         * Send an SMS message, Identical to sendSMS,
         * except that more messages are expected to be sent soon
         * smscPDU is smsc address in PDU form GSM BCD format prefixed
         *      by a length byte (as expected by TS 27.005) or NULL for default SMSC
         * pdu is SMS in PDU format as an ASCII hex string
         *      less the SMSC address
         */
        SendSMSExpectMore(
            [in] String smscPDU,
            [in] String pdu,
            [in] IMessage* response);

        /**
         * @param pdu is CDMA-SMS in internal pseudo-PDU format
         * @param response sent when operation completes
         */
        SendCdmaSms(
            [in] ArrayOf<Byte>* pdu,
            [in] IMessage* response);

        /**
         * send SMS over IMS with 3GPP/GSM SMS format
         * @param smscPDU is smsc address in PDU form GSM BCD format prefixed
         *      by a length byte (as expected by TS 27.005) or NULL for default SMSC
         * @param pdu is SMS in PDU format as an ASCII hex string
         *      less the SMSC address
         * @param retry indicates if this is a retry; 0 == not retry, nonzero = retry
         * @param messageRef valid field if retry is set to nonzero.
         *        Contains messageRef from RIL_SMS_Response corresponding to failed MO SMS
         * @param response sent when operation completes
         */
        SendImsGsmSms(
            [in] String smscPDU,
            [in] String pdu,
            [in] Int32 retry,
            [in] Int32 messageRef,
            [in] IMessage* response);

        /**
         * send SMS over IMS with 3GPP2/CDMA SMS format
         * @param pdu is CDMA-SMS in internal pseudo-PDU format
         * @param response sent when operation completes
         * @param retry indicates if this is a retry; 0 == not retry, nonzero = retry
         * @param messageRef valid field if retry is set to nonzero.
         *        Contains messageRef from RIL_SMS_Response corresponding to failed MO SMS
         * @param response sent when operation completes
         */
        SendImsCdmaSms(
            [in] ArrayOf<Byte>* pdu,
            [in] Int32 retry,
            [in] Int32 messageRef,
            [in] IMessage* response);

        /**
         * Deletes the specified SMS record from SIM memory (EF_SMS).
         *
         * @param index index of the SMS record to delete
         * @param response sent when operation completes
         */
        DeleteSmsOnSim(
            [in] Int32 index,
            [in] IMessage* response);

        /**
         * Deletes the specified SMS record from RUIM memory (EF_SMS in DF_CDMA).
         *
         * @param index index of the SMS record to delete
         * @param response sent when operation completes
         */
        DeleteSmsOnRuim(
            [in] Int32 index,
            [in] IMessage* response);

        /**
         * Writes an SMS message to SIM memory (EF_SMS).
         *
         * @param status status of message on SIM.  One of:
         *                  SmsManger.STATUS_ON_ICC_READ
         *                  SmsManger.STATUS_ON_ICC_UNREAD
         *                  SmsManger.STATUS_ON_ICC_SENT
         *                  SmsManger.STATUS_ON_ICC_UNSENT
         * @param pdu message PDU, as hex string
         * @param response sent when operation completes.
         *                  response.obj will be an AsyncResult, and will indicate
         *                  any error that may have occurred (eg, out of memory).
         */
        WriteSmsToSim(
            [in] Int32 status,
            [in] String smsc,
            [in] String pdu,
            [in] IMessage* response);

        WriteSmsToRuim(
            [in] Int32 status,
            [in] String pdu,
            [in] IMessage* response);

        SetRadioPower(
            [in] Boolean on,
            [in] IMessage* response);

        AcknowledgeLastIncomingGsmSms(
            [in] Boolean success,
            [in] Int32 cause,
            [in] IMessage* response);

        AcknowledgeLastIncomingCdmaSms(
            [in] Boolean success,
            [in] Int32 cause,
            [in] IMessage* response);

        /**
         * Acknowledge successful or failed receipt of last incoming SMS,
         * including acknowledgement TPDU to send as the RP-User-Data element
         * of the RP-ACK or RP-ERROR PDU.
         *
         * @param success true to send RP-ACK, false to send RP-ERROR
         * @param ackPdu the acknowledgement TPDU in hexadecimal format
         * @param response sent when operation completes.
         */
        AcknowledgeIncomingGsmSmsWithPdu(
            [in] Boolean success,
            [in] String ackPdu,
            [in] IMessage* response);

        /**
         * parameters equivalent to 27.007 AT+CRSM command
         * response.obj will be an AsyncResult
         * response.obj.result will be an IccIoResult on success
         */
        IccIO(
            [in] Int32 command,
            [in] Int32 fileid,
            [in] String path,
            [in] Int32 p1,
            [in] Int32 p2,
            [in] Int32 p3,
            [in] String data,
            [in] String pin2,
            [in] IMessage* response);

        /**
         * parameters equivalent to 27.007 AT+CRSM command
         * response.obj will be an AsyncResult
         * response.obj.userObj will be a IccIoResult on success
         */
        IccIOForApp(
            [in] Int32 command,
            [in] Int32 fileid,
            [in] String path,
            [in] Int32 p1,
            [in] Int32 p2,
            [in] Int32 p3,
            [in] String data,
            [in] String pin2,
            [in] String aid,
            [in] IMessage* response);

        /**
         * (AsyncResult)response.obj).result is an int[] with element [0] set to
         * 1 for "CLIP is provisioned", and 0 for "CLIP is not provisioned".
         *
         * @param response is callback message
         */
        QueryCLIP(
            [in] IMessage* response);

        /**
         * response.obj will be a an int[2]
         *
         * response.obj[0] will be TS 27.007 +CLIR parameter 'n'
         *  0 presentation indicator is used according to the subscription of the CLIR service
         *  1 CLIR invocation
         *  2 CLIR suppression
         *
         * response.obj[1] will be TS 27.007 +CLIR parameter 'm'
         *  0 CLIR not provisioned
         *  1 CLIR provisioned in permanent mode
         *  2 unknown (e.g. no network, etc.)
         *  3 CLIR temporary mode presentation restricted
         *  4 CLIR temporary mode presentation allowed
         */
        GetCLIR(
            [in] IMessage* response);

        /**
         * clirMode is one of the CLIR_* constants above
         *
         * response.obj is null
         */
        SetCLIR(
            [in] Int32 clirMode,
            [in] IMessage* response);

        /**
         * (AsyncResult)response.obj).result is an int[] with element [0] set to
         * 0 for disabled, 1 for enabled.
         *
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param response is callback message
         */
        QueryCallWaiting(
            [in] Int32 serviceClass,
            [in] IMessage* response);

        /**
         * @param enable is true to enable, false to disable
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param response is callback message
         */
        SetCallWaiting(
            [in] Boolean enbl,
            [in] Int32 serviceClass,
            [in] IMessage* response);

        /**
         * @param action is one of CF_ACTION_*
         * @param cfReason is one of CF_REASON_*
         * @param serviceClass is a sum of SERVICE_CLASSS_*
         */
        SetCallForward(
            [in] Int32 action,
            [in] Int32 cfReason,
            [in] Int32 serviceClass,
            [in] String number,
            [in] Int32 timeSeconds,
            [in] IMessage* response);

        /**
         * cfReason is one of CF_REASON_*
         *
         * ((AsyncResult)response.obj).result will be an array of
         * CallForwardInfo's
         *
         * An array of length 0 means "disabled for all codes"
         */
        QueryCallForwardStatus(
            [in] Int32 cfReason,
            [in] Int32 serviceClass,
            [in] String number,
            [in] IMessage* response);

        SetNetworkSelectionModeAutomatic(
            [in] IMessage* response);

        SetNetworkSelectionModeManual(
            [in] String operatorNumeric,
            [in] IMessage* response);

        /**
         * Queries whether the current network selection mode is automatic
         * or manual
         *
         * ((AsyncResult)response.obj).result  is an int[] with element [0] being
         * a 0 for automatic selection and a 1 for manual selection
         */
        GetNetworkSelectionMode(
            [in] IMessage* response);

        /**
         * Queries the currently available networks
         *
         * ((AsyncResult)response.obj).result  is a List of NetworkInfo objects
         */
        GetAvailableNetworks(
            [in] IMessage* response);

        GetBasebandVersion(
            [in] IMessage* response);

        /**
         * (AsyncResult)response.obj).result will be an Integer representing
         * the sum of enabled service classes (sum of SERVICE_CLASS_*)
         *
         * @param facility one of CB_FACILTY_*
         * @param password password or "" if not required
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param response is callback message
         */
        QueryFacilityLock(
            [in] String facility,
            [in] String password,
            [in] Int32 serviceClass,
            [in] IMessage* response);

        /**
         * (AsyncResult)response.obj).result will be an Integer representing
         * the sum of enabled service classes (sum of SERVICE_CLASS_*) for the
         * application with appId.
         *
         * @param facility one of CB_FACILTY_*
         * @param password password or "" if not required
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param appId is application Id or null if none
         * @param response is callback message
         */
        QueryFacilityLockForApp(
            [in] String facility,
            [in] String password,
            [in] Int32 serviceClass,
            [in] String appId,
            [in] IMessage* response);

        /**
         * @param facility one of CB_FACILTY_*
         * @param lockState true means lock, false means unlock
         * @param password password or "" if not required
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param response is callback message
         */
        SetFacilityLock(
            [in] String facility,
            [in] Boolean lockState,
            [in] String password,
            [in] Int32 serviceClass,
            [in] IMessage* response);

        /**
         * Set the facility lock for the app with this AID on the ICC card.
         *
         * @param facility one of CB_FACILTY_*
         * @param lockState true means lock, false means unlock
         * @param password password or "" if not required
         * @param serviceClass is a sum of SERVICE_CLASS_*
         * @param appId is application Id or null if none
         * @param response is callback message
         */
        SetFacilityLockForApp(
            [in] String facility,
            [in] Boolean lockState,
            [in] String password,
            [in] Int32 serviceClass,
            [in] String appId,
            [in] IMessage* response);

        SendUSSD(
            [in] String ussdString,
            [in] IMessage* response);

        /**
         * Cancels a pending USSD session if one exists.
         * @param response callback message
         */
        CancelPendingUssd(
            [in] IMessage* response);

        ResetRadio(
            [in] IMessage* result);

        /**
         * Assign a specified band for RF configuration.
         *
         * @param bandMode one of BM_*_BAND
         * @param response is callback message
         */
        SetBandMode(
            [in] Int32 bandMode,
            [in] IMessage* response);

        /**
         * Query the list of band mode supported by RF.
         *
         * @param response is callback message
         *        ((AsyncResult)response.obj).result  is an int[] where int[0] is
         *        the size of the array and the rest of each element representing
         *        one available BM_*_BAND
         */
        QueryAvailableBandMode(
            [in] IMessage* response);

        /**
         *  Requests to set the preferred network type for searching and registering
         * (CS/PS domain, RAT, and operation mode)
         * @param networkType one of  NT_*_TYPE
         * @param response is callback message
         */
        SetPreferredNetworkType(
            [in] Int32 networkType,
            [in] IMessage* response);

         /**
         *  Query the preferred network type setting
         *
         * @param response is callback message to report one of  NT_*_TYPE
         */
        GetPreferredNetworkType(
            [in] IMessage* response);

        /**
         * Query neighboring cell ids
         *
         * @param response s callback message to cell ids
         */
        GetNeighboringCids(
            [in] IMessage* response);

        /**
         * Request to enable/disable network state change notifications when
         * location information (lac and/or cid) has changed.
         *
         * @param enable true to enable, false to disable
         * @param response callback message
         */
        SetLocationUpdates(
            [in] Boolean enbl,
            [in] IMessage* response);

        /**
         * Gets the default SMSC address.
         *
         * @param result Callback message contains the SMSC address.
         */
        GetSmscAddress(
            [in] IMessage* result);

        /**
         * Sets the default SMSC address.
         *
         * @param address new SMSC address
         * @param result Callback message is empty on completion
         */
        SetSmscAddress(
            [in] String address,
            [in] IMessage* result);

        /**
         * Indicates whether there is storage available for new SMS messages.
         * @param available true if storage is available
         * @param result callback message
         */
        ReportSmsMemoryStatus(
            [in] Boolean available,
            [in] IMessage* result);

        /**
         * Indicates to the vendor ril that StkService is running
         * and is ready to receive RIL_UNSOL_STK_XXXX commands.
         *
         * @param result callback message
         */
        ReportStkServiceIsRunning(
            [in] IMessage* result);

        InvokeOemRilRequestRaw(
            [in] ArrayOf<Byte>* data,
            [in] IMessage* response);

        InvokeOemRilRequestStrings(
            [in] ArrayOf<String>* strings,
            [in] IMessage* response);

        /**
         * Fires when RIL_UNSOL_OEM_HOOK_RAW is received from the RIL.
         */
        SetOnUnsolOemHookRaw(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnUnsolOemHookRaw(
            [in] IHandler* h);

        /**
         * Send TERMINAL RESPONSE to the SIM, after processing a proactive command
         * sent by the SIM.
         *
         * @param contents  String containing SAT/USAT response in hexadecimal
         *                  format starting with first byte of response data. See
         *                  TS 102 223 for details.
         * @param response  Callback message
         */
        SendTerminalResponse(
            [in] String contents,
            [in] IMessage* response);

        /**
         * Send ENVELOPE to the SIM, after processing a proactive command sent by
         * the SIM.
         *
         * @param contents  String containing SAT/USAT response in hexadecimal
         *                  format starting with command tag. See TS 102 223 for
         *                  details.
         * @param response  Callback message
         */
        SendEnvelope(
            [in] String contents,
            [in] IMessage* response);

        /**
         * Send ENVELOPE to the SIM, such as an SMS-PP data download envelope
         * for a SIM data download message. This method has one difference
         * from {@link #sendEnvelope}: The SW1 and SW2 status bytes from the UICC response
         * are returned along with the response data.
         *
         * response.obj will be an AsyncResult
         * response.obj.result will be an IccIoResult on success
         *
         * @param contents  String containing SAT/USAT response in hexadecimal
         *                  format starting with command tag. See TS 102 223 for
         *                  details.
         * @param response  Callback message
         */
        SendEnvelopeWithStatus(
            [in] String contents,
            [in] IMessage* response);

        /**
         * Accept or reject the call setup request from SIM.
         *
         * @param accept   true if the call is to be accepted, false otherwise.
         * @param response Callback message
         */
        HandleCallSetupRequestFromSim(
            [in] Boolean accept,
            [in] IMessage* response);

        /**
         * Activate or deactivate cell broadcast SMS for GSM.
         *
         * @param activate
         *            true = activate, false = deactivate
         * @param result Callback message is empty on completion
         */
        SetGsmBroadcastActivation(
            [in] Boolean activate,
            [in] IMessage* result);

        /**
         * Configure cell broadcast SMS for GSM.
         *
         * @param response Callback message is empty on completion
         */
        SetGsmBroadcastConfig(
            [in] ArrayOf<ISmsBroadcastConfigInfo*>* config,
            [in] IMessage* response);

        /**
         * Query the current configuration of cell broadcast SMS of GSM.
         *
         * @param response
         *        Callback message contains the configuration from the modem
         *        on completion
         */
        GetGsmBroadcastConfig(
            [in] IMessage* response);

        //***** new Methods for CDMA support

        /**
         * Request the device ESN / MEID / IMEI / IMEISV.
         * "response" is const char **
         *   [0] is IMEI if GSM subscription is available
         *   [1] is IMEISV if GSM subscription is available
         *   [2] is ESN if CDMA subscription is available
         *   [3] is MEID if CDMA subscription is available
         */
        GetDeviceIdentity(
            [in] IMessage* response);

        /**
         * Request the device MDN / H_SID / H_NID / MIN.
         * "response" is const char **
         *   [0] is MDN if CDMA subscription is available
         *   [1] is a comma separated list of H_SID (Home SID) in decimal format
         *       if CDMA subscription is available
         *   [2] is a comma separated list of H_NID (Home NID) in decimal format
         *       if CDMA subscription is available
         *   [3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
         */
        GetCDMASubscription(
            [in] IMessage* response);

        /**
         * Send Flash Code.
         * "response" is is NULL
         *   [0] is a FLASH string
         */
        SendCDMAFeatureCode(
            [in] String FeatureCode,
            [in] IMessage* response);

        /** Set the Phone type created */
        SetPhoneType(
            [in] Int32 phoneType);

        /**
         *  Query the CDMA roaming preference setting
         *
         * @param response is callback message to report one of  CDMA_RM_*
         */
        QueryCdmaRoamingPreference(
            [in] IMessage* response);

        /**
         *  Requests to set the CDMA roaming preference
         * @param cdmaRoamingType one of  CDMA_RM_*
         * @param response is callback message
         */
        SetCdmaRoamingPreference(
            [in] Int32 cdmaRoamingType,
            [in] IMessage* response);

        /**
         *  Requests to set the CDMA subscription mode
         * @param cdmaSubscriptionType one of  CDMA_SUBSCRIPTION_*
         * @param response is callback message
         */
        SetCdmaSubscriptionSource(
            [in] Int32 cdmaSubscriptionType,
            [in] IMessage* response);

        /**
         *  Requests to get the CDMA subscription srouce
         * @param response is callback message
         */
        GetCdmaSubscriptionSource(
            [in] IMessage* response);

        /**
         *  Set the TTY mode
         *
         * @param ttyMode one of the following:
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_OFF}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_FULL}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_HCO}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_VCO}
         * @param response is callback message
         */
        SetTTYMode(
            [in] Int32 ttyMode,
            [in] IMessage* response);

        /**
         *  Query the TTY mode
         * (AsyncResult)response.obj).result is an int[] with element [0] set to
         * tty mode:
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_OFF}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_FULL}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_HCO}
         * - {@link com.android.internal.telephony.Phone#TTY_MODE_VCO}
         * @param response is callback message
         */
        QueryTTYMode(
            [in] IMessage* response);

        /**
         * Setup a packet data connection On successful completion, the result
         * message will return a {@link com.android.internal.telephony.dataconnection.DataCallResponse}
         * object containing the connection information.
         *
         * @param radioTechnology
         *            indicates whether to setup connection on radio technology CDMA
         *            (0) or GSM/UMTS (1)
         * @param profile
         *            Profile Number or NULL to indicate default profile
         * @param apn
         *            the APN to connect to if radio technology is GSM/UMTS.
         *            Otherwise null for CDMA.
         * @param user
         *            the username for APN, or NULL
         * @param password
         *            the password for APN, or NULL
         * @param authType
         *            the PAP / CHAP auth type. Values is one of SETUP_DATA_AUTH_*
         * @param protocol
         *            one of the PDP_type values in TS 27.007 section 10.1.1.
         *            For example, "IP", "IPV6", "IPV4V6", or "PPP".
         * @param result
         *            Callback message
         */
        SetupDataCall(
            [in] String radioTechnology,
            [in] String profile,
            [in] String apn,
            [in] String user,
            [in] String password,
            [in] String authType,
            [in] String protocol,
            [in] IMessage* result);

        /**
         * Deactivate packet data connection
         *
         * @param cid
         *            The connection ID
         * @param reason
         *            Data disconnect reason.
         * @param result
         *            Callback message is empty on completion
         */
        DeactivateDataCall(
            [in] Int32 cid,
            [in] Int32 reason,
            [in] IMessage* result);

        /**
         * Activate or deactivate cell broadcast SMS for CDMA.
         *
         * @param activate
         *            true = activate, false = deactivate
         * @param result
         *            Callback message is empty on completion
         */
        SetCdmaBroadcastActivation(
            [in] Boolean activate,
            [in] IMessage* result);

        /**
         * Configure cdma cell broadcast SMS.
         *
         * @param response
         *            Callback message is empty on completion
         */
        SetCdmaBroadcastConfig(
            [in] ArrayOf<ICdmaSmsBroadcastConfigInfo*>* configs,
            [in] IMessage* response);

        /**
         * Query the current configuration of cdma cell broadcast SMS.
         *
         * @param result
         *            Callback message contains the configuration from the modem on completion
         */
        GetCdmaBroadcastConfig(
            [in] IMessage* result);

        /**
         *  Requests the radio's system selection module to exit emergency callback mode.
         *  This function should only be called from CDMAPHone.java.
         *
         * @param response callback message
         */
        ExitEmergencyCallbackMode(
            [in] IMessage* response);

        /**
         * Request the status of the ICC and UICC cards.
         *
         * @param result
         *          Callback message containing {@link IccCardStatus} structure for the card.
         */
        GetIccCardStatus(
            [in] IMessage* result);

        /**
         * Return if the current radio is LTE on CDMA. This
         * is a tri-state return value as for a period of time
         * the mode may be unknown.
         *
         * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}
         * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}
         */
        GetLteOnCdmaMode(
            [out] Int32* result);

        /**
         * Get the data call profile information from the modem
         *
         * @param appType
         *          Callback message containing the count and the list of {@link
         *          RIL_DataCallProfileInfo}
         *
         * @param result
         *          Callback message
         */
        GetDataCallProfile(
            [in] Int32 appType,
            [in] IMessage* result);

        /**
         * Return if the current radio is LTE on GSM
         * @hide
         */
        GetLteOnGsmMode(
            [out] Int32* result);

        /**
         * Request the ISIM application on the UICC to perform the AKA
         * challenge/response algorithm for IMS authentication. The nonce string
         * and challenge response are Base64 encoded Strings.
         *
         * @param nonce the nonce string to pass with the ISIM authentication request
         * @param response a callback message with the String response in the obj field
         * @deprecated
         * @see requestIccSimAuthentication
         */
        RequestIsimAuthentication(
            [in] String nonce,
            [in] IMessage* response);

        /**
         * Request the SIM application on the UICC to perform authentication
         * challenge/response algorithm. The data string and challenge response are
         * Base64 encoded Strings.
         * Can support EAP-SIM, EAP-AKA with results encoded per 3GPP TS 31.102.
         *
         * @param authContext is the P2 parameter that specifies the authentication context per 3GPP TS
         *                    31.102 (Section 7.1.2)
         * @param data authentication challenge data
         * @param aid used to determine which application/slot to send the auth command to. See ETSI
         *            102.221 8.1 and 101.220 4
         * @param response a callback message with the String response in the obj field
         */
        RequestIccSimAuthentication(
            [in] Int32 authContext,
            [in] String data,
            [in] String aid,
            [in] IMessage* response);

        /**
         * Get the current Voice Radio Technology.
         *
         * AsyncResult.result is an int array with the first value
         * being one of the ServiceState.RIL_RADIO_TECHNOLOGY_xxx values.
         *
         * @param result is sent back to handler and result.obj is a AsyncResult
         */
        GetVoiceRadioTechnology(
            [in] IMessage* result);

        /**
         * Return the current set of CellInfo records
         *
         * AsyncResult.result is a of Collection<CellInfo>
         *
         * @param result is sent back to handler and result.obj is a AsyncResult
         */
        GetCellInfoList(
            [in] IMessage* result);

        /**
         * Sets the minimum time in milli-seconds between when RIL_UNSOL_CELL_INFO_LIST
         * should be invoked.
         *
         * The default, 0, means invoke RIL_UNSOL_CELL_INFO_LIST when any of the reported
         * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue
         * A RIL_UNSOL_CELL_INFO_LIST.
         *
         *

         * @param rateInMillis is sent back to handler and result.obj is a AsyncResult
         * @param response.obj is AsyncResult ar when sent to associated handler
         *                        ar.exception carries exception on failure or null on success
         *                        otherwise the error.
         */
        SetCellInfoListRate(
            [in] Int32 rateInMillis,
            [in] IMessage* response);

        /**
         * Fires when RIL_UNSOL_CELL_INFO_LIST is received from the RIL.
         */
        RegisterForCellInfoList(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForCellInfoList(
            [in] IHandler* h);

        /**
         * Set Initial Attach Apn
         *
         * @param apn
         *            the APN to connect to if radio technology is GSM/UMTS.
         * @param protocol
         *            one of the PDP_type values in TS 27.007 section 10.1.1.
         *            For example, "IP", "IPV6", "IPV4V6", or "PPP".
         * @param authType
         *            authentication protocol used for this PDP context
         *            (None: 0, PAP: 1, CHAP: 2, PAP&CHAP: 3)
         * @param username
         *            the username for APN, or NULL
         * @param password
         *            the password for APN, or NULL
         * @param result
         *            callback message contains the information of SUCCESS/FAILURE
         */
        SetInitialAttachApn(
            [in] String apn,
            [in] String protocol,
            [in] Int32 authType,
            [in] String username,
            [in] String password,
            [in] IMessage* result);

        /**
         * Set data profiles in modem
         *
         * @param dps
         *            Array of the data profiles set to modem
         * @param result
         *            callback message contains the information of SUCCESS/FAILURE
         */
        // SetDataProfile(
        //     [in] ArrayOf<IDataProfile*>* dps,
        //     [in] IMessage* result);

        /**
         * Notifiy that we are testing an emergency call
         */
        TestingEmergencyCall();

        /**
         * Open a logical channel to the SIM.
         *
         * Input parameters equivalent to TS 27.007 AT+CCHO command.
         *
         * @param AID Application id. See ETSI 102.221 and 101.220.
         * @param response Callback message. response.obj will be an int [1] with
         *            element [0] set to the id of the logical channel.
         */
        IccOpenLogicalChannel(
            [in] String AID,
            [in] IMessage* response);

        /**
         * Close a previously opened logical channel to the SIM.
         *
         * Input parameters equivalent to TS 27.007 AT+CCHC command.
         *
         * @param channel Channel id. Id of the channel to be closed.
         * @param response Callback message.
         */
        IccCloseLogicalChannel(
            [in] Int32 channel,
            [in] IMessage* response);

        /**
         * Exchange APDUs with the SIM on a logical channel.
         *
         * Input parameters equivalent to TS 27.007 AT+CGLA command.
         *
         * @param channel Channel id of the channel to use for communication. Has to
         *            be greater than zero.
         * @param cla Class of the APDU command.
         * @param instruction Instruction of the APDU command.
         * @param p1 P1 value of the APDU command.
         * @param p2 P2 value of the APDU command.
         * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU
         *            is sent to the SIM.
         * @param data Data to be sent with the APDU.
         * @param response Callback message. response.obj.userObj will be
         *            an IccIoResult on success.
         */
        IccTransmitApduLogicalChannel(
            [in] Int32 channel,
            [in] Int32 cla,
            [in] Int32 instruction,
            [in] Int32 p1,
            [in] Int32 p2,
            [in] Int32 p3,
            [in] String data,
            [in] IMessage* response);

        /**
         * Exchange APDUs with the SIM on a basic channel.
         *
         * Input parameters equivalent to TS 27.007 AT+CSIM command.
         *
         * @param cla Class of the APDU command.
         * @param instruction Instruction of the APDU command.
         * @param p1 P1 value of the APDU command.
         * @param p2 P2 value of the APDU command.
         * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU
         *            is sent to the SIM.
         * @param data Data to be sent with the APDU.
         * @param response Callback message. response.obj.userObj will be
         *            an IccIoResult on success.
         */
        IccTransmitApduBasicChannel(
            [in] Int32 cla,
            [in] Int32 instruction,
            [in] Int32 p1,
            [in] Int32 p2,
            [in] Int32 p3,
            [in] String data,
            [in] IMessage* response);

        /**
         * Get ATR (Answer To Reset; as per ISO/IEC 7816-4) from SIM card
         *
         * @param response Callback message
         */
        GetAtr(
            [in] IMessage* response);

        /**
         * Read one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.
         * Used for device configuration by some CDMA operators.
         *
         * @param itemID the ID of the item to read
         * @param response callback message with the String response in the obj field
         */
        NvReadItem(
            [in] Int32 itemID,
            [in] IMessage* response);

        /**
         * Write one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.
         * Used for device configuration by some CDMA operators.
         *
         * @param itemID the ID of the item to read
         * @param itemValue the value to write, as a String
         * @param response Callback message.
         */
        NvWriteItem(
            [in] Int32 itemID,
            [in] String itemValue,
            [in] IMessage* response);

        /**
         * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.
         * Used for device configuration by some CDMA operators.
         *
         * @param preferredRoamingList byte array containing the new PRL
         * @param response Callback message.
         */
        NvWriteCdmaPrl(
            [in] ArrayOf<Byte>* preferredRoamingList,
            [in] IMessage* response);

        /**
         * Perform the specified type of NV config reset. The radio will be taken offline
         * and the device must be rebooted after erasing the NV. Used for device
         * configuration by some CDMA operators.
         *
         * @param resetType reset type: 1: reload NV reset, 2: erase NV reset, 3: factory NV reset
         * @param response Callback message.
         */
        NvResetConfig(
            [in] Int32 resetType,
            [in] IMessage* response);

        /**
         *  returned message
         *  retMsg.obj = AsyncResult ar
         *  ar.exception carries exception on failure
         *  ar.userObject contains the orignal value of result.obj
         *  ar.result contains a List of HardwareConfig
         */
        GetHardwareConfig(
            [in] IMessage* result);

        /**
         * @return version of the ril.
         */
        GetRilVersion(
            [out] Int32* result);

       /**
         * Sets user selected subscription at Modem.
         *
         * @param slotId
         *          Slot.
         * @param appIndex
         *          Application index in the card.
         * @param subId
         *          Indicates subscription 0 or subscription 1.
         * @param subStatus
         *          Activation status, 1 = activate and 0 = deactivate.
         * @param result
         *          Callback message contains the information of SUCCESS/FAILURE.
         */
        // FIXME Update the doc and consider modifying the request to make more generic.
        SetUiccSubscription(
            [in] Int32 slotId,
            [in] Int32 appIndex,
            [in] Int32 subId,
            [in] Int32 subStatus,
            [in] IMessage* result);

        /**
         * Tells the modem if data is allowed or not.
         *
         * @param allowed
         *          true = allowed, false = not alowed
         * @param result
         *          Callback message contains the information of SUCCESS/FAILURE.
         */
        // FIXME We may need to pass AID and slotid also
        SetDataAllowed(
            [in] Boolean allowed,
            [in] IMessage* result);

        /**
          * Request to get modem stack capabilities
          * @param response is callback message
          */
        GetModemCapability(
            [in] IMessage* response);

        /**
          * Request to update binding status on the stack
          * @param stackId is stack to update binding
          * @param enable is to tell enable or disable binding
          * @param response is callback message
          */
        UpdateStackBinding(
            [in] Int32 stackId,
            [in] Int32 enbl,
            [in] IMessage* response);

        /**
         * Inform RIL that the device is shutting down
         *
         * @param result Callback message contains the information of SUCCESS/FAILURE
         */
        RequestShutdown(
            [in] IMessage* result);

        /**
         * @hide
         * CM-specific: Ask the RIL about the presence of back-compat flags
         */
        NeedsOldRilFeature(
            [in] String feature,
            [out] Boolean* result);

        /**
         * @hide
         * Register/unregister for WWAN and IWLAN coexistence
         * notification.
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForWwanIwlanCoexistence(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForWwanIwlanCoexistence(
            [in] IHandler* h);

        RegisterForSimRefreshEvent(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForSimRefreshEvent(
            [in] IHandler* h);

        /**
         * Request to update the current local call hold state.
         * @param lchStatus, true if call is in lch state
         */
        SetLocalCallHold(
            [in] Int32 lchStatus);

        /**
         * Register/unregister for modem capability oem hook event
         *
         * @param h Handler for notification message.
         * @param what User-defined message code.
         * @param obj User object.
         */
        RegisterForModemCapEvent(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnregisterForModemCapEvent(
            [in] IHandler* h);

        /**
         * @hide
         * samsung stk service implementation - set up registrant for sending
         * sms send result from modem(RIL) to catService
         */
        SetOnCatSendSmsResult(
            [in] IHandler* h,
            [in] Int32 what,
            [in] IInterface* obj);

        UnSetOnCatSendSmsResult(
            [in] IHandler* h);
    }

    }//Telephony
    }//Internal
    }//Droid
    }//Elastos

}
