//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    interface Elastos.Droid.App.IPendingIntent;
    interface Elastos.Droid.Content.IContext;
    interface Elastos.Droid.Content.IContentValues;
    interface Elastos.Droid.Net.IUri;
    interface Elastos.Droid.Os.IBundle;

    using interface Elastos.Utility.IArrayList;

    namespace Elastos {
    namespace Droid {
    namespace Telephony {

    [local, deprecated]
    interface ISmsManager {

        /**
         * Whether to append transaction id to MMS WAP Push M-Notification.ind's content location URI
         * when constructing the download URL of a new MMS (boolean type)
         */
        const String MMS_CONFIG_APPEND_TRANSACTION_ID = "enabledTransID";
        /**
         * Whether MMS is enabled for the current carrier (boolean type)
         */
        const String MMS_CONFIG_MMS_ENABLED = "enabledMMS";
        /**
         * Whether group MMS is enabled for the current carrier (boolean type)
         */
        const String MMS_CONFIG_GROUP_MMS_ENABLED = "enableGroupMms";
        /**
         * If this is enabled, M-NotifyResp.ind should be sent to the WAP Push content location
         * instead of the default MMSC (boolean type)
         */
        const String MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED = "enabledNotifyWapMMSC";
        /**
         * Whether alias is enabled (boolean type)
         */
        const String MMS_CONFIG_ALIAS_ENABLED = "aliasEnabled";
        /**
         * Whether audio is allowed to be attached for MMS messages (boolean type)
         */
        const String MMS_CONFIG_ALLOW_ATTACH_AUDIO = "allowAttachAudio";
        /**
         * Whether multipart SMS is enabled (boolean type)
         */
        const String MMS_CONFIG_MULTIPART_SMS_ENABLED = "enableMultipartSMS";
        /**
         * Whether SMS delivery report is enabled (boolean type)
         */
        const String MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED = "enableSMSDeliveryReports";
        /**
         * Whether content-disposition field should be expected in an MMS PDU (boolean type)
         */
        const String MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION =
                "supportMmsContentDisposition";
        /**
         * Whether multipart SMS should be sent as separate messages
         */
        const String MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES =
                "sendMultipartSmsAsSeparateMessages";
        /**
         * Whether MMS read report is enabled (boolean type)
         */
        const String MMS_CONFIG_MMS_READ_REPORT_ENABLED = "enableMMSReadReports";
        /**
         * Whether MMS delivery report is enabled (boolean type)
         */
        const String MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED = "enableMMSDeliveryReports";
        /**
         * Max MMS message size in bytes (int type)
         */
        const String MMS_CONFIG_MAX_MESSAGE_SIZE = "maxMessageSize";
        /**
         * Max MMS image width (int type)
         */
        const String MMS_CONFIG_MAX_IMAGE_WIDTH = "maxImageWidth";
        /**
         * Max MMS image height (int type)
         */
        const String MMS_CONFIG_MAX_IMAGE_HEIGHT = "maxImageHeight";
        /**
         * Limit of recipients of MMS messages (int type)
         */
        const String MMS_CONFIG_RECIPIENT_LIMIT = "recipientLimit";
        /**
         * Min alias character count (int type)
         */
        const String MMS_CONFIG_ALIAS_MIN_CHARS = "aliasMinChars";
        /**
         * Max alias character count (int type)
         */
        const String MMS_CONFIG_ALIAS_MAX_CHARS = "aliasMaxChars";
        /**
         * When the number of parts of a multipart SMS reaches this threshold, it should be
         * converted into an MMS (int type)
         */
        const String MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD = "smsToMmsTextThreshold";
        /**
         * Some carriers require SMS to be converted into MMS when text length reaches this threshold
         * (Int32 type)
         */
        const String MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD =
                "smsToMmsTextLengthThreshold";
        /**
         * Max message text size (Int32 type)
         */
        const String MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE = "maxMessageTextSize";
        /**
         * Max message subject length (Int32 type)
         */
        const String MMS_CONFIG_SUBJECT_MAX_LENGTH = "maxSubjectLength";
        /**
         * MMS HTTP socket timeout in milliseconds (Int32 type)
         */
        const String MMS_CONFIG_HTTP_SOCKET_TIMEOUT = "httpSocketTimeout";
        /**
         * The name of the UA Prof URL HTTP header for MMS HTTP request (String type)
         */
        const String MMS_CONFIG_UA_PROF_TAG_NAME = "uaProfTagName";
        /**
         * The User-Agent header value for MMS HTTP request (String type)
         */
        const String MMS_CONFIG_USER_AGENT = "userAgent";
        /**
         * The UA Profile URL header value for MMS HTTP request (String type)
         */
        const String MMS_CONFIG_UA_PROF_URL = "uaProfUrl";
        /**
         * A list of HTTP headers to add to MMS HTTP request, separated by "|" (String type)
         */
        const String MMS_CONFIG_HTTP_PARAMS = "httpParams";
        /**
         * Email gateway number (String type)
         */
        const String MMS_CONFIG_EMAIL_GATEWAY_NUMBER = "emailGatewayNumber";
        /**
         * The suffix to append to the NAI header value for MMS HTTP request (String type)
         */
        const String MMS_CONFIG_NAI_SUFFIX = "naiSuffix";

        /**
         * Send a text based SMS.
         *
         * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
         * {@link android.Manifest.permission#SEND_SMS} permission.</p>
         *
         * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
         * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
         * writes messages sent using this method to the SMS Provider (the default SMS app is always
         * responsible for writing its sent messages to the SMS Provider). For information about
         * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
         *
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *  the current default SMSC
         * @param text the body of the message to send
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed.
         *  The result code will be <code>Activity.RESULT_OK</code> for success,
         *  or one of these errors:<br>
         *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *  <code>RESULT_ERROR_RADIO_OFF</code><br>
         *  <code>RESULT_ERROR_NULL_PDU</code><br>
         *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
         *  the extra "errorCode" containing a radio technology specific value,
         *  generally only useful for troubleshooting.<br>
         *  The per-application based SMS control checks sentIntent. If sentIntent
         *  is NULL the caller will be checked against all unknown applications,
         *  which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is delivered to the recipient.  The
         *  raw pdu of the status report is in the extended data ("pdu").
         *
         * @throws IllegalArgumentException if destinationAddress or text are empty
         */
        SendTextMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] String text,
            [in] IPendingIntent* sentIntent,
            [in] IPendingIntent* deliveryIntent);

        /**
         * Send a text based SMS with messaging options.
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *  the current default SMSC
         * @param text the body of the message to send
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed.
         *  The result code will be <code>Activity.RESULT_OK</code> for success,
         *  or one of these errors:<br>
         *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *  <code>RESULT_ERROR_RADIO_OFF</code><br>
         *  <code>RESULT_ERROR_NULL_PDU</code><br>
         *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
         *  the extra "errorCode" containing a radio technology specific value,
         *  generally only useful for troubleshooting.<br>
         *  The per-application based SMS control checks sentIntent. If sentIntent
         *  is NULL the caller will be checked against all unknown applications,
         *  which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is delivered to the recipient.  The
         *  raw pdu of the status report is in the extended data ("pdu").
         * @param priority Priority level of the message
         *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
         *  ---------------------------------
         *  PRIORITY      | Level of Priority
         *  ---------------------------------
         *      '00'      |     Normal
         *      '01'      |     Interactive
         *      '10'      |     Urgent
         *      '11'      |     Emergency
         *  ----------------------------------
         *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
         * @param isExpectMore is a boolean to indicate the sending message is multi segmented or not.
         * @param validityPeriod Validity Period of the message in mins.
         *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
         *  Validity Period(Minimum) -> 5 mins
         *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
         *  Any Other values included Negative considered as Invalid Validity Period of the message.
         *
         * @throws IllegalArgumentException if destinationAddress or text are empty
         * {@hide}
         */
        SendTextMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] String text,
            [in] IPendingIntent* sentIntent,
            [in] IPendingIntent* deliveryIntent,
            [in] Int32 priority,
            [in] Boolean isExpectMore,
            [in] Int32 validityPeriod);

        /**
         * TODO Move this to new CarrierSmsManager class.
         *
         * Inject an SMS PDU into the android application framework.
         *
         * The caller should have carrier privileges.
         * @see android.telephony.TelephonyManager.hasCarrierPrivileges
         *
         * @param pdu is the byte array of pdu to be injected into android application framework
         * @param format is the format of SMS pdu (3gpp or 3gpp2)
         * @param receivedIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully received by the
         *  android application framework. This intent is broadcasted at
         *  the same time an SMS received from radio is acknowledged back.
         *
         *  @throws IllegalArgumentException if format is not one of 3gpp and 3gpp2.
         *  {@hide}
         */
        InjectSmsPdu(
            [in] ArrayOf<Byte>* pdu,
            [in] String format,
            [in] IPendingIntent* receivedIntent);

        /**
         * Update the status of a pending (send-by-IP) SMS message and resend by PSTN if necessary.
         * This outbound message was handled by the carrier app. If the carrier app fails to send
         * this message, it would be resent by PSTN.
         *
         * The caller should have carrier privileges.
         * @see android.telephony.TelephonyManager.hasCarrierPrivileges
         *
         * @param messageRef the reference number of the SMS message.
         * @param success True if and only if the message was sent successfully. If its value is
         *  false, this message should be resent via PSTN.
         * {@hide}
         */
        UpdateSmsSendStatus(
            [in] Int32 messageRef,
            [in] Boolean success);

        /**
         * Divide a message text into several fragments, none bigger than
         * the maximum SMS message size.
         *
         * @param text the original message.  Must not be null.
         * @return an <code>ArrayList</code> of strings that, in order,
         *   comprise the original message
         *
         * @throws IllegalArgumentException if text is null
         */
        DivideMessage(
            [in] String text,
            [in] IArrayList** result);

        /**
         * Send a multi-part text based SMS.  The callee should have already
         * divided the message into correctly sized parts by calling
         * <code>divideMessage</code>.
         *
         * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
         * {@link android.Manifest.permission#SEND_SMS} permission.</p>
         *
         * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
         * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
         * writes messages sent using this method to the SMS Provider (the default SMS app is always
         * responsible for writing its sent messages to the SMS Provider). For information about
         * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *   the current default SMSC
         * @param parts an <code>ArrayList</code> of strings that, in order,
         *   comprise the original message
         * @param sentIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been sent.
         *   The result code will be <code>Activity.RESULT_OK</code> for success,
         *   or one of these errors:<br>
         *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *   <code>RESULT_ERROR_RADIO_OFF</code><br>
         *   <code>RESULT_ERROR_NULL_PDU</code><br>
         *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
         *   the extra "errorCode" containing a radio technology specific value,
         *   generally only useful for troubleshooting.<br>
         *   The per-application based SMS control checks sentIntent. If sentIntent
         *   is NULL the caller will be checked against all unknown applications,
         *   which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been delivered
         *   to the recipient.  The raw pdu of the status report is in the
         *   extended data ("pdu").
         *
         * @throws IllegalArgumentException if destinationAddress or data are empty
         */
        SendMultipartTextMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] IArrayList* parts,
            [in] IArrayList* sentIntents,
            [in] IArrayList* deliveryIntents);

        /**
         * Send a multi-part text based SMS with messaging options. The callee should have already
         * divided the message into correctly sized parts by calling
         * <code>divideMessage</code>.
         *
         * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
         * {@link android.Manifest.permission#SEND_SMS} permission.</p>
         *
         * <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
         * <em>and only if</em> an app is not selected as the default SMS app, the system automatically
         * writes messages sent using this method to the SMS Provider (the default SMS app is always
         * responsible for writing its sent messages to the SMS Provider). For information about
         * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *   the current default SMSC
         * @param parts an <code>ArrayList</code> of strings that, in order,
         *   comprise the original message
         * @param sentIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been sent.
         *   The result code will be <code>Activity.RESULT_OK</code> for success,
         *   or one of these errors:<br>
         *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *   <code>RESULT_ERROR_RADIO_OFF</code><br>
         *   <code>RESULT_ERROR_NULL_PDU</code><br>
         *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
         *   the extra "errorCode" containing a radio technology specific value,
         *   generally only useful for troubleshooting.<br>
         *   The per-application based SMS control checks sentIntent. If sentIntent
         *   is NULL the caller will be checked against all unknown applications,
         *   which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been delivered
         *   to the recipient.  The raw pdu of the status report is in the
         *   extended data ("pdu").
         * @param priority Priority level of the message
         *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
         *  ---------------------------------
         *  PRIORITY      | Level of Priority
         *  ---------------------------------
         *      '00'      |     Normal
         *      '01'      |     Interactive
         *      '10'      |     Urgent
         *      '11'      |     Emergency
         *  ----------------------------------
         *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
         * @param isExpectMore is a boolean to indicate the sending message is multi segmented or not.
         * @param validityPeriod Validity Period of the message in mins.
         *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
         *  Validity Period(Minimum) -> 5 mins
         *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
         *  Any Other values included Negative considered as Invalid Validity Period of the message.
         *
         * @throws IllegalArgumentException if destinationAddress or data are empty
         * {@hide}
         */
        SendMultipartTextMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] IArrayList* parts,
            [in] IArrayList* sentIntents,
            [in] IArrayList* deliveryIntents,
            [in] Int32 priority,
            [in] Boolean isExpectMore,
            [in] Int32 validityPeriod);

        /**
         * Send a data based SMS to a specific application port.
         *
         * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
         * {@link android.Manifest.permission#SEND_SMS} permission.</p>
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *  the current default SMSC
         * @param destinationPort the port to deliver the message to
         * @param data the body of the message to send
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed.
         *  The result code will be <code>Activity.RESULT_OK</code> for success,
         *  or one of these errors:<br>
         *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *  <code>RESULT_ERROR_RADIO_OFF</code><br>
         *  <code>RESULT_ERROR_NULL_PDU</code><br>
         *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
         *  the extra "errorCode" containing a radio technology specific value,
         *  generally only useful for troubleshooting.<br>
         *  The per-application based SMS control checks sentIntent. If sentIntent
         *  is NULL the caller will be checked against all unknown applications,
         *  which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is delivered to the recipient.  The
         *  raw pdu of the status report is in the extended data ("pdu").
         *
         * @throws IllegalArgumentException if destinationAddress or data are empty
         */
        SendDataMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] Int16 destinationPort,
            [in] ArrayOf<Byte>* data,
            [in] IPendingIntent* sentIntent,
            [in] IPendingIntent* deliveryIntent);

        /**
         * Send a data based SMS to a specific application port.
         *
         * <p class="note"><strong>Note:</strong> Using this method requires that your app has the
         * {@link android.Manifest.permission#SEND_SMS} permission.</p>
         *
         * @param destinationAddress the address to send the message to
         * @param scAddress is the service center address or null to use
         *  the current default SMSC
         * @param destinationPort the port to deliver the message to
         * @param originatorPort the port set by the sender
         * @param data the body of the message to send
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed.
         *  The result code will be <code>Activity.RESULT_OK</code> for success,
         *  or one of these errors:<br>
         *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *  <code>RESULT_ERROR_RADIO_OFF</code><br>
         *  <code>RESULT_ERROR_NULL_PDU</code><br>
         *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
         *  the extra "errorCode" containing a radio technology specific value,
         *  generally only useful for troubleshooting.<br>
         *  The per-application based SMS control checks sentIntent. If sentIntent
         *  is NULL the caller will be checked against all unknown applications,
         *  which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is delivered to the recipient.  The
         *  raw pdu of the status report is in the extended data ("pdu").
         *
         * @throws IllegalArgumentException if destinationAddress or data are empty
         * {@hide}
         */
        SendDataMessage(
            [in] String destinationAddress,
            [in] String scAddress,
            [in] Int16 destinationPort,
            [in] Int16 originatorPort,
            [in] ArrayOf<Byte>* data,
            [in] IPendingIntent* sentIntent,
            [in] IPendingIntent* deliveryIntent);

        GetSubId(
            [out] Int64* result);

        /**
         * Copy a raw SMS PDU to the ICC.
         * ICC (Integrated Circuit Card) is the card of the device.
         * For example, this can be the SIM or USIM for GSM.
         *
         * @param smsc the SMSC for this message, or NULL for the default SMSC
         * @param pdu the raw PDU to store
         * @param status message status (STATUS_ON_ICC_READ, STATUS_ON_ICC_UNREAD,
         *               STATUS_ON_ICC_SENT, STATUS_ON_ICC_UNSENT)
         * @return true for success
         *
         * @throws IllegalArgumentException if pdu is NULL
         * {@hide}
         */
        CopyMessageToIcc(
            [in] ArrayOf<Byte>* smsc,
            [in] ArrayOf<Byte>* pdu,
            [in] Int32 status,
            [out] Boolean* result);

        /**
         * Delete the specified message from the ICC.
         * ICC (Integrated Circuit Card) is the card of the device.
         * For example, this can be the SIM or USIM for GSM.
         *
         * @param messageIndex is the record index of the message on ICC
         * @return true for success
         *
         * {@hide}
         */
        DeleteMessageFromIcc(
            [in] Int32 messageIndex,
            [out] Boolean* result);

        /**
         * Update the specified message on the ICC.
         * ICC (Integrated Circuit Card) is the card of the device.
         * For example, this can be the SIM or USIM for GSM.
         *
         * @param messageIndex record index of message to update
         * @param newStatus new message status (STATUS_ON_ICC_READ,
         *                  STATUS_ON_ICC_UNREAD, STATUS_ON_ICC_SENT,
         *                  STATUS_ON_ICC_UNSENT, STATUS_ON_ICC_FREE)
         * @param pdu the raw PDU to store
         * @return true for success
         *
         * {@hide}
         */
        UpdateMessageOnIcc(
            [in] Int32 messageIndex,
            [in] Int32 newStatus,
            [in] ArrayOf<Byte>* pdu,
            [out] Boolean* result);

        /**
         * Retrieves all messages currently stored on ICC.
         * ICC (Integrated Circuit Card) is the card of the device.
         * For example, this can be the SIM or USIM for GSM.
         *
         * @return <code>ArrayList</code> of <code>SmsMessage</code> objects
         *
         * {@hide}
         */
        GetAllMessagesFromIcc(
            [out] IArrayList** result);

        /**
         * Enable reception of cell broadcast (SMS-CB) messages with the given
         * message identifier. Note that if two different clients enable the same
         * message identifier, they must both disable it for the device to stop
         * receiving those messages. All received messages will be broadcast in an
         * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
         * Note: This call is blocking, callers may want to avoid calling it from
         * the main thread of an application.
         *
         * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @return true if successful, false otherwise
         * @see #disableCellBroadcast(int)
         *
         * {@hide}
         */
        EnableCellBroadcast(
            [in] Int32 messageIdentifier,
            [out] Boolean* result);

        /**
         * Disable reception of cell broadcast (SMS-CB) messages with the given
         * message identifier. Note that if two different clients enable the same
         * message identifier, they must both disable it for the device to stop
         * receiving those messages.
         * Note: This call is blocking, callers may want to avoid calling it from
         * the main thread of an application.
         *
         * @param messageIdentifier Message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @return true if successful, false otherwise
         *
         * @see #enableCellBroadcast(int)
         *
         * {@hide}
         */
        DisableCellBroadcast(
            [in] Int32 messageIdentifier,
            [out] Boolean* result);

        /**
         * Enable reception of cell broadcast (SMS-CB) messages with the given
         * message identifier range. Note that if two different clients enable the same
         * message identifier, they must both disable it for the device to stop
         * receiving those messages. All received messages will be broadcast in an
         * intent with the action "android.provider.Telephony.SMS_CB_RECEIVED".
         * Note: This call is blocking, callers may want to avoid calling it from
         * the main thread of an application.
         *
         * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @return true if successful, false otherwise
         * @see #disableCellBroadcastRange(int, int)
         *
         * @throws IllegalArgumentException if endMessageId < startMessageId
         * {@hide}
         */
        EnableCellBroadcastRange(
            [in] Int32 startMessageId,
            [in] Int32 endMessageId,
            [out] Boolean* result);

        /**
         * Disable reception of cell broadcast (SMS-CB) messages with the given
         * message identifier range. Note that if two different clients enable the same
         * message identifier, they must both disable it for the device to stop
         * receiving those messages.
         * Note: This call is blocking, callers may want to avoid calling it from
         * the main thread of an application.
         *
         * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)
         * or C.R1001-G (3GPP2)
         * @return true if successful, false otherwise
         *
         * @see #enableCellBroadcastRange(Int32, Int32)
         *
         * @throws IllegalArgumentException if endMessageId < startMessageId
         * {@hide}
         */
        DisableCellBroadcastRange(
            [in] Int32 startMessageId,
            [in] Int32 endMessageId,
            [out] Boolean* result);

        /**
         * SMS over IMS is supported if IMS is registered and SMS is supported
         * on IMS.
         *
         * @return true if SMS over IMS is supported, false otherwise
         *
         * @see #getImsSmsFormat()
         *
         * @hide
         */
        IsImsSmsSupported(
            [out] Boolean* result);

        /**
         * Gets SMS format supported on IMS.  SMS over IMS format is
         * either 3GPP or 3GPP2.
         *
         * @return SmsMessage.FORMAT_3GPP,
         *         SmsMessage.FORMAT_3GPP2
         *      or SmsMessage.FORMAT_UNKNOWN
         *
         * @see #isImsSmsSupported()
         *
         * @hide
         */
        GetImsSmsFormat(
            [out] String* result);

        /**
         * Get the capacity count of sms on Icc card
         *
         * @return the capacity count of sms on Icc card
         * @hide
         */
        GetSmsCapacityOnIcc(
            [out] Int32* result);

        /** Free space (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
        const Int32 STATUS_ON_ICC_FREE      = 0;

        /** Received and read (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
        const Int32 STATUS_ON_ICC_READ      = 1;

        /** Received and unread (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
        const Int32 STATUS_ON_ICC_UNREAD    = 3;

        /** Stored and sent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
        const Int32 STATUS_ON_ICC_SENT      = 5;

        /** Stored and unsent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). */
        const Int32 STATUS_ON_ICC_UNSENT    = 7;

        // SMS send failure result codes

        /** Generic failure cause */
        const Int32 RESULT_ERROR_GENERIC_FAILURE    = 1;
        /** Failed because radio was explicitly turned off */
        const Int32 RESULT_ERROR_RADIO_OFF          = 2;
        /** Failed because no pdu provided */
        const Int32 RESULT_ERROR_NULL_PDU           = 3;
        /** Failed because service is currently unavailable */
        const Int32 RESULT_ERROR_NO_SERVICE         = 4;
        /** Failed because we reached the sending queue limit.  {@hide} */
        const Int32 RESULT_ERROR_LIMIT_EXCEEDED     = 5;
        /** Failed because FDN is enabled. {@hide} */
        const Int32 RESULT_ERROR_FDN_CHECK_FAILURE  = 6;

        /**
         * Send an MMS message
         *
         * @param context application context
         * @param contentUri the content Uri from which the message pdu will be read
         * @param locationUrl the optional location url where message should be sent to
         * @param configOverrides the carrier-specific messaging configuration values to override for
         *  sending the message.
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed
         * @throws IllegalArgumentException if contentUri is empty
         */
        SendMultimediaMessage(
            [in] IContext* ctx,
            [in] IUri* contentUri,
            [in] String locationUrl,
            [in] IBundle* configOverrides,
            [in] IPendingIntent* sentIntent);

        /**
         * Download an MMS message from carrier by a given location URL
         *
         * @param context application context
         * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained
         *  from the MMS WAP push notification
         * @param contentUri the content uri to which the downloaded pdu will be written
         * @param configOverrides the carrier-specific messaging configuration values to override for
         *  downloading the message.
         * @param downloadedIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is downloaded, or the download is failed
         * @throws IllegalArgumentException if locationUrl or contentUri is empty
         */
        DownloadMultimediaMessage(
            [in] IContext* ctx,
            [in] String locationUrl,
            [in] IUri* contentUri,
            [in] IBundle* configOverrides,
            [in] IPendingIntent* downloadedIntent);

        // MMS send/download failure result codes
        const Int32 MMS_ERROR_UNSPECIFIED = 1;
        const Int32 MMS_ERROR_INVALID_APN = 2;
        const Int32 MMS_ERROR_UNABLE_CONNECT_MMS = 3;
        const Int32 MMS_ERROR_HTTP_FAILURE = 4;
        const Int32 MMS_ERROR_IO_ERROR = 5;
        const Int32 MMS_ERROR_RETRY = 6;
        const Int32 MMS_ERROR_CONFIGURATION_ERROR = 7;

        // Intent extra name for result data
        const String EXTRA_MMS_DATA = "android.telephony.extra.MMS_DATA";

        /**
         * Update the status of a pending (send-by-IP) MMS message handled by the carrier app.
         * If the carrier app fails to send this message, it may be resent via carrier network
         * depending on the status code.
         *
         * The caller should have carrier privileges.
         * @see android.telephony.TelephonyManager.hasCarrierPrivileges
         *
         * @param context application context
         * @param messageRef the reference number of the MMS message.
         * @param pdu non-empty (contains the SendConf PDU) if the message was sent successfully,
         *   otherwise, this param should be null.
         * @param status send status. It can be Activity.RESULT_OK or one of the MMS error codes.
         *   If status is Activity.RESULT_OK, the MMS was sent successfully.
         *   If status is MMS_ERROR_RETRY, this message would be resent via carrier
         *   network. The message will not be resent for other MMS error statuses.
         * @param contentUri the URI of the sent message
         * {@hide}
         */
        UpdateMmsSendStatus(
            [in] IContext* ctx,
            [in] Int32 messageRef,
            [in] ArrayOf<Byte>* pdu,
            [in] Int32 status,
            [in] IUri* contentUri);

        /**
         * Update the status of a pending (download-by-IP) MMS message handled by the carrier app.
         * If the carrier app fails to download this message, it may be re-downloaded via carrier
         * network depending on the status code.
         *
         * The caller should have carrier privileges.
         * @see android.telephony.TelephonyManager.hasCarrierPrivileges
         *
         * @param context application context
         * @param messageRef the reference number of the MMS message.
         * @param status download status.  It can be Activity.RESULT_OK or one of the MMS error codes.
         *   If status is Activity.RESULT_OK, the MMS was downloaded successfully.
         *   If status is MMS_ERROR_RETRY, this message would be re-downloaded via carrier
         *   network. The message will not be re-downloaded for other MMS error statuses.
         * @param contentUri the URI of the downloaded message
         * {@hide}
         */
        UpdateMmsDownloadStatus(
            [in] IContext* ctx,
            [in] Int32 messageRef,
            [in] Int32 status,
            [in] IUri* contentUri);

        /**
         * Import a text message into system's SMS store
         *
         * Only default SMS apps can import SMS
         *
         * @param address the destination(source) address of the sent(received) message
         * @param type the type of the message
         * @param text the message text
         * @param timestampMillis the message timestamp in milliseconds
         * @param seen if the message is seen
         * @param read if the message is read
         * @return the message URI, null if failed
         * @hide
         */
        ImportTextMessage(
            [in] String address,
            [in] Int32 type,
            [in] String text,
            [in] Int64 timestampMillis,
            [in] Boolean seen,
            [in] Boolean read,
            [out] IUri** result);

        /** Represents the received SMS message for importing {@hide} */
        const Int32 SMS_TYPE_INCOMING = 0;
        /** Represents the sent SMS message for importing {@hide} */
        const Int32 SMS_TYPE_OUTGOING = 1;

        /**
         * Import a multimedia message into system's MMS store. Only the following PDU type is
         * supported: Retrieve.conf, Send.req, Notification.ind, Delivery.ind, Read-Orig.ind
         *
         * Only default SMS apps can import MMS
         *
         * @param contentUri the content uri from which to read the PDU of the message to import
         * @param messageId the optional message id. Use null if not specifying
         * @param timestampSecs the optional message timestamp. Use -1 if not specifying
         * @param seen if the message is seen
         * @param read if the message is read
         * @return the message URI, null if failed
         * @throws IllegalArgumentException if pdu is empty
         * {@hide}
         */
        ImportMultimediaMessage(
            [in] IUri* contentUri,
            [in] String messageId,
            [in] Int64 timestampSecs,
            [in] Boolean seen,
            [in] Boolean read,
            [out] IUri** result);

        /**
         * Delete a system stored SMS or MMS message
         *
         * Only default SMS apps can delete system stored SMS and MMS messages
         *
         * @param messageUri the URI of the stored message
         * @return true if deletion is successful, false otherwise
         * @throws IllegalArgumentException if messageUri is empty
         * {@hide}
         */
        DeleteStoredMessage(
            [in] IUri* messageUri,
            [out] Boolean* result);

        /**
         * Delete a system stored SMS or MMS thread
         *
         * Only default SMS apps can delete system stored SMS and MMS conversations
         *
         * @param conversationId the ID of the message conversation
         * @return true if deletion is successful, false otherwise
         * {@hide}
         */
        DeleteStoredConversation(
            [in] Int64 conversationId,
            [out] Boolean* result);

        /**
         * Update the status properties of a system stored SMS or MMS message, e.g.
         * the read status of a message, etc.
         *
         * @param messageUri the URI of the stored message
         * @param statusValues a list of status properties in key-value pairs to update
         * @return true if update is successful, false otherwise
         * @throws IllegalArgumentException if messageUri is empty
         * {@hide}
         */
        UpdateStoredMessageStatus(
            [in] IUri* messageUri,
            [in] IContentValues* statusValues,
            [out] Boolean* result);

        /** Message status property: whether the message has been seen. 1 means seen, 0 not {@hide} */
        const String MESSAGE_STATUS_SEEN = "seen";
        /** Message status property: whether the message has been read. 1 means read, 0 not {@hide} */
        const String MESSAGE_STATUS_READ = "read";

        /**
         * Archive or unarchive a stored conversation
         *
         * @param conversationId the ID of the message conversation
         * @param archived true to archive the conversation, false to unarchive
         * @return true if update is successful, false otherwise
         * {@hide}
         */
        ArchiveStoredConversation(
            [in] Int64 conversationId,
            [in] Boolean archived,
            [out] Boolean* result);

        /**
         * Add a text message draft to system SMS store
         *
         * Only default SMS apps can add SMS draft
         *
         * @param address the destination address of message
         * @param text the body of the message to send
         * @return the URI of the stored draft message
         * {@hide}
         */
        AddTextMessageDraft(
            [in] String address,
            [in] String text,
            [out] IUri** result);

        /**
         * Add a multimedia message draft to system MMS store
         *
         * Only default SMS apps can add MMS draft
         *
         * @param contentUri the content uri from which to read the PDU data of the draft MMS
         * @return the URI of the stored draft message
         * @throws IllegalArgumentException if pdu is empty
         * {@hide}
         */
        AddMultimediaMessageDraft(
            [in] IUri* contentUri,
            [out] IUri** result);

        /**
         * Send a system stored text message.
         *
         * You can only send a failed text message or a draft text message.
         *
         * @param messageUri the URI of the stored message
         * @param scAddress is the service center address or null to use the current default SMSC
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed.
         *  The result code will be <code>Activity.RESULT_OK</code> for success,
         *  or one of these errors:<br>
         *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *  <code>RESULT_ERROR_RADIO_OFF</code><br>
         *  <code>RESULT_ERROR_NULL_PDU</code><br>
         *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
         *  the extra "errorCode" containing a radio technology specific value,
         *  generally only useful for troubleshooting.<br>
         *  The per-application based SMS control checks sentIntent. If sentIntent
         *  is NULL the caller will be checked against all unknown applications,
         *  which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is delivered to the recipient.  The
         *  raw pdu of the status report is in the extended data ("pdu").
         *
         * @throws IllegalArgumentException if messageUri is empty
         * {@hide}
         */
        SendStoredTextMessage(
            [in] IUri* messageUri,
            [in] String scAddress,
            [in] IPendingIntent* sentIntent,
            [in] IPendingIntent* deliveryIntent);

        /**
         * Send a system stored multi-part text message.
         *
         * You can only send a failed text message or a draft text message.
         * The provided <code>PendingIntent</code> lists should match the part number of the
         * divided text of the stored message by using <code>divideMessage</code>
         *
         * @param messageUri the URI of the stored message
         * @param scAddress is the service center address or null to use
         *   the current default SMSC
         * @param sentIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been sent.
         *   The result code will be <code>Activity.RESULT_OK</code> for success,
         *   or one of these errors:<br>
         *   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
         *   <code>RESULT_ERROR_RADIO_OFF</code><br>
         *   <code>RESULT_ERROR_NULL_PDU</code><br>
         *   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
         *   the extra "errorCode" containing a radio technology specific value,
         *   generally only useful for troubleshooting.<br>
         *   The per-application based SMS control checks sentIntent. If sentIntent
         *   is NULL the caller will be checked against all unknown applications,
         *   which cause smaller number of SMS to be sent in checking period.
         * @param deliveryIntents if not null, an <code>ArrayList</code> of
         *   <code>PendingIntent</code>s (one for each message part) that is
         *   broadcast when the corresponding message part has been delivered
         *   to the recipient.  The raw pdu of the status report is in the
         *   extended data ("pdu").
         *
         * @throws IllegalArgumentException if messageUri is empty
         * {@hide}
         */
        SendStoredMultipartTextMessage(
            [in] IUri* messageUri,
            [in] String scAddress,
            [in] IArrayList* sentIntents,
            [in] IArrayList* deliveryIntents);

        /**
         * Send a system stored MMS message
         *
         * This is used for sending a previously sent, but failed-to-send, message or
         * for sending a text message that has been stored as a draft.
         *
         * @param messageUri the URI of the stored message
         * @param configOverrides the carrier-specific messaging configuration values to override for
         *  sending the message.
         * @param sentIntent if not NULL this <code>PendingIntent</code> is
         *  broadcast when the message is successfully sent, or failed
         * @throws IllegalArgumentException if messageUri is empty
         * {@hide}
         */
        SendStoredMultimediaMessage(
            [in] IUri* messageUri,
            [in] IBundle* configOverrides,
            [in] IPendingIntent* sentIntent);

        /**
         * Turns on/off the flag to automatically write sent/received SMS/MMS messages into system
         *
         * When this flag is on, all SMS/MMS sent/received are stored by system automatically
         * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
         * automatically
         *
         * This flag can only be changed by default SMS apps
         *
         * @param enabled Whether to enable message auto persisting
         * {@hide}
         */
        SetAutoPersisting(
            [in] Boolean enabled);

        /**
         * Get the value of the flag to automatically write sent/received SMS/MMS messages into system
         *
         * When this flag is on, all SMS/MMS sent/received are stored by system automatically
         * When this flag is off, only SMS/MMS sent by non-default SMS apps are stored by system
         * automatically
         *
         * @return the current value of the auto persist flag
         * {@hide}
         */
        GetAutoPersisting(
            [out] Boolean* result);

        /**
         * Get carrier-dependent configuration values.
         *
         * @return bundle key/values pairs of configuration values
         */
        GetCarrierConfigValues(
            [out] IBundle** result);

    }

    [local]
    interface ISmsManagerHelper {

        GetDefault(
            [out] ISmsManager** result);

        GetSmsManagerForSubscriber(
            [in] Int64 subId,
            [out] ISmsManager** result);

        /**
         * Get the default sms subId
         *
         * @return the default sms subId
         * @hide
         */
        GetDefaultSmsSubId(
            [out] Int64* result);

    }

    }//Telephony
    }//Droid
    }//Elastos

}
