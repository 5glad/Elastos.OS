
#include "elastos/droid/internal/telephony/dataconnection/DcFailCause.h"
#include <Elastos.CoreLibrary.Utility.h>

namespace Elastos {
namespace Droid {
namespace Internal {
namespace Telephony {
namespace DataConnection {

CAR_INTERFACE_IMPL(DcFailCause, Object, IDcFailCause)

AutoPtr<IHashMap> DcFailCause::sErrorCodeToFailCauseMap = InitErrorCodeToFailCauseMap();

DcFailCause::DcFailCause()
{
#if 0 // TODO: Translate codes below
    Boolean mRestartRadioOnRegularDeactivation = Resources.getSystem().getBoolean(
            com.android.internal.R.bool.config_restart_radio_on_pdp_fail_regular_deactivation);
#endif
}

ECode DcFailCause::constructor(
    /* [in] */ Int32 errorCode)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        mErrorCode = errorCode;

#endif
}

ECode DcFailCause::GetErrorCode(
    /* [out] */ Int32* result)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        return mErrorCode;

#endif
}

ECode DcFailCause::IsRestartRadioFail(
    /* [out] */ Boolean* result)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        return (this == REGULAR_DEACTIVATION && mRestartRadioOnRegularDeactivation);

#endif
}

ECode DcFailCause::IsPermanentFail(
    /* [out] */ Boolean* result)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        Context context = PhoneFactory.getContext();
        if (this == ACTIVATION_REJECT_GGSN) {
            return (context.getResources().
                    getBoolean(com.android.internal.R.bool.config_reject_ggsn_perm_failure));
        } else if (this == PROTOCOL_ERRORS) {
            return (context.getResources().
                    getBoolean(com.android.internal.R.bool.config_protocol_errors_perm_failure));
        } else {
            return (this == OPERATOR_BARRED) || (this == MISSING_UNKNOWN_APN) ||
                    (this == UNKNOWN_PDP_ADDRESS_TYPE) || (this == USER_AUTHENTICATION) ||
                    (this == SERVICE_OPTION_NOT_SUPPORTED) ||
                    (this == SERVICE_OPTION_NOT_SUBSCRIBED) || (this == NSAPI_IN_USE) ||
                    (this == ONLY_IPV4_ALLOWED) || (this == ONLY_IPV6_ALLOWED) ||
                    (this == RADIO_POWER_OFF) || (this == TETHERED_CALL_ACTIVE) ||
                    (this == RADIO_NOT_AVAILABLE) || (this == UNACCEPTABLE_NETWORK_PARAMETER);
        }

#endif
}

ECode DcFailCause::IsEventLoggable(
    /* [out] */ Boolean* result)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        return (this == OPERATOR_BARRED) || (this == INSUFFICIENT_RESOURCES) ||
                (this == UNKNOWN_PDP_ADDRESS_TYPE) || (this == USER_AUTHENTICATION) ||
                (this == ACTIVATION_REJECT_GGSN) || (this == ACTIVATION_REJECT_UNSPECIFIED) ||
                (this == SERVICE_OPTION_NOT_SUBSCRIBED) ||
                (this == SERVICE_OPTION_NOT_SUPPORTED) ||
                (this == SERVICE_OPTION_OUT_OF_ORDER) || (this == NSAPI_IN_USE) ||
                (this == ONLY_IPV4_ALLOWED) || (this == ONLY_IPV6_ALLOWED) ||
                (this == PROTOCOL_ERRORS) || (this == SIGNAL_LOST) ||
                (this == RADIO_POWER_OFF) || (this == TETHERED_CALL_ACTIVE) ||
                (this == UNACCEPTABLE_NETWORK_PARAMETER);

#endif
}

ECode DcFailCause::FromInt32(
    /* [in] */ Int32 errorCode,
    /* [out] */ IDcFailCause** result)
{
    return E_NOT_IMPLEMENTED;
#if 0 // TODO: Translate codes below
        DcFailCause fc = sErrorCodeToFailCauseMap.get(errorCode);
        if (fc == null) {
            fc = UNKNOWN;
        }
        return fc;

#endif
}

AutoPtr<IHashMap> DcFailCause::InitErrorCodeToFailCauseMap()
{
    AutoPtr<IHashMap> rev;
#if 0 // TODO: Translate codes below
    CHashMap::New((IHashMap**)&rev);
    Int32 values[] = {
            DcFailCause_NONE,
            DcFailCause_OPERATOR_BARRED,
            DcFailCause_INSUFFICIENT_RESOURCES,
            DcFailCause_MISSING_UNKNOWN_APN,
            DcFailCause_UNKNOWN_PDP_ADDRESS_TYPE,
            DcFailCause_USER_AUTHENTICATION,
            DcFailCause_ACTIVATION_REJECT_GGSN,
            DcFailCause_ACTIVATION_REJECT_UNSPECIFIED,
            DcFailCause_SERVICE_OPTION_NOT_SUPPORTED,
            DcFailCause_SERVICE_OPTION_NOT_SUBSCRIBED,
            DcFailCause_SERVICE_OPTION_OUT_OF_ORDER,
            DcFailCause_NSAPI_IN_USE,
            DcFailCause_REGULAR_DEACTIVATION,
            DcFailCause_ONLY_IPV4_ALLOWED,
            DcFailCause_ONLY_IPV6_ALLOWED,
            DcFailCause_ONLY_SINGLE_BEARER_ALLOWED,
            DcFailCause_PROTOCOL_ERRORS,

            // Local errors generated by Vendor RIL
            // specified in ril.h
            DcFailCause_REGISTRATION_FAIL,
            DcFailCause_GPRS_REGISTRATION_FAIL,
            DcFailCause_SIGNAL_LOST,
            DcFailCause_PREF_RADIO_TECH_CHANGED,
            DcFailCause_RADIO_POWER_OFF,
            DcFailCause_TETHERED_CALL_ACTIVE,
            DcFailCause_ERROR_UNSPECIFIED,

            // Errors generated by the Framework
            // specified here
            DcFailCause_UNKNOWN,
            DcFailCause_RADIO_NOT_AVAILABLE,
            DcFailCause_UNACCEPTABLE_NETWORK_PARAMETER,
            DcFailCause_CONNECTION_TO_DATACONNECTIONAC_BROKEN,
            DcFailCause_LOST_CONNECTION,
            DcFailCause_RESET_BY_FRAMEWORK};

    for (Int32 i = 0; i < sizeof(values) / sizeof(Int32); ++i) {
        AutoPtr<IInteger32> i32;
        CInteger32::New(values[i], (IInteger32**)&i32);
        rev->Put(i32, i32);
    }
#endif
    return rev;
}

} // namespace DataConnection
} // namespace Telephony
} // namespace Internal
} // namespace Droid
} // namespace Elastos
