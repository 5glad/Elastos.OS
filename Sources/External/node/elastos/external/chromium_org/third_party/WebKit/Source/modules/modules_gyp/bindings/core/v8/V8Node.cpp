// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8Node.h"

#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/v8/ExceptionState.h"
#include "bindings/v8/V8DOMActivityLogger.h"
#include "bindings/v8/V8DOMConfiguration.h"
#include "bindings/v8/V8HiddenValue.h"
#include "bindings/v8/V8ObjectConstructor.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/StaticNodeList.h"
#include "core/dom/custom/CustomElementCallbackDispatcher.h"
#include "core/frame/UseCounter.h"
#include "core/html/LabelsNodeList.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace WebCore {

static void initializeScriptWrappableForInterface(Node* object)
{
    if (ScriptWrappable::wrapperCanBeStoredInObject(object))
        ScriptWrappable::fromObject(object)->setTypeInfo(&V8Node::wrapperTypeInfo);
    else
        ASSERT_NOT_REACHED();
}

} // namespace WebCore

void webCoreInitializeScriptWrappableForInterface(WebCore::Node* object)
{
    WebCore::initializeScriptWrappableForInterface(object);
}

namespace WebCore {
const WrapperTypeInfo V8Node::wrapperTypeInfo = { gin::kEmbedderBlink, V8Node::domTemplate, V8Node::derefObject, 0, V8Node::toEventTarget, 0, V8Node::installPerContextEnabledMethods, &V8EventTarget::wrapperTypeInfo, WrapperTypeObjectPrototype, WillBeGarbageCollectedObject };

namespace NodeV8Internal {

template <typename T> void V8_USE(T) { }

static void nodeNameAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueString(info, impl->nodeName(), info.GetIsolate());
}

static void nodeNameAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::nodeNameAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nodeValueAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueStringOrNull(info, impl->nodeValue(), info.GetIsolate());
}

static void nodeValueAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::nodeValueAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nodeValueAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithNullCheck>, cppValue, v8Value);
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    impl->setNodeValue(cppValue);
}

static void nodeValueAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    NodeV8Internal::nodeValueAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nodeTypeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueUnsigned(info, impl->nodeType());
}

static void nodeTypeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::nodeTypeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void parentNodeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->parentNode()), impl);
}

static void parentNodeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::parentNodeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void parentNodeAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->parentNode()));
}

static void parentNodeAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::parentNodeAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void childNodesAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->childNodes()), impl);
}

static void childNodesAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::childNodesAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void childNodesAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->childNodes()));
}

static void childNodesAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::childNodesAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void firstChildAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->firstChild()), impl);
}

static void firstChildAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::firstChildAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void firstChildAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->firstChild()));
}

static void firstChildAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::firstChildAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lastChildAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->lastChild()), impl);
}

static void lastChildAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::lastChildAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lastChildAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->lastChild()));
}

static void lastChildAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::lastChildAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void previousSiblingAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->previousSibling()), impl);
}

static void previousSiblingAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::previousSiblingAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void previousSiblingAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->previousSibling()));
}

static void previousSiblingAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::previousSiblingAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nextSiblingAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->nextSibling()), impl);
}

static void nextSiblingAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::nextSiblingAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nextSiblingAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->nextSibling()));
}

static void nextSiblingAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::nextSiblingAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void ownerDocumentAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->ownerDocument()), impl);
}

static void ownerDocumentAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::ownerDocumentAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void ownerDocumentAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->ownerDocument()));
}

static void ownerDocumentAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::ownerDocumentAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void namespaceURIAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueStringOrNull(info, impl->namespaceURI(), info.GetIsolate());
}

static void namespaceURIAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::NodeNamespaceURI);
    NodeV8Internal::namespaceURIAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void localNameAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueStringOrNull(info, impl->localName(), info.GetIsolate());
}

static void localNameAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::NodeLocalName);
    NodeV8Internal::localNameAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void baseURIAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueStringOrNull(info, impl->baseURI(), info.GetIsolate());
}

static void baseURIAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::baseURIAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textContentAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueStringOrNull(info, impl->textContent(), info.GetIsolate());
}

static void textContentAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::textContentAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textContentAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithUndefinedOrNullCheck>, cppValue, v8Value);
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    impl->setTextContent(cppValue);
}

static void textContentAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    NodeV8Internal::textContentAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void parentElementAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->parentElement()), impl);
}

static void parentElementAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::parentElementAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void parentElementAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toNative(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->parentElement()));
}

static void parentElementAttributeGetterCallbackForMainWorld(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    NodeV8Internal::parentElementAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void insertBeforeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    ScriptState* scriptState = ScriptState::from(info.GetIsolate()->GetCurrentContext());
    V8PerContextData* contextData = scriptState->perContextData();
    if (contextData && contextData->activityLogger()) {
        Vector<v8::Handle<v8::Value> > loggerArgs = toNativeArguments<v8::Handle<v8::Value> >(info, 0);
        contextData->activityLogger()->logMethod("Node.insertBefore", info.Length(), loggerArgs.data());
    }
    V8Node::insertBeforeMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void insertBeforeMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8Node::insertBeforeMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void replaceChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    ScriptState* scriptState = ScriptState::from(info.GetIsolate()->GetCurrentContext());
    V8PerContextData* contextData = scriptState->perContextData();
    if (contextData && contextData->activityLogger()) {
        Vector<v8::Handle<v8::Value> > loggerArgs = toNativeArguments<v8::Handle<v8::Value> >(info, 0);
        contextData->activityLogger()->logMethod("Node.replaceChild", info.Length(), loggerArgs.data());
    }
    V8Node::replaceChildMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void replaceChildMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8Node::replaceChildMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void removeChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8Node::removeChildMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void appendChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    ScriptState* scriptState = ScriptState::from(info.GetIsolate()->GetCurrentContext());
    V8PerContextData* contextData = scriptState->perContextData();
    if (contextData && contextData->activityLogger()) {
        Vector<v8::Handle<v8::Value> > loggerArgs = toNativeArguments<v8::Handle<v8::Value> >(info, 0);
        contextData->activityLogger()->logMethod("Node.appendChild", info.Length(), loggerArgs.data());
    }
    V8Node::appendChildMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void appendChildMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8Node::appendChildMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasChildNodesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toNative(info.Holder());
    v8SetReturnValueBool(info, impl->hasChildren());
}

static void hasChildNodesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::hasChildNodesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void cloneNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toNative(info.Holder());
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    bool deep;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueFast(info, WTF::getPtr(impl->cloneNode()), impl);
            return;
        }
        TONATIVE_VOID_INTERNAL(deep, info[0]->BooleanValue());
    }
    v8SetReturnValueFast(info, WTF::getPtr(impl->cloneNode(deep)), impl);
}

static void cloneNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::cloneNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void normalizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toNative(info.Holder());
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    impl->normalize();
}

static void normalizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::normalizeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isSameNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toNative(info.Holder());
    Node* other;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(other, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isSameNode(other));
}

static void isSameNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::NodeIsSameNode);
    NodeV8Internal::isSameNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isEqualNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isEqualNode", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    Node* other;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(other, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isEqualNode(other));
}

static void isEqualNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::isEqualNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lookupPrefixMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("lookupPrefix", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    V8StringResource<WithNullCheck> namespaceURI;
    {
        TOSTRING_VOID_INTERNAL(namespaceURI, info[0]);
    }
    v8SetReturnValueStringOrNull(info, impl->lookupPrefix(namespaceURI), info.GetIsolate());
}

static void lookupPrefixMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::lookupPrefixMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isDefaultNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isDefaultNamespace", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    V8StringResource<WithNullCheck> namespaceURI;
    {
        TOSTRING_VOID_INTERNAL(namespaceURI, info[0]);
    }
    v8SetReturnValueBool(info, impl->isDefaultNamespace(namespaceURI));
}

static void isDefaultNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::isDefaultNamespaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lookupNamespaceURIMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("lookupNamespaceURI", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    V8StringResource<WithNullCheck> prefix;
    {
        TOSTRING_VOID_INTERNAL(prefix, info[0]);
    }
    v8SetReturnValueStringOrNull(info, impl->lookupNamespaceURI(prefix), info.GetIsolate());
}

static void lookupNamespaceURIMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::lookupNamespaceURIMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void compareDocumentPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("compareDocumentPosition", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    Node* other;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(other, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueUnsigned(info, impl->compareDocumentPosition(other));
}

static void compareDocumentPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::compareDocumentPositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void containsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("contains", "Node", 1, info.Length(), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toNative(info.Holder());
    Node* other;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(other, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->contains(other));
}

static void containsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    NodeV8Internal::containsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

} // namespace NodeV8Internal

static const V8DOMConfiguration::AttributeConfiguration V8NodeAttributes[] = {
    {"nodeName", NodeV8Internal::nodeNameAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"nodeValue", NodeV8Internal::nodeValueAttributeGetterCallback, NodeV8Internal::nodeValueAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"nodeType", NodeV8Internal::nodeTypeAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"parentNode", NodeV8Internal::parentNodeAttributeGetterCallback, 0, NodeV8Internal::parentNodeAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"childNodes", NodeV8Internal::childNodesAttributeGetterCallback, 0, NodeV8Internal::childNodesAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"firstChild", NodeV8Internal::firstChildAttributeGetterCallback, 0, NodeV8Internal::firstChildAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"lastChild", NodeV8Internal::lastChildAttributeGetterCallback, 0, NodeV8Internal::lastChildAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"previousSibling", NodeV8Internal::previousSiblingAttributeGetterCallback, 0, NodeV8Internal::previousSiblingAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"nextSibling", NodeV8Internal::nextSiblingAttributeGetterCallback, 0, NodeV8Internal::nextSiblingAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"ownerDocument", NodeV8Internal::ownerDocumentAttributeGetterCallback, 0, NodeV8Internal::ownerDocumentAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"namespaceURI", NodeV8Internal::namespaceURIAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"localName", NodeV8Internal::localNameAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"baseURI", NodeV8Internal::baseURIAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"textContent", NodeV8Internal::textContentAttributeGetterCallback, NodeV8Internal::textContentAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"parentElement", NodeV8Internal::parentElementAttributeGetterCallback, 0, NodeV8Internal::parentElementAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const V8DOMConfiguration::MethodConfiguration V8NodeMethods[] = {
    {"insertBefore", NodeV8Internal::insertBeforeMethodCallback, NodeV8Internal::insertBeforeMethodCallbackForMainWorld, 2},
    {"replaceChild", NodeV8Internal::replaceChildMethodCallback, NodeV8Internal::replaceChildMethodCallbackForMainWorld, 2},
    {"removeChild", NodeV8Internal::removeChildMethodCallback, 0, 1},
    {"appendChild", NodeV8Internal::appendChildMethodCallback, NodeV8Internal::appendChildMethodCallbackForMainWorld, 1},
    {"hasChildNodes", NodeV8Internal::hasChildNodesMethodCallback, 0, 0},
    {"cloneNode", NodeV8Internal::cloneNodeMethodCallback, 0, 0},
    {"normalize", NodeV8Internal::normalizeMethodCallback, 0, 0},
    {"isSameNode", NodeV8Internal::isSameNodeMethodCallback, 0, 0},
    {"isEqualNode", NodeV8Internal::isEqualNodeMethodCallback, 0, 1},
    {"lookupPrefix", NodeV8Internal::lookupPrefixMethodCallback, 0, 1},
    {"isDefaultNamespace", NodeV8Internal::isDefaultNamespaceMethodCallback, 0, 1},
    {"lookupNamespaceURI", NodeV8Internal::lookupNamespaceURIMethodCallback, 0, 1},
    {"compareDocumentPosition", NodeV8Internal::compareDocumentPositionMethodCallback, 0, 1},
    {"contains", NodeV8Internal::containsMethodCallback, 0, 1},
};

static void configureV8NodeTemplate(v8::Handle<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(functionTemplate, "Node", V8EventTarget::domTemplate(isolate), V8Node::internalFieldCount,
        V8NodeAttributes, WTF_ARRAY_LENGTH(V8NodeAttributes),
        0, 0,
        V8NodeMethods, WTF_ARRAY_LENGTH(V8NodeMethods),
        isolate);
    v8::Local<v8::ObjectTemplate> instanceTemplate ALLOW_UNUSED = functionTemplate->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototypeTemplate ALLOW_UNUSED = functionTemplate->PrototypeTemplate();
    static const V8DOMConfiguration::ConstantConfiguration V8NodeConstants[] = {
        {"ELEMENT_NODE", 1},
        {"ATTRIBUTE_NODE", 2},
        {"TEXT_NODE", 3},
        {"CDATA_SECTION_NODE", 4},
        {"ENTITY_REFERENCE_NODE", 5},
        {"ENTITY_NODE", 6},
        {"PROCESSING_INSTRUCTION_NODE", 7},
        {"COMMENT_NODE", 8},
        {"DOCUMENT_NODE", 9},
        {"DOCUMENT_TYPE_NODE", 10},
        {"DOCUMENT_FRAGMENT_NODE", 11},
        {"NOTATION_NODE", 12},
        {"DOCUMENT_POSITION_DISCONNECTED", 0x01},
        {"DOCUMENT_POSITION_PRECEDING", 0x02},
        {"DOCUMENT_POSITION_FOLLOWING", 0x04},
        {"DOCUMENT_POSITION_CONTAINS", 0x08},
        {"DOCUMENT_POSITION_CONTAINED_BY", 0x10},
        {"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 0x20},
    };
    V8DOMConfiguration::installConstants(functionTemplate, prototypeTemplate, V8NodeConstants, WTF_ARRAY_LENGTH(V8NodeConstants), isolate);
    COMPILE_ASSERT(1 == Node::ELEMENT_NODE, TheValueOfNode_ELEMENT_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(2 == Node::ATTRIBUTE_NODE, TheValueOfNode_ATTRIBUTE_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(3 == Node::TEXT_NODE, TheValueOfNode_TEXT_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(4 == Node::CDATA_SECTION_NODE, TheValueOfNode_CDATA_SECTION_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(5 == Node::ENTITY_REFERENCE_NODE, TheValueOfNode_ENTITY_REFERENCE_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(6 == Node::ENTITY_NODE, TheValueOfNode_ENTITY_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(7 == Node::PROCESSING_INSTRUCTION_NODE, TheValueOfNode_PROCESSING_INSTRUCTION_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(8 == Node::COMMENT_NODE, TheValueOfNode_COMMENT_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(9 == Node::DOCUMENT_NODE, TheValueOfNode_DOCUMENT_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(10 == Node::DOCUMENT_TYPE_NODE, TheValueOfNode_DOCUMENT_TYPE_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(11 == Node::DOCUMENT_FRAGMENT_NODE, TheValueOfNode_DOCUMENT_FRAGMENT_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(12 == Node::NOTATION_NODE, TheValueOfNode_NOTATION_NODEDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x01 == Node::DOCUMENT_POSITION_DISCONNECTED, TheValueOfNode_DOCUMENT_POSITION_DISCONNECTEDDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x02 == Node::DOCUMENT_POSITION_PRECEDING, TheValueOfNode_DOCUMENT_POSITION_PRECEDINGDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x04 == Node::DOCUMENT_POSITION_FOLLOWING, TheValueOfNode_DOCUMENT_POSITION_FOLLOWINGDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x08 == Node::DOCUMENT_POSITION_CONTAINS, TheValueOfNode_DOCUMENT_POSITION_CONTAINSDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x10 == Node::DOCUMENT_POSITION_CONTAINED_BY, TheValueOfNode_DOCUMENT_POSITION_CONTAINED_BYDoesntMatchWithImplementation);
    COMPILE_ASSERT(0x20 == Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, TheValueOfNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFICDoesntMatchWithImplementation);

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Handle<v8::FunctionTemplate> V8Node::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), configureV8NodeTemplate);
}

bool V8Node::hasInstance(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Handle<v8::Object> V8Node::findInstanceInPrototypeChain(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Node* V8Node::toNativeWithTypeCheck(v8::Isolate* isolate, v8::Handle<v8::Value> value)
{
    return hasInstance(value, isolate) ? fromInternalPointer(v8::Handle<v8::Object>::Cast(value)->GetAlignedPointerFromInternalField(v8DOMWrapperObjectIndex)) : 0;
}

EventTarget* V8Node::toEventTarget(v8::Handle<v8::Object> object)
{
    return toNative(object);
}

v8::Handle<v8::Object> V8Node::createWrapper(PassRefPtrWillBeRawPtr<Node> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8Node>(impl.get(), isolate));
    if (ScriptWrappable::wrapperCanBeStoredInObject(impl.get())) {
        const WrapperTypeInfo* actualInfo = ScriptWrappable::fromObject(impl.get())->typeInfo();
        // Might be a XXXConstructor::wrapperTypeInfo instead of an XXX::wrapperTypeInfo. These will both have
        // the same object de-ref functions, though, so use that as the basis of the check.
        RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(actualInfo->derefObjectFunction == wrapperTypeInfo.derefObjectFunction);
    }

    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &wrapperTypeInfo, toInternalPointer(impl.get()), isolate);
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    installPerContextEnabledProperties(wrapper, impl.get(), isolate);
    V8DOMWrapper::associateObjectWithWrapper<V8Node>(impl, &wrapperTypeInfo, wrapper, isolate, WrapperConfiguration::Dependent);
    return wrapper;
}

void V8Node::derefObject(void* object)
{
#if !ENABLE(OILPAN)
    fromInternalPointer(object)->deref();
#endif // !ENABLE(OILPAN)
}

template<>
v8::Handle<v8::Value> toV8NoInline(Node* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    return toV8(impl, creationContext, isolate);
}

} // namespace WebCore
