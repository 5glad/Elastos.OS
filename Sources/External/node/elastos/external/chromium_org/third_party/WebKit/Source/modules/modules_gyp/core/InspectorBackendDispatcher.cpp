// File is generated by Source/core/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


#include "config.h"
#include "InspectorBackendDispatcher.h"

#include "core/inspector/InspectorFrontendChannel.h"
#include "core/inspector/JSONParser.h"
#include "platform/JSONValues.h"
#include "wtf/text/CString.h"
#include "wtf/text/WTFString.h"

namespace WebCore {

const char InspectorBackendDispatcher::commandNames[] = {
    "Inspector.enable\0"
    "Inspector.disable\0"
    "Inspector.reset\0"
    "Memory.getDOMCounters\0"
    "Page.enable\0"
    "Page.disable\0"
    "Page.addScriptToEvaluateOnLoad\0"
    "Page.removeScriptToEvaluateOnLoad\0"
    "Page.reload\0"
    "Page.navigate\0"
    "Page.getCookies\0"
    "Page.deleteCookie\0"
    "Page.getResourceTree\0"
    "Page.getResourceContent\0"
    "Page.searchInResource\0"
    "Page.setDocumentContent\0"
    "Page.setDeviceMetricsOverride\0"
    "Page.clearDeviceMetricsOverride\0"
    "Page.setShowPaintRects\0"
    "Page.setShowDebugBorders\0"
    "Page.setShowFPSCounter\0"
    "Page.setContinuousPaintingEnabled\0"
    "Page.setShowScrollBottleneckRects\0"
    "Page.getScriptExecutionStatus\0"
    "Page.setScriptExecutionDisabled\0"
    "Page.setGeolocationOverride\0"
    "Page.clearGeolocationOverride\0"
    "Page.setDeviceOrientationOverride\0"
    "Page.clearDeviceOrientationOverride\0"
    "Page.hasTouchInputs\0"
    "Page.setTouchEmulationEnabled\0"
    "Page.setEmulatedMedia\0"
    "Page.setShowViewportSizeOnResize\0"
    "Runtime.evaluate\0"
    "Runtime.callFunctionOn\0"
    "Runtime.getProperties\0"
    "Runtime.releaseObject\0"
    "Runtime.releaseObjectGroup\0"
    "Runtime.run\0"
    "Runtime.enable\0"
    "Runtime.disable\0"
    "Runtime.isRunRequired\0"
    "Console.enable\0"
    "Console.disable\0"
    "Console.clearMessages\0"
    "Console.setMonitoringXHREnabled\0"
    "Console.addInspectedNode\0"
    "Console.addInspectedHeapObject\0"
    "Network.enable\0"
    "Network.disable\0"
    "Network.setUserAgentOverride\0"
    "Network.setExtraHTTPHeaders\0"
    "Network.getResponseBody\0"
    "Network.replayXHR\0"
    "Network.canClearBrowserCache\0"
    "Network.canClearBrowserCookies\0"
    "Network.setCacheDisabled\0"
    "Network.loadResourceForFrontend\0"
    "Database.enable\0"
    "Database.disable\0"
    "Database.getDatabaseTableNames\0"
    "Database.executeSQL\0"
    "IndexedDB.enable\0"
    "IndexedDB.disable\0"
    "IndexedDB.requestDatabaseNames\0"
    "IndexedDB.requestDatabase\0"
    "IndexedDB.requestData\0"
    "IndexedDB.clearObjectStore\0"
    "DOMStorage.enable\0"
    "DOMStorage.disable\0"
    "DOMStorage.getDOMStorageItems\0"
    "DOMStorage.setDOMStorageItem\0"
    "DOMStorage.removeDOMStorageItem\0"
    "ApplicationCache.getFramesWithManifests\0"
    "ApplicationCache.enable\0"
    "ApplicationCache.getManifestForFrame\0"
    "ApplicationCache.getApplicationCacheForFrame\0"
    "FileSystem.enable\0"
    "FileSystem.disable\0"
    "FileSystem.requestFileSystemRoot\0"
    "FileSystem.requestDirectoryContent\0"
    "FileSystem.requestMetadata\0"
    "FileSystem.requestFileContent\0"
    "FileSystem.deleteEntry\0"
    "DOM.enable\0"
    "DOM.disable\0"
    "DOM.getDocument\0"
    "DOM.requestChildNodes\0"
    "DOM.querySelector\0"
    "DOM.querySelectorAll\0"
    "DOM.setNodeName\0"
    "DOM.setNodeValue\0"
    "DOM.removeNode\0"
    "DOM.setAttributeValue\0"
    "DOM.setAttributesAsText\0"
    "DOM.removeAttribute\0"
    "DOM.getEventListenersForNode\0"
    "DOM.getOuterHTML\0"
    "DOM.setOuterHTML\0"
    "DOM.performSearch\0"
    "DOM.getSearchResults\0"
    "DOM.discardSearchResults\0"
    "DOM.requestNode\0"
    "DOM.setInspectModeEnabled\0"
    "DOM.highlightRect\0"
    "DOM.highlightQuad\0"
    "DOM.highlightNode\0"
    "DOM.hideHighlight\0"
    "DOM.highlightFrame\0"
    "DOM.pushNodeByPathToFrontend\0"
    "DOM.pushNodesByBackendIdsToFrontend\0"
    "DOM.resolveNode\0"
    "DOM.getAttributes\0"
    "DOM.moveTo\0"
    "DOM.undo\0"
    "DOM.redo\0"
    "DOM.markUndoableState\0"
    "DOM.focus\0"
    "DOM.setFileInputFiles\0"
    "DOM.getBoxModel\0"
    "DOM.getNodeForLocation\0"
    "DOM.getRelayoutBoundary\0"
    "CSS.enable\0"
    "CSS.disable\0"
    "CSS.getMatchedStylesForNode\0"
    "CSS.getInlineStylesForNode\0"
    "CSS.getComputedStyleForNode\0"
    "CSS.getPlatformFontsForNode\0"
    "CSS.getStyleSheetText\0"
    "CSS.setStyleSheetText\0"
    "CSS.setPropertyText\0"
    "CSS.setRuleSelector\0"
    "CSS.createStyleSheet\0"
    "CSS.addRule\0"
    "CSS.forcePseudoState\0"
    "CSS.getMediaQueries\0"
    "Timeline.enable\0"
    "Timeline.disable\0"
    "Timeline.start\0"
    "Timeline.stop\0"
    "Debugger.enable\0"
    "Debugger.disable\0"
    "Debugger.setBreakpointsActive\0"
    "Debugger.setSkipAllPauses\0"
    "Debugger.setBreakpointByUrl\0"
    "Debugger.setBreakpoint\0"
    "Debugger.removeBreakpoint\0"
    "Debugger.continueToLocation\0"
    "Debugger.stepOver\0"
    "Debugger.stepInto\0"
    "Debugger.stepOut\0"
    "Debugger.pause\0"
    "Debugger.resume\0"
    "Debugger.searchInContent\0"
    "Debugger.canSetScriptSource\0"
    "Debugger.setScriptSource\0"
    "Debugger.restartFrame\0"
    "Debugger.getScriptSource\0"
    "Debugger.getFunctionDetails\0"
    "Debugger.setPauseOnExceptions\0"
    "Debugger.evaluateOnCallFrame\0"
    "Debugger.compileScript\0"
    "Debugger.runScript\0"
    "Debugger.setOverlayMessage\0"
    "Debugger.setVariableValue\0"
    "Debugger.getStepInPositions\0"
    "Debugger.getBacktrace\0"
    "Debugger.skipStackFrames\0"
    "Debugger.setAsyncCallStackDepth\0"
    "DOMDebugger.setDOMBreakpoint\0"
    "DOMDebugger.removeDOMBreakpoint\0"
    "DOMDebugger.setEventListenerBreakpoint\0"
    "DOMDebugger.removeEventListenerBreakpoint\0"
    "DOMDebugger.setInstrumentationBreakpoint\0"
    "DOMDebugger.removeInstrumentationBreakpoint\0"
    "DOMDebugger.setXHRBreakpoint\0"
    "DOMDebugger.removeXHRBreakpoint\0"
    "Profiler.enable\0"
    "Profiler.disable\0"
    "Profiler.setSamplingInterval\0"
    "Profiler.start\0"
    "Profiler.stop\0"
    "HeapProfiler.enable\0"
    "HeapProfiler.disable\0"
    "HeapProfiler.startTrackingHeapObjects\0"
    "HeapProfiler.stopTrackingHeapObjects\0"
    "HeapProfiler.takeHeapSnapshot\0"
    "HeapProfiler.collectGarbage\0"
    "HeapProfiler.getObjectByHeapObjectId\0"
    "HeapProfiler.getHeapObjectId\0"
    "Worker.enable\0"
    "Worker.disable\0"
    "Worker.sendMessageToWorker\0"
    "Worker.canInspectWorkers\0"
    "Worker.connectToWorker\0"
    "Worker.disconnectFromWorker\0"
    "Worker.setAutoconnectToWorkers\0"
    "Canvas.enable\0"
    "Canvas.disable\0"
    "Canvas.dropTraceLog\0"
    "Canvas.hasUninstrumentedCanvases\0"
    "Canvas.captureFrame\0"
    "Canvas.startCapturing\0"
    "Canvas.stopCapturing\0"
    "Canvas.getTraceLog\0"
    "Canvas.replayTraceLog\0"
    "Canvas.getResourceState\0"
    "Canvas.evaluateTraceLogCallArgument\0"
    "Input.dispatchKeyEvent\0"
    "Input.dispatchMouseEvent\0"
    "Input.dispatchTouchEvent\0"
    "LayerTree.enable\0"
    "LayerTree.disable\0"
    "LayerTree.compositingReasons\0"
    "LayerTree.makeSnapshot\0"
    "LayerTree.loadSnapshot\0"
    "LayerTree.releaseSnapshot\0"
    "LayerTree.profileSnapshot\0"
    "LayerTree.replaySnapshot\0"
    "LayerTree.snapshotCommandLog\0"
    "Geolocation.setGeolocationOverride\0"
    "Geolocation.clearGeolocationOverride\0"
    "DeviceOrientation.setDeviceOrientationOverride\0"
    "DeviceOrientation.clearDeviceOrientationOverride\0"
    "Tracing.start\0"
};

const size_t InspectorBackendDispatcher::commandNamesIndex[] = {
    0,
    17,
    35,
    51,
    73,
    85,
    98,
    129,
    163,
    175,
    189,
    205,
    223,
    244,
    268,
    290,
    314,
    344,
    376,
    399,
    424,
    447,
    481,
    515,
    545,
    577,
    605,
    635,
    669,
    705,
    725,
    755,
    777,
    810,
    827,
    850,
    872,
    894,
    921,
    933,
    948,
    964,
    986,
    1001,
    1017,
    1039,
    1071,
    1096,
    1127,
    1142,
    1158,
    1187,
    1215,
    1239,
    1257,
    1286,
    1317,
    1342,
    1374,
    1390,
    1407,
    1438,
    1458,
    1475,
    1493,
    1524,
    1550,
    1572,
    1599,
    1617,
    1636,
    1666,
    1695,
    1727,
    1767,
    1791,
    1828,
    1873,
    1891,
    1910,
    1943,
    1978,
    2005,
    2035,
    2058,
    2069,
    2081,
    2097,
    2119,
    2137,
    2158,
    2174,
    2191,
    2206,
    2228,
    2252,
    2272,
    2301,
    2318,
    2335,
    2353,
    2374,
    2399,
    2415,
    2441,
    2459,
    2477,
    2495,
    2513,
    2532,
    2561,
    2597,
    2613,
    2631,
    2642,
    2651,
    2660,
    2682,
    2692,
    2714,
    2730,
    2753,
    2777,
    2788,
    2800,
    2828,
    2855,
    2883,
    2911,
    2933,
    2955,
    2975,
    2995,
    3016,
    3028,
    3049,
    3069,
    3085,
    3102,
    3117,
    3131,
    3147,
    3164,
    3194,
    3220,
    3248,
    3271,
    3297,
    3325,
    3343,
    3361,
    3378,
    3393,
    3409,
    3434,
    3462,
    3487,
    3509,
    3534,
    3562,
    3592,
    3621,
    3644,
    3663,
    3690,
    3716,
    3744,
    3766,
    3791,
    3823,
    3852,
    3884,
    3923,
    3965,
    4006,
    4050,
    4079,
    4111,
    4127,
    4144,
    4173,
    4188,
    4202,
    4222,
    4243,
    4281,
    4318,
    4348,
    4376,
    4413,
    4442,
    4456,
    4471,
    4498,
    4523,
    4546,
    4574,
    4605,
    4619,
    4634,
    4654,
    4687,
    4707,
    4729,
    4750,
    4769,
    4791,
    4815,
    4851,
    4874,
    4899,
    4924,
    4941,
    4959,
    4988,
    5011,
    5034,
    5060,
    5086,
    5111,
    5140,
    5175,
    5212,
    5259,
    5308,
};

const char* InspectorBackendDispatcher::commandName(MethodNames index) {
    COMPILE_ASSERT(static_cast<int>(kMethodNamesEnumSize) == WTF_ARRAY_LENGTH(commandNamesIndex), command_name_array_problem);
    return commandNames + commandNamesIndex[index];
}

class InspectorBackendDispatcherImpl : public InspectorBackendDispatcher {
public:
    InspectorBackendDispatcherImpl(InspectorFrontendChannel* inspectorFrontendChannel)
        : m_inspectorFrontendChannel(inspectorFrontendChannel)
        , m_inspectorAgent(0)
        , m_memoryAgent(0)
        , m_pageAgent(0)
        , m_runtimeAgent(0)
        , m_consoleAgent(0)
        , m_networkAgent(0)
        , m_databaseAgent(0)
        , m_indexedDBAgent(0)
        , m_domStorageAgent(0)
        , m_applicationCacheAgent(0)
        , m_fileSystemAgent(0)
        , m_domAgent(0)
        , m_cssAgent(0)
        , m_timelineAgent(0)
        , m_debuggerAgent(0)
        , m_domDebuggerAgent(0)
        , m_profilerAgent(0)
        , m_heapProfilerAgent(0)
        , m_workerAgent(0)
        , m_canvasAgent(0)
        , m_inputAgent(0)
        , m_layerTreeAgent(0)
        , m_geolocationAgent(0)
        , m_deviceOrientationAgent(0)
        , m_tracingAgent(0)
        , m_powerAgent(0)
    { }

    virtual void clearFrontend() { m_inspectorFrontendChannel = 0; }
    virtual void dispatch(const String& message);
    virtual void reportProtocolError(const long* const callId, CommonErrorCode, const String& errorMessage, PassRefPtr<JSONValue> data) const;
    using InspectorBackendDispatcher::reportProtocolError;

    void sendResponse(long callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result);
    bool isActive() { return m_inspectorFrontendChannel; }

    virtual void registerAgent(InspectorCommandHandler* inspectorAgent) { ASSERT(!m_inspectorAgent); m_inspectorAgent = inspectorAgent; }
    virtual void registerAgent(MemoryCommandHandler* memoryAgent) { ASSERT(!m_memoryAgent); m_memoryAgent = memoryAgent; }
    virtual void registerAgent(PageCommandHandler* pageAgent) { ASSERT(!m_pageAgent); m_pageAgent = pageAgent; }
    virtual void registerAgent(RuntimeCommandHandler* runtimeAgent) { ASSERT(!m_runtimeAgent); m_runtimeAgent = runtimeAgent; }
    virtual void registerAgent(ConsoleCommandHandler* consoleAgent) { ASSERT(!m_consoleAgent); m_consoleAgent = consoleAgent; }
    virtual void registerAgent(NetworkCommandHandler* networkAgent) { ASSERT(!m_networkAgent); m_networkAgent = networkAgent; }
    virtual void registerAgent(DatabaseCommandHandler* databaseAgent) { ASSERT(!m_databaseAgent); m_databaseAgent = databaseAgent; }
    virtual void registerAgent(IndexedDBCommandHandler* indexedDBAgent) { ASSERT(!m_indexedDBAgent); m_indexedDBAgent = indexedDBAgent; }
    virtual void registerAgent(DOMStorageCommandHandler* domStorageAgent) { ASSERT(!m_domStorageAgent); m_domStorageAgent = domStorageAgent; }
    virtual void registerAgent(ApplicationCacheCommandHandler* applicationCacheAgent) { ASSERT(!m_applicationCacheAgent); m_applicationCacheAgent = applicationCacheAgent; }
    virtual void registerAgent(FileSystemCommandHandler* fileSystemAgent) { ASSERT(!m_fileSystemAgent); m_fileSystemAgent = fileSystemAgent; }
    virtual void registerAgent(DOMCommandHandler* domAgent) { ASSERT(!m_domAgent); m_domAgent = domAgent; }
    virtual void registerAgent(CSSCommandHandler* cssAgent) { ASSERT(!m_cssAgent); m_cssAgent = cssAgent; }
    virtual void registerAgent(TimelineCommandHandler* timelineAgent) { ASSERT(!m_timelineAgent); m_timelineAgent = timelineAgent; }
    virtual void registerAgent(DebuggerCommandHandler* debuggerAgent) { ASSERT(!m_debuggerAgent); m_debuggerAgent = debuggerAgent; }
    virtual void registerAgent(DOMDebuggerCommandHandler* domDebuggerAgent) { ASSERT(!m_domDebuggerAgent); m_domDebuggerAgent = domDebuggerAgent; }
    virtual void registerAgent(ProfilerCommandHandler* profilerAgent) { ASSERT(!m_profilerAgent); m_profilerAgent = profilerAgent; }
    virtual void registerAgent(HeapProfilerCommandHandler* heapProfilerAgent) { ASSERT(!m_heapProfilerAgent); m_heapProfilerAgent = heapProfilerAgent; }
    virtual void registerAgent(WorkerCommandHandler* workerAgent) { ASSERT(!m_workerAgent); m_workerAgent = workerAgent; }
    virtual void registerAgent(CanvasCommandHandler* canvasAgent) { ASSERT(!m_canvasAgent); m_canvasAgent = canvasAgent; }
    virtual void registerAgent(InputCommandHandler* inputAgent) { ASSERT(!m_inputAgent); m_inputAgent = inputAgent; }
    virtual void registerAgent(LayerTreeCommandHandler* layerTreeAgent) { ASSERT(!m_layerTreeAgent); m_layerTreeAgent = layerTreeAgent; }
    virtual void registerAgent(GeolocationCommandHandler* geolocationAgent) { ASSERT(!m_geolocationAgent); m_geolocationAgent = geolocationAgent; }
    virtual void registerAgent(DeviceOrientationCommandHandler* deviceOrientationAgent) { ASSERT(!m_deviceOrientationAgent); m_deviceOrientationAgent = deviceOrientationAgent; }
    virtual void registerAgent(TracingCommandHandler* tracingAgent) { ASSERT(!m_tracingAgent); m_tracingAgent = tracingAgent; }
    virtual void registerAgent(PowerCommandHandler* powerAgent) { ASSERT(!m_powerAgent); m_powerAgent = powerAgent; }
private:
    void Inspector_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Inspector_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Inspector_reset(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Memory_getDOMCounters(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_addScriptToEvaluateOnLoad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_removeScriptToEvaluateOnLoad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_reload(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_navigate(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getCookies(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_deleteCookie(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceTree(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_searchInResource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDocumentContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDeviceMetricsOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_clearDeviceMetricsOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowPaintRects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowDebugBorders(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowFPSCounter(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setContinuousPaintingEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowScrollBottleneckRects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getScriptExecutionStatus(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setScriptExecutionDisabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_clearGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_clearDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_hasTouchInputs(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setTouchEmulationEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setEmulatedMedia(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setShowViewportSizeOnResize(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_evaluate(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_callFunctionOn(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_getProperties(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObject(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObjectGroup(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_run(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_isRunRequired(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_clearMessages(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_setMonitoringXHREnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_addInspectedNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_addInspectedHeapObject(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setUserAgentOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setExtraHTTPHeaders(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_getResponseBody(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_replayXHR(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCache(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCookies(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setCacheDisabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_loadResourceForFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_getDatabaseTableNames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_executeSQL(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabaseNames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabase(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestData(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_clearObjectStore(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_getDOMStorageItems(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_setDOMStorageItem(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_removeDOMStorageItem(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getFramesWithManifests(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getManifestForFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getApplicationCacheForFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileSystemRoot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestDirectoryContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestMetadata(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_deleteEntry(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getDocument(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestChildNodes(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelector(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelectorAll(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeName(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributeValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributesAsText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeAttribute(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getEventListenersForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getOuterHTML(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setOuterHTML(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_performSearch(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getSearchResults(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_discardSearchResults(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setInspectModeEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightRect(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightQuad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_hideHighlight(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodeByPathToFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodesByBackendIdsToFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_resolveNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getAttributes(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_moveTo(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_undo(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_redo(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_markUndoableState(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_focus(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setFileInputFiles(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getBoxModel(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getNodeForLocation(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getRelayoutBoundary(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMatchedStylesForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getInlineStylesForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getComputedStyleForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getPlatformFontsForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getStyleSheetText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setStyleSheetText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setPropertyText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setRuleSelector(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_createStyleSheet(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_addRule(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_forcePseudoState(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMediaQueries(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_start(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Timeline_stop(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointsActive(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setSkipAllPauses(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointByUrl(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_removeBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_continueToLocation(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOver(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepInto(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOut(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_pause(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_resume(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_searchInContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_canSetScriptSource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setScriptSource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_restartFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getScriptSource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getFunctionDetails(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setPauseOnExceptions(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_evaluateOnCallFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_compileScript(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_runScript(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setOverlayMessage(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setVariableValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getStepInPositions(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getBacktrace(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_skipStackFrames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setAsyncCallStackDepth(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setDOMBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeDOMBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setEventListenerBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeEventListenerBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setInstrumentationBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeInstrumentationBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setXHRBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeXHRBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_setSamplingInterval(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_start(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_stop(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_startTrackingHeapObjects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_stopTrackingHeapObjects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_takeHeapSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_collectGarbage(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getObjectByHeapObjectId(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getHeapObjectId(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_sendMessageToWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_canInspectWorkers(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_connectToWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disconnectFromWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_setAutoconnectToWorkers(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_dropTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_hasUninstrumentedCanvases(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_captureFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_startCapturing(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_stopCapturing(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_getTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_replayTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_getResourceState(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Canvas_evaluateTraceLogCallArgument(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Input_dispatchKeyEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Input_dispatchMouseEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Input_dispatchTouchEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_enable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_disable(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_compositingReasons(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_makeSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_loadSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_releaseSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_profileSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_replaySnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_snapshotCommandLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Geolocation_setGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Geolocation_clearGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_setDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_clearDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Tracing_start(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);

    InspectorFrontendChannel* m_inspectorFrontendChannel;
    InspectorCommandHandler* m_inspectorAgent;
    MemoryCommandHandler* m_memoryAgent;
    PageCommandHandler* m_pageAgent;
    RuntimeCommandHandler* m_runtimeAgent;
    ConsoleCommandHandler* m_consoleAgent;
    NetworkCommandHandler* m_networkAgent;
    DatabaseCommandHandler* m_databaseAgent;
    IndexedDBCommandHandler* m_indexedDBAgent;
    DOMStorageCommandHandler* m_domStorageAgent;
    ApplicationCacheCommandHandler* m_applicationCacheAgent;
    FileSystemCommandHandler* m_fileSystemAgent;
    DOMCommandHandler* m_domAgent;
    CSSCommandHandler* m_cssAgent;
    TimelineCommandHandler* m_timelineAgent;
    DebuggerCommandHandler* m_debuggerAgent;
    DOMDebuggerCommandHandler* m_domDebuggerAgent;
    ProfilerCommandHandler* m_profilerAgent;
    HeapProfilerCommandHandler* m_heapProfilerAgent;
    WorkerCommandHandler* m_workerAgent;
    CanvasCommandHandler* m_canvasAgent;
    InputCommandHandler* m_inputAgent;
    LayerTreeCommandHandler* m_layerTreeAgent;
    GeolocationCommandHandler* m_geolocationAgent;
    DeviceOrientationCommandHandler* m_deviceOrientationAgent;
    TracingCommandHandler* m_tracingAgent;
    PowerCommandHandler* m_powerAgent;

    template<typename R, typename V, typename V0>
    static R getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name);

    static int getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static double getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static String getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static bool getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONObject> getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONArray> getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);

    void sendResponse(long callId, ErrorString invocationError, PassRefPtr<JSONObject> result)
    {
        sendResponse(callId, invocationError, RefPtr<JSONValue>(), result);
    }
    void sendResponse(long callId, ErrorString invocationError)
    {
        sendResponse(callId, invocationError, RefPtr<JSONValue>(), JSONObject::create());
    }
    static const char InvalidParamsFormatString[];
};

const char InspectorBackendDispatcherImpl::InvalidParamsFormatString[] = "Some arguments of method '%s' can't be processed";

void InspectorBackendDispatcherImpl::Inspector_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Inspector_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Inspector_reset(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_resetCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->reset(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Memory_getDOMCounters(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_memoryAgent)
        protocolErrors->pushString("Memory handler is not available.");

    int out_documents;
    int out_nodes;
    int out_jsEventListeners;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kMemory_getDOMCountersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_memoryAgent->getDOMCounters(&error, &out_documents, &out_nodes, &out_jsEventListeners);
    if (!error.length()) {
        result->setNumber("documents", out_documents);
        result->setNumber("nodes", out_nodes);
        result->setNumber("jsEventListeners", out_jsEventListeners);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);

    TypeBuilder::Page::ScriptIdentifier out_identifier;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_addScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->addScriptToEvaluateOnLoad(&error, in_scriptSource, &out_identifier);
    if (!error.length()) {
        result->setString("identifier", out_identifier);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_identifier = getString(paramsContainerPtr, "identifier", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_removeScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->removeScriptToEvaluateOnLoad(&error, in_identifier);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_reload(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool ignoreCache_valueFound = false;
    bool in_ignoreCache = getBoolean(paramsContainerPtr, "ignoreCache", &ignoreCache_valueFound, protocolErrors);
    bool scriptToEvaluateOnLoad_valueFound = false;
    String in_scriptToEvaluateOnLoad = getString(paramsContainerPtr, "scriptToEvaluateOnLoad", &scriptToEvaluateOnLoad_valueFound, protocolErrors);
    bool scriptPreprocessor_valueFound = false;
    String in_scriptPreprocessor = getString(paramsContainerPtr, "scriptPreprocessor", &scriptPreprocessor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_reloadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->reload(&error, ignoreCache_valueFound ? &in_ignoreCache : 0, scriptToEvaluateOnLoad_valueFound ? &in_scriptToEvaluateOnLoad : 0, scriptPreprocessor_valueFound ? &in_scriptPreprocessor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_navigate(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_navigateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->navigate(&error, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_getCookies(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::Cookie> > out_cookies;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getCookiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getCookies(&error, out_cookies);
    if (!error.length()) {
        result->setValue("cookies", out_cookies);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_deleteCookie(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cookieName = getString(paramsContainerPtr, "cookieName", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_deleteCookieCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->deleteCookie(&error, in_cookieName, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_getResourceTree(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Page::FrameResourceTree> out_frameTree;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceTreeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getResourceTree(&error, out_frameTree);
    if (!error.length()) {
        result->setValue("frameTree", out_frameTree);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_getResourceContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    String out_content;
    bool out_base64Encoded;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getResourceContent(&error, in_frameId, in_url, &out_content, &out_base64Encoded);
    if (!error.length()) {
        result->setString("content", out_content);
        result->setBoolean("base64Encoded", out_base64Encoded);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_searchInResource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::SearchMatch> > out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_searchInResourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->searchInResource(&error, in_frameId, in_url, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_setDocumentContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_html = getString(paramsContainerPtr, "html", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDocumentContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setDocumentContent(&error, in_frameId, in_html);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setDeviceMetricsOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrors);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrors);
    double in_deviceScaleFactor = getDouble(paramsContainerPtr, "deviceScaleFactor", 0, protocolErrors);
    bool in_emulateViewport = getBoolean(paramsContainerPtr, "emulateViewport", 0, protocolErrors);
    bool in_fitWindow = getBoolean(paramsContainerPtr, "fitWindow", 0, protocolErrors);
    bool textAutosizing_valueFound = false;
    bool in_textAutosizing = getBoolean(paramsContainerPtr, "textAutosizing", &textAutosizing_valueFound, protocolErrors);
    bool fontScaleFactor_valueFound = false;
    double in_fontScaleFactor = getDouble(paramsContainerPtr, "fontScaleFactor", &fontScaleFactor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDeviceMetricsOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setDeviceMetricsOverride(&error, in_width, in_height, in_deviceScaleFactor, in_emulateViewport, in_fitWindow, textAutosizing_valueFound ? &in_textAutosizing : 0, fontScaleFactor_valueFound ? &in_fontScaleFactor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_clearDeviceMetricsOverride(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_clearDeviceMetricsOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->clearDeviceMetricsOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowPaintRects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_result = getBoolean(paramsContainerPtr, "result", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowPaintRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowPaintRects(&error, in_result);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowDebugBorders(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowDebugBordersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowDebugBorders(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowFPSCounter(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowFPSCounterCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowFPSCounter(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setContinuousPaintingEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setContinuousPaintingEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setContinuousPaintingEnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowScrollBottleneckRects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowScrollBottleneckRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowScrollBottleneckRects(&error, in_show);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_getScriptExecutionStatus(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    PageCommandHandler::Result::Enum out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getScriptExecutionStatusCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getScriptExecutionStatus(&error, &out_result);
    if (!error.length()) {
        result->setString("result", TypeBuilder::getEnumConstantValue(out_result));
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_setScriptExecutionDisabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setScriptExecutionDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setScriptExecutionDisabled(&error, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_geolocationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool latitude_valueFound = false;
    double in_latitude = getDouble(paramsContainerPtr, "latitude", &latitude_valueFound, protocolErrors);
    bool longitude_valueFound = false;
    double in_longitude = getDouble(paramsContainerPtr, "longitude", &longitude_valueFound, protocolErrors);
    bool accuracy_valueFound = false;
    double in_accuracy = getDouble(paramsContainerPtr, "accuracy", &accuracy_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setGeolocationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_geolocationAgent->setGeolocationOverride(&error, latitude_valueFound ? &in_latitude : 0, longitude_valueFound ? &in_longitude : 0, accuracy_valueFound ? &in_accuracy : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_clearGeolocationOverride(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_geolocationAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_clearGeolocationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_geolocationAgent->clearGeolocationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_hasTouchInputs(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_hasTouchInputsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->hasTouchInputs(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setTouchEmulationEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setTouchEmulationEnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setEmulatedMedia(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_media = getString(paramsContainerPtr, "media", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setEmulatedMediaCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setEmulatedMedia(&error, in_media);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Page_setShowViewportSizeOnResize(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);
    bool showGrid_valueFound = false;
    bool in_showGrid = getBoolean(paramsContainerPtr, "showGrid", &showGrid_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setShowViewportSizeOnResizeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setShowViewportSizeOnResize(&error, in_show, showGrid_valueFound ? &in_showGrid : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_evaluate(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool contextId_valueFound = false;
    int in_contextId = getInt(paramsContainerPtr, "contextId", &contextId_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_evaluateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->evaluate(&error, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, contextId_valueFound ? &in_contextId : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_callFunctionOn(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    String in_functionDeclaration = getString(paramsContainerPtr, "functionDeclaration", 0, protocolErrors);
    bool arguments_valueFound = false;
    RefPtr<JSONArray> in_arguments = getArray(paramsContainerPtr, "arguments", &arguments_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_callFunctionOnCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->callFunctionOn(&error, in_objectId, in_functionDeclaration, arguments_valueFound ? &in_arguments : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_getProperties(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool ownProperties_valueFound = false;
    bool in_ownProperties = getBoolean(paramsContainerPtr, "ownProperties", &ownProperties_valueFound, protocolErrors);
    bool accessorPropertiesOnly_valueFound = false;
    bool in_accessorPropertiesOnly = getBoolean(paramsContainerPtr, "accessorPropertiesOnly", &accessorPropertiesOnly_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::PropertyDescriptor> > out_result;
    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::InternalPropertyDescriptor> > out_internalProperties;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_getPropertiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->getProperties(&error, in_objectId, ownProperties_valueFound ? &in_ownProperties : 0, accessorPropertiesOnly_valueFound ? &in_accessorPropertiesOnly : 0, out_result, out_internalProperties);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_internalProperties)
            result->setValue("internalProperties", out_internalProperties);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObject(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObject(&error, in_objectId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectGroupCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObjectGroup(&error, in_objectGroup);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_run(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_runCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->run(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_isRunRequired(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_isRunRequiredCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->isRunRequired(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Console_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_clearMessages(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_clearMessagesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->clearMessages(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_setMonitoringXHREnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_setMonitoringXHREnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->setMonitoringXHREnabled(&error, in_enabled);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_addInspectedNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_addInspectedNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->addInspectedNode(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Console_addInspectedHeapObject(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_heapObjectId = getInt(paramsContainerPtr, "heapObjectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_addInspectedHeapObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->addInspectedHeapObject(&error, in_heapObjectId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setUserAgentOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_userAgent = getString(paramsContainerPtr, "userAgent", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setUserAgentOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setUserAgentOverride(&error, in_userAgent);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_headers = getObject(paramsContainerPtr, "headers", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setExtraHTTPHeadersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setExtraHTTPHeaders(&error, in_headers);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_getResponseBody(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);

    String out_body;
    bool out_base64Encoded;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_getResponseBodyCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->getResponseBody(&error, in_requestId, &out_body, &out_base64Encoded);
    if (!error.length()) {
        result->setString("body", out_body);
        result->setBoolean("base64Encoded", out_base64Encoded);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_replayXHR(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_replayXHRCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->replayXHR(&error, in_requestId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCache(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCacheCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCache(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCookies(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCookiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCookies(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_setCacheDisabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_cacheDisabled = getBoolean(paramsContainerPtr, "cacheDisabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setCacheDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setCacheDisabled(&error, in_cacheDisabled);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::NetworkCommandHandler::LoadResourceForFrontendCallback::LoadResourceForFrontendCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::NetworkCommandHandler::LoadResourceForFrontendCallback::sendSuccess(double statusCode, PassRefPtr<JSONObject> responseHeaders, const String& content)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("statusCode", statusCode);
    jsonMessage->setValue("responseHeaders", responseHeaders);
    jsonMessage->setString("content", content);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Network_loadResourceForFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    bool requestHeaders_valueFound = false;
    RefPtr<JSONObject> in_requestHeaders = getObject(paramsContainerPtr, "requestHeaders", &requestHeaders_valueFound, protocolErrors);
    RefPtr<NetworkCommandHandler::LoadResourceForFrontendCallback> callback = adoptRef(new NetworkCommandHandler::LoadResourceForFrontendCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_loadResourceForFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->loadResourceForFrontend(&error, in_frameId, in_url, requestHeaders_valueFound ? &in_requestHeaders : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Database_getDatabaseTableNames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_tableNames;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_getDatabaseTableNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_databaseAgent->getDatabaseTableNames(&error, in_databaseId, out_tableNames);
    if (!error.length()) {
        result->setValue("tableNames", out_tableNames);
    }
    sendResponse(callId, error, result);
}

InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::ExecuteSQLCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > columnNames, PassRefPtr<TypeBuilder::Array<JSONValue> > values, PassRefPtr<TypeBuilder::Database::Error> sqlError)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    if (columnNames)
        jsonMessage->setValue("columnNames", columnNames);
    if (values)
        jsonMessage->setValue("values", values);
    if (sqlError)
        jsonMessage->setValue("sqlError", sqlError);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Database_executeSQL(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    RefPtr<DatabaseCommandHandler::ExecuteSQLCallback> callback = adoptRef(new DatabaseCommandHandler::ExecuteSQLCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_executeSQLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->executeSQL(&error, in_databaseId, in_query, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->disable(&error);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::RequestDatabaseNamesCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > databaseNames)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseNames", databaseNames);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    RefPtr<IndexedDBCommandHandler::RequestDatabaseNamesCallback> callback = adoptRef(new IndexedDBCommandHandler::RequestDatabaseNamesCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabaseNames(&error, in_securityOrigin, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::RequestDatabaseCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::sendSuccess(PassRefPtr<TypeBuilder::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseWithObjectStores", databaseWithObjectStores);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabase(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    RefPtr<IndexedDBCommandHandler::RequestDatabaseCallback> callback = adoptRef(new IndexedDBCommandHandler::RequestDatabaseCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabase(&error, in_securityOrigin, in_databaseName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::RequestDataCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::DataEntry> > objectStoreDataEntries, bool hasMore)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("objectStoreDataEntries", objectStoreDataEntries);
    jsonMessage->setBoolean("hasMore", hasMore);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestData(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    String in_indexName = getString(paramsContainerPtr, "indexName", 0, protocolErrors);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrors);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrors);
    bool keyRange_valueFound = false;
    RefPtr<JSONObject> in_keyRange = getObject(paramsContainerPtr, "keyRange", &keyRange_valueFound, protocolErrors);
    RefPtr<IndexedDBCommandHandler::RequestDataCallback> callback = adoptRef(new IndexedDBCommandHandler::RequestDataCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestData(&error, in_securityOrigin, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, keyRange_valueFound ? &in_keyRange : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::ClearObjectStoreCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    RefPtr<IndexedDBCommandHandler::ClearObjectStoreCallback> callback = adoptRef(new IndexedDBCommandHandler::ClearObjectStoreCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_clearObjectStoreCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->clearObjectStore(&error, in_securityOrigin, in_databaseName, in_objectStoreName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<String> > > out_entries;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_getDOMStorageItemsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domStorageAgent->getDOMStorageItems(&error, in_storageId, out_entries);
    if (!error.length()) {
        result->setValue("entries", out_entries);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_setDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->setDOMStorageItem(&error, in_storageId, in_key, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_removeDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->removeDOMStorageItem(&error, in_storageId, in_key);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::ApplicationCache::FrameWithManifest> > out_frameIds;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getFramesWithManifestsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getFramesWithManifests(&error, out_frameIds);
    if (!error.length()) {
        result->setValue("frameIds", out_frameIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_applicationCacheAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    String out_manifestURL;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getManifestForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getManifestForFrame(&error, in_frameId, &out_manifestURL);
    if (!error.length()) {
        result->setString("manifestURL", out_manifestURL);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    RefPtr<TypeBuilder::ApplicationCache::ApplicationCache> out_applicationCache;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getApplicationCacheForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getApplicationCacheForFrame(&error, in_frameId, out_applicationCache);
    if (!error.length()) {
        result->setValue("applicationCache", out_applicationCache);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::FileSystem_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::FileSystem_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->disable(&error);

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::RequestFileSystemRootCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Entry> root)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (root)
        jsonMessage->setValue("root", root);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_origin = getString(paramsContainerPtr, "origin", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtr<FileSystemCommandHandler::RequestFileSystemRootCallback> callback = adoptRef(new FileSystemCommandHandler::RequestFileSystemRootCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileSystemRootCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileSystemRoot(&error, in_origin, in_type, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::RequestDirectoryContentCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::Array<TypeBuilder::FileSystem::Entry> > entries)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (entries)
        jsonMessage->setValue("entries", entries);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtr<FileSystemCommandHandler::RequestDirectoryContentCallback> callback = adoptRef(new FileSystemCommandHandler::RequestDirectoryContentCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestDirectoryContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestDirectoryContent(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::RequestMetadataCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Metadata> metadata)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (metadata)
        jsonMessage->setValue("metadata", metadata);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestMetadata(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtr<FileSystemCommandHandler::RequestMetadataCallback> callback = adoptRef(new FileSystemCommandHandler::RequestMetadataCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestMetadataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestMetadata(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::RequestFileContentCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::sendSuccess(int errorCode, const String* const content, const String* const charset)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (content)
        jsonMessage->setString("content", *content);
    if (charset)
        jsonMessage->setString("charset", *charset);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    bool in_readAsText = getBoolean(paramsContainerPtr, "readAsText", 0, protocolErrors);
    bool start_valueFound = false;
    int in_start = getInt(paramsContainerPtr, "start", &start_valueFound, protocolErrors);
    bool end_valueFound = false;
    int in_end = getInt(paramsContainerPtr, "end", &end_valueFound, protocolErrors);
    bool charset_valueFound = false;
    String in_charset = getString(paramsContainerPtr, "charset", &charset_valueFound, protocolErrors);
    RefPtr<FileSystemCommandHandler::RequestFileContentCallback> callback = adoptRef(new FileSystemCommandHandler::RequestFileContentCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileContent(&error, in_url, in_readAsText, start_valueFound ? &in_start : 0, end_valueFound ? &in_end : 0, charset_valueFound ? &in_charset : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::DeleteEntryCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::sendSuccess(int errorCode)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_deleteEntry(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtr<FileSystemCommandHandler::DeleteEntryCallback> callback = adoptRef(new FileSystemCommandHandler::DeleteEntryCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_deleteEntryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->deleteEntry(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getDocument(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::DOM::Node> out_root;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getDocumentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getDocument(&error, out_root);
    if (!error.length()) {
        result->setValue("root", out_root);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_requestChildNodes(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool depth_valueFound = false;
    int in_depth = getInt(paramsContainerPtr, "depth", &depth_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestChildNodesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->requestChildNodes(&error, in_nodeId, depth_valueFound ? &in_depth : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_querySelector(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelector(&error, in_nodeId, in_selector, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_querySelectorAll(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorAllCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelectorAll(&error, in_nodeId, in_selector, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeName(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeNameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->setNodeName(&error, in_nodeId, in_name, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setNodeValue(&error, in_nodeId, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeNode(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributeValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributeValue(&error, in_nodeId, in_name, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributesAsText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);
    bool name_valueFound = false;
    String in_name = getString(paramsContainerPtr, "name", &name_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributesAsTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributesAsText(&error, in_nodeId, in_text, name_valueFound ? &in_name : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeAttribute(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeAttributeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeAttribute(&error, in_nodeId, in_name);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getEventListenersForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::DOM::EventListener> > out_listeners;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getEventListenersForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getEventListenersForNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : 0, out_listeners);
    if (!error.length()) {
        result->setValue("listeners", out_listeners);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getOuterHTML(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    String out_outerHTML;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getOuterHTML(&error, in_nodeId, &out_outerHTML);
    if (!error.length()) {
        result->setString("outerHTML", out_outerHTML);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setOuterHTML(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_outerHTML = getString(paramsContainerPtr, "outerHTML", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setOuterHTML(&error, in_nodeId, in_outerHTML);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_performSearch(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);

    String out_searchId;
    int out_resultCount;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_performSearchCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->performSearch(&error, in_query, &out_searchId, &out_resultCount);
    if (!error.length()) {
        result->setString("searchId", out_searchId);
        result->setNumber("resultCount", out_resultCount);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getSearchResults(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);
    int in_fromIndex = getInt(paramsContainerPtr, "fromIndex", 0, protocolErrors);
    int in_toIndex = getInt(paramsContainerPtr, "toIndex", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getSearchResults(&error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_discardSearchResults(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_discardSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->discardSearchResults(&error, in_searchId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_requestNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->requestNode(&error, in_objectId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool inspectUAShadowDOM_valueFound = false;
    bool in_inspectUAShadowDOM = getBoolean(paramsContainerPtr, "inspectUAShadowDOM", &inspectUAShadowDOM_valueFound, protocolErrors);
    bool highlightConfig_valueFound = false;
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", &highlightConfig_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setInspectModeEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setInspectModeEnabled(&error, in_enabled, inspectUAShadowDOM_valueFound ? &in_inspectUAShadowDOM : 0, highlightConfig_valueFound ? &in_highlightConfig : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightRect(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrors);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightRectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightRect(&error, in_x, in_y, in_width, in_height, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightQuad(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_quad = getArray(paramsContainerPtr, "quad", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightQuadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightQuad(&error, in_quad, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", 0, protocolErrors);
    bool nodeId_valueFound = false;
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", &nodeId_valueFound, protocolErrors);
    bool objectId_valueFound = false;
    String in_objectId = getString(paramsContainerPtr, "objectId", &objectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightNode(&error, in_highlightConfig, nodeId_valueFound ? &in_nodeId : 0, objectId_valueFound ? &in_objectId : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_hideHighlight(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_hideHighlightCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->hideHighlight(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    bool contentColor_valueFound = false;
    RefPtr<JSONObject> in_contentColor = getObject(paramsContainerPtr, "contentColor", &contentColor_valueFound, protocolErrors);
    bool contentOutlineColor_valueFound = false;
    RefPtr<JSONObject> in_contentOutlineColor = getObject(paramsContainerPtr, "contentOutlineColor", &contentOutlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightFrame(&error, in_frameId, contentColor_valueFound ? &in_contentColor : 0, contentOutlineColor_valueFound ? &in_contentOutlineColor : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_path = getString(paramsContainerPtr, "path", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodeByPathToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodeByPathToFrontend(&error, in_path, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_backendNodeIds = getArray(paramsContainerPtr, "backendNodeIds", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodesByBackendIdsToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodesByBackendIdsToFrontend(&error, in_backendNodeIds, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_resolveNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_object;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_resolveNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->resolveNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : 0, out_object);
    if (!error.length()) {
        result->setValue("object", out_object);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getAttributes(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_attributes;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getAttributesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getAttributes(&error, in_nodeId, out_attributes);
    if (!error.length()) {
        result->setValue("attributes", out_attributes);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_moveTo(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrors);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_moveToCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->moveTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_undo(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_undoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->undo(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_redo(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_redoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->redo(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_markUndoableState(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_markUndoableStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->markUndoableState(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_focus(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_focusCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->focus(&error, in_nodeId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setFileInputFiles(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_files = getArray(paramsContainerPtr, "files", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setFileInputFilesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setFileInputFiles(&error, in_nodeId, in_files);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getBoxModel(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::DOM::BoxModel> out_model;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getBoxModelCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getBoxModel(&error, in_nodeId, out_model);
    if (!error.length()) {
        result->setValue("model", out_model);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getNodeForLocation(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getNodeForLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getNodeForLocation(&error, in_x, in_y, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getRelayoutBoundaryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getRelayoutBoundary(&error, in_nodeId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(callId, error, result);
}

InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::EnableCallback(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id) : CallbackBase(backendImpl, id) {}

void InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CSS_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");
    RefPtr<CSSCommandHandler::EnableCallback> callback = adoptRef(new CSSCommandHandler::EnableCallback(this, callId));

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->enable(&error, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool includePseudo_valueFound = false;
    bool in_includePseudo = getBoolean(paramsContainerPtr, "includePseudo", &includePseudo_valueFound, protocolErrors);
    bool includeInherited_valueFound = false;
    bool in_includeInherited = getBoolean(paramsContainerPtr, "includeInherited", &includeInherited_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::RuleMatch> > out_matchedCSSRules;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PseudoIdMatches> > out_pseudoElements;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::InheritedStyleEntry> > out_inherited;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMatchedStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMatchedStylesForNode(&error, in_nodeId, includePseudo_valueFound ? &in_includePseudo : 0, includeInherited_valueFound ? &in_includeInherited : 0, out_matchedCSSRules, out_pseudoElements, out_inherited);
    if (!error.length()) {
        if (out_matchedCSSRules)
            result->setValue("matchedCSSRules", out_matchedCSSRules);
        if (out_pseudoElements)
            result->setValue("pseudoElements", out_pseudoElements);
        if (out_inherited)
            result->setValue("inherited", out_inherited);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getInlineStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getInlineStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle);
    if (!error.length()) {
        if (out_inlineStyle)
            result->setValue("inlineStyle", out_inlineStyle);
        if (out_attributesStyle)
            result->setValue("attributesStyle", out_attributesStyle);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSComputedStyleProperty> > out_computedStyle;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getComputedStyleForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getComputedStyleForNode(&error, in_nodeId, out_computedStyle);
    if (!error.length()) {
        result->setValue("computedStyle", out_computedStyle);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    String out_cssFamilyName;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PlatformFontUsage> > out_fonts;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getPlatformFontsForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getPlatformFontsForNode(&error, in_nodeId, &out_cssFamilyName, out_fonts);
    if (!error.length()) {
        result->setString("cssFamilyName", out_cssFamilyName);
        result->setValue("fonts", out_fonts);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getStyleSheetText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);

    String out_text;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getStyleSheetText(&error, in_styleSheetId, &out_text);
    if (!error.length()) {
        result->setString("text", out_text);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setStyleSheetText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->setStyleSheetText(&error, in_styleSheetId, in_text);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_setPropertyText(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_style;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setPropertyTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setPropertyText(&error, in_styleSheetId, in_range, in_text, out_style);
    if (!error.length()) {
        result->setValue("style", out_style);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setRuleSelector(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setRuleSelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setRuleSelector(&error, in_styleSheetId, in_range, in_selector, out_rule);
    if (!error.length()) {
        result->setValue("rule", out_rule);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_createStyleSheet(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    TypeBuilder::CSS::StyleSheetId out_styleSheetId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_createStyleSheetCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->createStyleSheet(&error, in_frameId, &out_styleSheetId);
    if (!error.length()) {
        result->setString("styleSheetId", out_styleSheetId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_addRule(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_addRuleCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->addRule(&error, in_styleSheetId, in_selector, out_rule);
    if (!error.length()) {
        result->setValue("rule", out_rule);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_forcePseudoState(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_forcedPseudoClasses = getArray(paramsContainerPtr, "forcedPseudoClasses", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_forcePseudoStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->forcePseudoState(&error, in_nodeId, in_forcedPseudoClasses);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMediaQueries(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSMedia> > out_medias;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMediaQueriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMediaQueries(&error, out_medias);
    if (!error.length()) {
        result->setValue("medias", out_medias);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Timeline_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_start(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool maxCallStackDepth_valueFound = false;
    int in_maxCallStackDepth = getInt(paramsContainerPtr, "maxCallStackDepth", &maxCallStackDepth_valueFound, protocolErrors);
    bool bufferEvents_valueFound = false;
    bool in_bufferEvents = getBoolean(paramsContainerPtr, "bufferEvents", &bufferEvents_valueFound, protocolErrors);
    bool liveEvents_valueFound = false;
    String in_liveEvents = getString(paramsContainerPtr, "liveEvents", &liveEvents_valueFound, protocolErrors);
    bool includeCounters_valueFound = false;
    bool in_includeCounters = getBoolean(paramsContainerPtr, "includeCounters", &includeCounters_valueFound, protocolErrors);
    bool includeGPUEvents_valueFound = false;
    bool in_includeGPUEvents = getBoolean(paramsContainerPtr, "includeGPUEvents", &includeGPUEvents_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_timelineAgent->start(&error, maxCallStackDepth_valueFound ? &in_maxCallStackDepth : 0, bufferEvents_valueFound ? &in_bufferEvents : 0, liveEvents_valueFound ? &in_liveEvents : 0, includeCounters_valueFound ? &in_includeCounters : 0, includeGPUEvents_valueFound ? &in_includeGPUEvents : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Timeline_stop(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Timeline::TimelineEvent> > out_events;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTimeline_stopCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_timelineAgent->stop(&error, out_events);
    if (!error.length()) {
        if (out_events)
            result->setValue("events", out_events);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_active = getBoolean(paramsContainerPtr, "active", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointsActiveCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setBreakpointsActive(&error, in_active);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_skipped = getBoolean(paramsContainerPtr, "skipped", 0, protocolErrors);
    bool untilReload_valueFound = false;
    bool in_untilReload = getBoolean(paramsContainerPtr, "untilReload", &untilReload_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setSkipAllPausesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setSkipAllPauses(&error, in_skipped, untilReload_valueFound ? &in_untilReload : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_lineNumber = getInt(paramsContainerPtr, "lineNumber", 0, protocolErrors);
    bool url_valueFound = false;
    String in_url = getString(paramsContainerPtr, "url", &url_valueFound, protocolErrors);
    bool urlRegex_valueFound = false;
    String in_urlRegex = getString(paramsContainerPtr, "urlRegex", &urlRegex_valueFound, protocolErrors);
    bool columnNumber_valueFound = false;
    int in_columnNumber = getInt(paramsContainerPtr, "columnNumber", &columnNumber_valueFound, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);
    bool isAntibreakpoint_valueFound = false;
    bool in_isAntibreakpoint = getBoolean(paramsContainerPtr, "isAntibreakpoint", &isAntibreakpoint_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_locations;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointByUrlCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpointByUrl(&error, in_lineNumber, url_valueFound ? &in_url : 0, urlRegex_valueFound ? &in_urlRegex : 0, columnNumber_valueFound ? &in_columnNumber : 0, condition_valueFound ? &in_condition : 0, isAntibreakpoint_valueFound ? &in_isAntibreakpoint : 0, &out_breakpointId, out_locations);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("locations", out_locations);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Debugger::Location> out_actualLocation;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpoint(&error, in_location, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_actualLocation);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("actualLocation", out_actualLocation);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_removeBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_breakpointId = getString(paramsContainerPtr, "breakpointId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_removeBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->removeBreakpoint(&error, in_breakpointId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_continueToLocation(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool interstatementLocation_valueFound = false;
    bool in_interstatementLocation = getBoolean(paramsContainerPtr, "interstatementLocation", &interstatementLocation_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_continueToLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->continueToLocation(&error, in_location, interstatementLocation_valueFound ? &in_interstatementLocation : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOver(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOverCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOver(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepInto(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepIntoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepInto(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOut(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOutCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOut(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_pause(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_pauseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->pause(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_resume(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_resumeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->resume(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_searchInContent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::SearchMatch> > out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_searchInContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->searchInContent(&error, in_scriptId, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_canSetScriptSource(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_canSetScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->canSetScriptSource(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setScriptSource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");
    RefPtr<TypeBuilder::Debugger::SetScriptSourceError> errorData;

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);
    bool preview_valueFound = false;
    bool in_preview = getBoolean(paramsContainerPtr, "preview", &preview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<JSONObject> out_result;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setScriptSource(&error, errorData, in_scriptId, in_scriptSource, preview_valueFound ? &in_preview : 0, out_callFrames, out_result, out_asyncStackTrace);
    if (!error.length()) {
        if (out_callFrames)
            result->setValue("callFrames", out_callFrames);
        if (out_result)
            result->setValue("result", out_result);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, errorData, result);
}

void InspectorBackendDispatcherImpl::Debugger_restartFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<JSONObject> out_result;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_restartFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->restartFrame(&error, in_callFrameId, out_callFrames, out_result, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        result->setValue("result", out_result);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getScriptSource(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);

    String out_scriptSource;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getScriptSource(&error, in_scriptId, &out_scriptSource);
    if (!error.length()) {
        result->setString("scriptSource", out_scriptSource);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getFunctionDetails(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_functionId = getString(paramsContainerPtr, "functionId", 0, protocolErrors);

    RefPtr<TypeBuilder::Debugger::FunctionDetails> out_details;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getFunctionDetailsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getFunctionDetails(&error, in_functionId, out_details);
    if (!error.length()) {
        result->setValue("details", out_details);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_state = getString(paramsContainerPtr, "state", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setPauseOnExceptionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setPauseOnExceptions(&error, in_state);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_evaluateOnCallFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->evaluateOnCallFrame(&error, in_callFrameId, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_compileScript(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    String in_sourceURL = getString(paramsContainerPtr, "sourceURL", 0, protocolErrors);
    bool executionContextId_valueFound = false;
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", &executionContextId_valueFound, protocolErrors);

    TypeBuilder::OptOutput<TypeBuilder::Debugger::ScriptId> out_scriptId;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_compileScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->compileScript(&error, in_expression, in_sourceURL, executionContextId_valueFound ? &in_executionContextId : 0, &out_scriptId, out_exceptionDetails);
    if (!error.length()) {
        if (out_scriptId.isAssigned())
            result->setString("scriptId", out_scriptId.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_runScript(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    bool executionContextId_valueFound = false;
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", &executionContextId_valueFound, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    RefPtr<TypeBuilder::Debugger::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_runScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->runScript(&error, in_scriptId, executionContextId_valueFound ? &in_executionContextId : 0, objectGroup_valueFound ? &in_objectGroup : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, out_result, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", out_exceptionDetails);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setOverlayMessage(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool message_valueFound = false;
    String in_message = getString(paramsContainerPtr, "message", &message_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setOverlayMessageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setOverlayMessage(&error, message_valueFound ? &in_message : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setVariableValue(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_scopeNumber = getInt(paramsContainerPtr, "scopeNumber", 0, protocolErrors);
    String in_variableName = getString(paramsContainerPtr, "variableName", 0, protocolErrors);
    RefPtr<JSONObject> in_newValue = getObject(paramsContainerPtr, "newValue", 0, protocolErrors);
    bool callFrameId_valueFound = false;
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", &callFrameId_valueFound, protocolErrors);
    bool functionObjectId_valueFound = false;
    String in_functionObjectId = getString(paramsContainerPtr, "functionObjectId", &functionObjectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setVariableValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setVariableValue(&error, in_scopeNumber, in_variableName, in_newValue, callFrameId_valueFound ? &in_callFrameId : 0, functionObjectId_valueFound ? &in_functionObjectId : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_getStepInPositions(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_stepInPositions;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getStepInPositionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getStepInPositions(&error, in_callFrameId, out_stepInPositions);
    if (!error.length()) {
        if (out_stepInPositions)
            result->setValue("stepInPositions", out_stepInPositions);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getBacktrace(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getBacktraceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getBacktrace(&error, out_callFrames, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", out_asyncStackTrace);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_skipStackFrames(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool script_valueFound = false;
    String in_script = getString(paramsContainerPtr, "script", &script_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_skipStackFramesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->skipStackFrames(&error, script_valueFound ? &in_script : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_maxDepth = getInt(paramsContainerPtr, "maxDepth", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setAsyncCallStackDepthCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setAsyncCallStackDepth(&error, in_maxDepth);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setXHRBreakpoint(&error, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeXHRBreakpoint(&error, in_url);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_setSamplingInterval(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_interval = getInt(paramsContainerPtr, "interval", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_setSamplingIntervalCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->setSamplingInterval(&error, in_interval);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_start(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->start(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_stop(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<TypeBuilder::Profiler::CPUProfile> out_profile;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_stopCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_profilerAgent->stop(&error, out_profile);
    if (!error.length()) {
        result->setValue("profile", out_profile);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool trackAllocations_valueFound = false;
    bool in_trackAllocations = getBoolean(paramsContainerPtr, "trackAllocations", &trackAllocations_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_startTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->startTrackingHeapObjects(&error, trackAllocations_valueFound ? &in_trackAllocations : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_stopTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->stopTrackingHeapObjects(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_takeHeapSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->takeHeapSnapshot(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_collectGarbageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->collectGarbage(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getObjectByHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    TypeBuilder::HeapProfiler::HeapSnapshotObjectId out_heapSnapshotObjectId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getHeapObjectId(&error, in_objectId, &out_heapSnapshotObjectId);
    if (!error.length()) {
        result->setString("heapSnapshotObjectId", out_heapSnapshotObjectId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Worker_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_sendMessageToWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrors);
    RefPtr<JSONObject> in_message = getObject(paramsContainerPtr, "message", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_sendMessageToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->sendMessageToWorker(&error, in_workerId, in_message);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_canInspectWorkers(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_canInspectWorkersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_workerAgent->canInspectWorkers(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Worker_connectToWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_connectToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->connectToWorker(&error, in_workerId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disconnectFromWorker(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disconnectFromWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disconnectFromWorker(&error, in_workerId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_setAutoconnectToWorkersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->setAutoconnectToWorkers(&error, in_value);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Canvas_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_canvasAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Canvas_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_canvasAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Canvas_dropTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_dropTraceLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_canvasAgent->dropTraceLog(&error, in_traceLogId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Canvas_hasUninstrumentedCanvases(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_hasUninstrumentedCanvasesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->hasUninstrumentedCanvases(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_captureFrame(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool frameId_valueFound = false;
    String in_frameId = getString(paramsContainerPtr, "frameId", &frameId_valueFound, protocolErrors);

    TypeBuilder::Canvas::TraceLogId out_traceLogId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_captureFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->captureFrame(&error, frameId_valueFound ? &in_frameId : 0, &out_traceLogId);
    if (!error.length()) {
        result->setString("traceLogId", out_traceLogId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_startCapturing(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool frameId_valueFound = false;
    String in_frameId = getString(paramsContainerPtr, "frameId", &frameId_valueFound, protocolErrors);

    TypeBuilder::Canvas::TraceLogId out_traceLogId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_startCapturingCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->startCapturing(&error, frameId_valueFound ? &in_frameId : 0, &out_traceLogId);
    if (!error.length()) {
        result->setString("traceLogId", out_traceLogId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_stopCapturing(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_stopCapturingCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_canvasAgent->stopCapturing(&error, in_traceLogId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Canvas_getTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);
    bool startOffset_valueFound = false;
    int in_startOffset = getInt(paramsContainerPtr, "startOffset", &startOffset_valueFound, protocolErrors);
    bool maxLength_valueFound = false;
    int in_maxLength = getInt(paramsContainerPtr, "maxLength", &maxLength_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Canvas::TraceLog> out_traceLog;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_getTraceLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->getTraceLog(&error, in_traceLogId, startOffset_valueFound ? &in_startOffset : 0, maxLength_valueFound ? &in_maxLength : 0, out_traceLog);
    if (!error.length()) {
        result->setValue("traceLog", out_traceLog);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_replayTraceLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);
    int in_stepNo = getInt(paramsContainerPtr, "stepNo", 0, protocolErrors);

    RefPtr<TypeBuilder::Canvas::ResourceState> out_resourceState;
    double out_replayTime;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_replayTraceLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->replayTraceLog(&error, in_traceLogId, in_stepNo, out_resourceState, &out_replayTime);
    if (!error.length()) {
        result->setValue("resourceState", out_resourceState);
        result->setNumber("replayTime", out_replayTime);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_getResourceState(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);
    String in_resourceId = getString(paramsContainerPtr, "resourceId", 0, protocolErrors);

    RefPtr<TypeBuilder::Canvas::ResourceState> out_resourceState;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_getResourceStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->getResourceState(&error, in_traceLogId, in_resourceId, out_resourceState);
    if (!error.length()) {
        result->setValue("resourceState", out_resourceState);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Canvas_evaluateTraceLogCallArgument(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_canvasAgent)
        protocolErrors->pushString("Canvas handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_traceLogId = getString(paramsContainerPtr, "traceLogId", 0, protocolErrors);
    int in_callIndex = getInt(paramsContainerPtr, "callIndex", 0, protocolErrors);
    int in_argumentIndex = getInt(paramsContainerPtr, "argumentIndex", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    RefPtr<TypeBuilder::Canvas::ResourceState> out_resourceState;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCanvas_evaluateTraceLogCallArgumentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_canvasAgent->evaluateTraceLogCallArgument(&error, in_traceLogId, in_callIndex, in_argumentIndex, objectGroup_valueFound ? &in_objectGroup : 0, out_result, out_resourceState);
    if (!error.length()) {
        if (out_result)
            result->setValue("result", out_result);
        if (out_resourceState)
            result->setValue("resourceState", out_resourceState);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Input_dispatchKeyEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_inputAgent)
        protocolErrors->pushString("Input handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    bool modifiers_valueFound = false;
    int in_modifiers = getInt(paramsContainerPtr, "modifiers", &modifiers_valueFound, protocolErrors);
    bool timestamp_valueFound = false;
    double in_timestamp = getDouble(paramsContainerPtr, "timestamp", &timestamp_valueFound, protocolErrors);
    bool text_valueFound = false;
    String in_text = getString(paramsContainerPtr, "text", &text_valueFound, protocolErrors);
    bool unmodifiedText_valueFound = false;
    String in_unmodifiedText = getString(paramsContainerPtr, "unmodifiedText", &unmodifiedText_valueFound, protocolErrors);
    bool keyIdentifier_valueFound = false;
    String in_keyIdentifier = getString(paramsContainerPtr, "keyIdentifier", &keyIdentifier_valueFound, protocolErrors);
    bool windowsVirtualKeyCode_valueFound = false;
    int in_windowsVirtualKeyCode = getInt(paramsContainerPtr, "windowsVirtualKeyCode", &windowsVirtualKeyCode_valueFound, protocolErrors);
    bool nativeVirtualKeyCode_valueFound = false;
    int in_nativeVirtualKeyCode = getInt(paramsContainerPtr, "nativeVirtualKeyCode", &nativeVirtualKeyCode_valueFound, protocolErrors);
    bool autoRepeat_valueFound = false;
    bool in_autoRepeat = getBoolean(paramsContainerPtr, "autoRepeat", &autoRepeat_valueFound, protocolErrors);
    bool isKeypad_valueFound = false;
    bool in_isKeypad = getBoolean(paramsContainerPtr, "isKeypad", &isKeypad_valueFound, protocolErrors);
    bool isSystemKey_valueFound = false;
    bool in_isSystemKey = getBoolean(paramsContainerPtr, "isSystemKey", &isSystemKey_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInput_dispatchKeyEventCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inputAgent->dispatchKeyEvent(&error, in_type, modifiers_valueFound ? &in_modifiers : 0, timestamp_valueFound ? &in_timestamp : 0, text_valueFound ? &in_text : 0, unmodifiedText_valueFound ? &in_unmodifiedText : 0, keyIdentifier_valueFound ? &in_keyIdentifier : 0, windowsVirtualKeyCode_valueFound ? &in_windowsVirtualKeyCode : 0, nativeVirtualKeyCode_valueFound ? &in_nativeVirtualKeyCode : 0, autoRepeat_valueFound ? &in_autoRepeat : 0, isKeypad_valueFound ? &in_isKeypad : 0, isSystemKey_valueFound ? &in_isSystemKey : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Input_dispatchMouseEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_inputAgent)
        protocolErrors->pushString("Input handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);
    bool modifiers_valueFound = false;
    int in_modifiers = getInt(paramsContainerPtr, "modifiers", &modifiers_valueFound, protocolErrors);
    bool timestamp_valueFound = false;
    double in_timestamp = getDouble(paramsContainerPtr, "timestamp", &timestamp_valueFound, protocolErrors);
    bool button_valueFound = false;
    String in_button = getString(paramsContainerPtr, "button", &button_valueFound, protocolErrors);
    bool clickCount_valueFound = false;
    int in_clickCount = getInt(paramsContainerPtr, "clickCount", &clickCount_valueFound, protocolErrors);
    bool deviceSpace_valueFound = false;
    bool in_deviceSpace = getBoolean(paramsContainerPtr, "deviceSpace", &deviceSpace_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInput_dispatchMouseEventCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inputAgent->dispatchMouseEvent(&error, in_type, in_x, in_y, modifiers_valueFound ? &in_modifiers : 0, timestamp_valueFound ? &in_timestamp : 0, button_valueFound ? &in_button : 0, clickCount_valueFound ? &in_clickCount : 0, deviceSpace_valueFound ? &in_deviceSpace : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Input_dispatchTouchEvent(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_inputAgent)
        protocolErrors->pushString("Input handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtr<JSONArray> in_touchPoints = getArray(paramsContainerPtr, "touchPoints", 0, protocolErrors);
    bool modifiers_valueFound = false;
    int in_modifiers = getInt(paramsContainerPtr, "modifiers", &modifiers_valueFound, protocolErrors);
    bool timestamp_valueFound = false;
    double in_timestamp = getDouble(paramsContainerPtr, "timestamp", &timestamp_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInput_dispatchTouchEventCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inputAgent->dispatchTouchEvent(&error, in_type, in_touchPoints, modifiers_valueFound ? &in_modifiers : 0, timestamp_valueFound ? &in_timestamp : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_enable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->enable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_disable(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->disable(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_compositingReasons(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_compositingReasons;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_compositingReasonsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->compositingReasons(&error, in_layerId, out_compositingReasons);
    if (!error.length()) {
        result->setValue("compositingReasons", out_compositingReasons);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_makeSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_makeSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->makeSnapshot(&error, in_layerId, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_loadSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_data = getString(paramsContainerPtr, "data", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_loadSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->loadSnapshot(&error, in_data, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_releaseSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->releaseSnapshot(&error, in_snapshotId);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_profileSnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool minRepeatCount_valueFound = false;
    int in_minRepeatCount = getInt(paramsContainerPtr, "minRepeatCount", &minRepeatCount_valueFound, protocolErrors);
    bool minDuration_valueFound = false;
    double in_minDuration = getDouble(paramsContainerPtr, "minDuration", &minDuration_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<double> > > out_timings;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_profileSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->profileSnapshot(&error, in_snapshotId, minRepeatCount_valueFound ? &in_minRepeatCount : 0, minDuration_valueFound ? &in_minDuration : 0, out_timings);
    if (!error.length()) {
        result->setValue("timings", out_timings);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_replaySnapshot(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool fromStep_valueFound = false;
    int in_fromStep = getInt(paramsContainerPtr, "fromStep", &fromStep_valueFound, protocolErrors);
    bool toStep_valueFound = false;
    int in_toStep = getInt(paramsContainerPtr, "toStep", &toStep_valueFound, protocolErrors);

    String out_dataURL;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_replaySnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->replaySnapshot(&error, in_snapshotId, fromStep_valueFound ? &in_fromStep : 0, toStep_valueFound ? &in_toStep : 0, &out_dataURL);
    if (!error.length()) {
        result->setString("dataURL", out_dataURL);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<JSONObject> > out_commandLog;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_snapshotCommandLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->snapshotCommandLog(&error, in_snapshotId, out_commandLog);
    if (!error.length()) {
        result->setValue("commandLog", out_commandLog);
    }
    sendResponse(callId, error, result);
}

void InspectorBackendDispatcherImpl::Geolocation_setGeolocationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_geolocationAgent)
        protocolErrors->pushString("Geolocation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool latitude_valueFound = false;
    double in_latitude = getDouble(paramsContainerPtr, "latitude", &latitude_valueFound, protocolErrors);
    bool longitude_valueFound = false;
    double in_longitude = getDouble(paramsContainerPtr, "longitude", &longitude_valueFound, protocolErrors);
    bool accuracy_valueFound = false;
    double in_accuracy = getDouble(paramsContainerPtr, "accuracy", &accuracy_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kGeolocation_setGeolocationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_geolocationAgent->setGeolocationOverride(&error, latitude_valueFound ? &in_latitude : 0, longitude_valueFound ? &in_longitude : 0, accuracy_valueFound ? &in_accuracy : 0);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Geolocation_clearGeolocationOverride(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_geolocationAgent)
        protocolErrors->pushString("Geolocation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kGeolocation_clearGeolocationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_geolocationAgent->clearGeolocationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride(long callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(callId, error);
}

void InspectorBackendDispatcherImpl::Tracing_start(long callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_tracingAgent)
        protocolErrors->pushString("Tracing handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_categories = getString(paramsContainerPtr, "categories", 0, protocolErrors);
    String in_options = getString(paramsContainerPtr, "options", 0, protocolErrors);
    bool bufferUsageReportingInterval_valueFound = false;
    double in_bufferUsageReportingInterval = getDouble(paramsContainerPtr, "bufferUsageReportingInterval", &bufferUsageReportingInterval_valueFound, protocolErrors);

    String out_sessionId;

    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTracing_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_tracingAgent->start(&error, in_categories, in_options, bufferUsageReportingInterval_valueFound ? &in_bufferUsageReportingInterval : 0, &out_sessionId);
    if (!error.length()) {
        result->setString("sessionId", out_sessionId);
    }
    sendResponse(callId, error, result);
}


PassRefPtr<InspectorBackendDispatcher> InspectorBackendDispatcher::create(InspectorFrontendChannel* inspectorFrontendChannel)
{
    return adoptRef(new InspectorBackendDispatcherImpl(inspectorFrontendChannel));
}


void InspectorBackendDispatcherImpl::dispatch(const String& message)
{
    RefPtr<InspectorBackendDispatcher> protect = this;
    typedef void (InspectorBackendDispatcherImpl::*CallHandler)(long callId, JSONObject* messageObject, JSONArray* protocolErrors);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, );
    long callId = 0;

    if (dispatchMap.isEmpty()) {
        static const CallHandler handlers[] = {
            &InspectorBackendDispatcherImpl::Inspector_enable,
            &InspectorBackendDispatcherImpl::Inspector_disable,
            &InspectorBackendDispatcherImpl::Inspector_reset,
            &InspectorBackendDispatcherImpl::Memory_getDOMCounters,
            &InspectorBackendDispatcherImpl::Page_enable,
            &InspectorBackendDispatcherImpl::Page_disable,
            &InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_reload,
            &InspectorBackendDispatcherImpl::Page_navigate,
            &InspectorBackendDispatcherImpl::Page_getCookies,
            &InspectorBackendDispatcherImpl::Page_deleteCookie,
            &InspectorBackendDispatcherImpl::Page_getResourceTree,
            &InspectorBackendDispatcherImpl::Page_getResourceContent,
            &InspectorBackendDispatcherImpl::Page_searchInResource,
            &InspectorBackendDispatcherImpl::Page_setDocumentContent,
            &InspectorBackendDispatcherImpl::Page_setDeviceMetricsOverride,
            &InspectorBackendDispatcherImpl::Page_clearDeviceMetricsOverride,
            &InspectorBackendDispatcherImpl::Page_setShowPaintRects,
            &InspectorBackendDispatcherImpl::Page_setShowDebugBorders,
            &InspectorBackendDispatcherImpl::Page_setShowFPSCounter,
            &InspectorBackendDispatcherImpl::Page_setContinuousPaintingEnabled,
            &InspectorBackendDispatcherImpl::Page_setShowScrollBottleneckRects,
            &InspectorBackendDispatcherImpl::Page_getScriptExecutionStatus,
            &InspectorBackendDispatcherImpl::Page_setScriptExecutionDisabled,
            &InspectorBackendDispatcherImpl::Page_setGeolocationOverride,
            &InspectorBackendDispatcherImpl::Page_clearGeolocationOverride,
            &InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_hasTouchInputs,
            &InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::Page_setEmulatedMedia,
            &InspectorBackendDispatcherImpl::Page_setShowViewportSizeOnResize,
            &InspectorBackendDispatcherImpl::Runtime_evaluate,
            &InspectorBackendDispatcherImpl::Runtime_callFunctionOn,
            &InspectorBackendDispatcherImpl::Runtime_getProperties,
            &InspectorBackendDispatcherImpl::Runtime_releaseObject,
            &InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup,
            &InspectorBackendDispatcherImpl::Runtime_run,
            &InspectorBackendDispatcherImpl::Runtime_enable,
            &InspectorBackendDispatcherImpl::Runtime_disable,
            &InspectorBackendDispatcherImpl::Runtime_isRunRequired,
            &InspectorBackendDispatcherImpl::Console_enable,
            &InspectorBackendDispatcherImpl::Console_disable,
            &InspectorBackendDispatcherImpl::Console_clearMessages,
            &InspectorBackendDispatcherImpl::Console_setMonitoringXHREnabled,
            &InspectorBackendDispatcherImpl::Console_addInspectedNode,
            &InspectorBackendDispatcherImpl::Console_addInspectedHeapObject,
            &InspectorBackendDispatcherImpl::Network_enable,
            &InspectorBackendDispatcherImpl::Network_disable,
            &InspectorBackendDispatcherImpl::Network_setUserAgentOverride,
            &InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders,
            &InspectorBackendDispatcherImpl::Network_getResponseBody,
            &InspectorBackendDispatcherImpl::Network_replayXHR,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCache,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCookies,
            &InspectorBackendDispatcherImpl::Network_setCacheDisabled,
            &InspectorBackendDispatcherImpl::Network_loadResourceForFrontend,
            &InspectorBackendDispatcherImpl::Database_enable,
            &InspectorBackendDispatcherImpl::Database_disable,
            &InspectorBackendDispatcherImpl::Database_getDatabaseTableNames,
            &InspectorBackendDispatcherImpl::Database_executeSQL,
            &InspectorBackendDispatcherImpl::IndexedDB_enable,
            &InspectorBackendDispatcherImpl::IndexedDB_disable,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabase,
            &InspectorBackendDispatcherImpl::IndexedDB_requestData,
            &InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore,
            &InspectorBackendDispatcherImpl::DOMStorage_enable,
            &InspectorBackendDispatcherImpl::DOMStorage_disable,
            &InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems,
            &InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem,
            &InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem,
            &InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests,
            &InspectorBackendDispatcherImpl::ApplicationCache_enable,
            &InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame,
            &InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame,
            &InspectorBackendDispatcherImpl::FileSystem_enable,
            &InspectorBackendDispatcherImpl::FileSystem_disable,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot,
            &InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent,
            &InspectorBackendDispatcherImpl::FileSystem_requestMetadata,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileContent,
            &InspectorBackendDispatcherImpl::FileSystem_deleteEntry,
            &InspectorBackendDispatcherImpl::DOM_enable,
            &InspectorBackendDispatcherImpl::DOM_disable,
            &InspectorBackendDispatcherImpl::DOM_getDocument,
            &InspectorBackendDispatcherImpl::DOM_requestChildNodes,
            &InspectorBackendDispatcherImpl::DOM_querySelector,
            &InspectorBackendDispatcherImpl::DOM_querySelectorAll,
            &InspectorBackendDispatcherImpl::DOM_setNodeName,
            &InspectorBackendDispatcherImpl::DOM_setNodeValue,
            &InspectorBackendDispatcherImpl::DOM_removeNode,
            &InspectorBackendDispatcherImpl::DOM_setAttributeValue,
            &InspectorBackendDispatcherImpl::DOM_setAttributesAsText,
            &InspectorBackendDispatcherImpl::DOM_removeAttribute,
            &InspectorBackendDispatcherImpl::DOM_getEventListenersForNode,
            &InspectorBackendDispatcherImpl::DOM_getOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_setOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_performSearch,
            &InspectorBackendDispatcherImpl::DOM_getSearchResults,
            &InspectorBackendDispatcherImpl::DOM_discardSearchResults,
            &InspectorBackendDispatcherImpl::DOM_requestNode,
            &InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled,
            &InspectorBackendDispatcherImpl::DOM_highlightRect,
            &InspectorBackendDispatcherImpl::DOM_highlightQuad,
            &InspectorBackendDispatcherImpl::DOM_highlightNode,
            &InspectorBackendDispatcherImpl::DOM_hideHighlight,
            &InspectorBackendDispatcherImpl::DOM_highlightFrame,
            &InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend,
            &InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend,
            &InspectorBackendDispatcherImpl::DOM_resolveNode,
            &InspectorBackendDispatcherImpl::DOM_getAttributes,
            &InspectorBackendDispatcherImpl::DOM_moveTo,
            &InspectorBackendDispatcherImpl::DOM_undo,
            &InspectorBackendDispatcherImpl::DOM_redo,
            &InspectorBackendDispatcherImpl::DOM_markUndoableState,
            &InspectorBackendDispatcherImpl::DOM_focus,
            &InspectorBackendDispatcherImpl::DOM_setFileInputFiles,
            &InspectorBackendDispatcherImpl::DOM_getBoxModel,
            &InspectorBackendDispatcherImpl::DOM_getNodeForLocation,
            &InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary,
            &InspectorBackendDispatcherImpl::CSS_enable,
            &InspectorBackendDispatcherImpl::CSS_disable,
            &InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode,
            &InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode,
            &InspectorBackendDispatcherImpl::CSS_getStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setPropertyText,
            &InspectorBackendDispatcherImpl::CSS_setRuleSelector,
            &InspectorBackendDispatcherImpl::CSS_createStyleSheet,
            &InspectorBackendDispatcherImpl::CSS_addRule,
            &InspectorBackendDispatcherImpl::CSS_forcePseudoState,
            &InspectorBackendDispatcherImpl::CSS_getMediaQueries,
            &InspectorBackendDispatcherImpl::Timeline_enable,
            &InspectorBackendDispatcherImpl::Timeline_disable,
            &InspectorBackendDispatcherImpl::Timeline_start,
            &InspectorBackendDispatcherImpl::Timeline_stop,
            &InspectorBackendDispatcherImpl::Debugger_enable,
            &InspectorBackendDispatcherImpl::Debugger_disable,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive,
            &InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_continueToLocation,
            &InspectorBackendDispatcherImpl::Debugger_stepOver,
            &InspectorBackendDispatcherImpl::Debugger_stepInto,
            &InspectorBackendDispatcherImpl::Debugger_stepOut,
            &InspectorBackendDispatcherImpl::Debugger_pause,
            &InspectorBackendDispatcherImpl::Debugger_resume,
            &InspectorBackendDispatcherImpl::Debugger_searchInContent,
            &InspectorBackendDispatcherImpl::Debugger_canSetScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_setScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_restartFrame,
            &InspectorBackendDispatcherImpl::Debugger_getScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_getFunctionDetails,
            &InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions,
            &InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame,
            &InspectorBackendDispatcherImpl::Debugger_compileScript,
            &InspectorBackendDispatcherImpl::Debugger_runScript,
            &InspectorBackendDispatcherImpl::Debugger_setOverlayMessage,
            &InspectorBackendDispatcherImpl::Debugger_setVariableValue,
            &InspectorBackendDispatcherImpl::Debugger_getStepInPositions,
            &InspectorBackendDispatcherImpl::Debugger_getBacktrace,
            &InspectorBackendDispatcherImpl::Debugger_skipStackFrames,
            &InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth,
            &InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint,
            &InspectorBackendDispatcherImpl::Profiler_enable,
            &InspectorBackendDispatcherImpl::Profiler_disable,
            &InspectorBackendDispatcherImpl::Profiler_setSamplingInterval,
            &InspectorBackendDispatcherImpl::Profiler_start,
            &InspectorBackendDispatcherImpl::Profiler_stop,
            &InspectorBackendDispatcherImpl::HeapProfiler_enable,
            &InspectorBackendDispatcherImpl::HeapProfiler_disable,
            &InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot,
            &InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage,
            &InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId,
            &InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId,
            &InspectorBackendDispatcherImpl::Worker_enable,
            &InspectorBackendDispatcherImpl::Worker_disable,
            &InspectorBackendDispatcherImpl::Worker_sendMessageToWorker,
            &InspectorBackendDispatcherImpl::Worker_canInspectWorkers,
            &InspectorBackendDispatcherImpl::Worker_connectToWorker,
            &InspectorBackendDispatcherImpl::Worker_disconnectFromWorker,
            &InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers,
            &InspectorBackendDispatcherImpl::Canvas_enable,
            &InspectorBackendDispatcherImpl::Canvas_disable,
            &InspectorBackendDispatcherImpl::Canvas_dropTraceLog,
            &InspectorBackendDispatcherImpl::Canvas_hasUninstrumentedCanvases,
            &InspectorBackendDispatcherImpl::Canvas_captureFrame,
            &InspectorBackendDispatcherImpl::Canvas_startCapturing,
            &InspectorBackendDispatcherImpl::Canvas_stopCapturing,
            &InspectorBackendDispatcherImpl::Canvas_getTraceLog,
            &InspectorBackendDispatcherImpl::Canvas_replayTraceLog,
            &InspectorBackendDispatcherImpl::Canvas_getResourceState,
            &InspectorBackendDispatcherImpl::Canvas_evaluateTraceLogCallArgument,
            &InspectorBackendDispatcherImpl::Input_dispatchKeyEvent,
            &InspectorBackendDispatcherImpl::Input_dispatchMouseEvent,
            &InspectorBackendDispatcherImpl::Input_dispatchTouchEvent,
            &InspectorBackendDispatcherImpl::LayerTree_enable,
            &InspectorBackendDispatcherImpl::LayerTree_disable,
            &InspectorBackendDispatcherImpl::LayerTree_compositingReasons,
            &InspectorBackendDispatcherImpl::LayerTree_makeSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_loadSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_profileSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_replaySnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog,
            &InspectorBackendDispatcherImpl::Geolocation_setGeolocationOverride,
            &InspectorBackendDispatcherImpl::Geolocation_clearGeolocationOverride,
            &InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Tracing_start,
        };
        for (size_t i = 0; i < kMethodNamesEnumSize; ++i)
            dispatchMap.add(commandName(static_cast<MethodNames>(i)), handlers[i]);
    }

    RefPtr<JSONValue> parsedMessage = parseJSON(message);
    if (!parsedMessage) {
        reportProtocolError(0, ParseError, "Message must be in JSON format");
        return;
    }

    RefPtr<JSONObject> messageObject = parsedMessage->asObject();
    if (!messageObject) {
        reportProtocolError(0, InvalidRequest, "Message must be a JSONified object");
        return;
    }

    RefPtr<JSONValue> callIdValue = messageObject->get("id");
    if (!callIdValue) {
        reportProtocolError(0, InvalidRequest, "'id' property was not found");
        return;
    }

    if (!callIdValue->asNumber(&callId)) {
        reportProtocolError(0, InvalidRequest, "The type of 'id' property must be number");
        return;
    }

    RefPtr<JSONValue> methodValue = messageObject->get("method");
    if (!methodValue) {
        reportProtocolError(&callId, InvalidRequest, "'method' property wasn't found");
        return;
    }

    String method;
    if (!methodValue->asString(&method)) {
        reportProtocolError(&callId, InvalidRequest, "The type of 'method' property must be string");
        return;
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        reportProtocolError(&callId, MethodNotFound, "'" + method + "' wasn't found");
        return;
    }

    RefPtr<JSONArray> protocolErrors = JSONArray::create();
    ((*this).*it->value)(callId, messageObject.get(), protocolErrors.get());
}

void InspectorBackendDispatcherImpl::sendResponse(long callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result)
{
    if (invocationError.length()) {
        reportProtocolError(&callId, ServerError, invocationError, errorData);
        return;
    }

    RefPtr<JSONObject> responseMessage = JSONObject::create();
    responseMessage->setNumber("id", callId);
    responseMessage->setObject("result", result);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendMessageToFrontend(responseMessage.release());
}

void InspectorBackendDispatcher::reportProtocolError(const long* const callId, CommonErrorCode code, const String& errorMessage) const
{
    reportProtocolError(callId, code, errorMessage, PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::reportProtocolError(const long* const callId, CommonErrorCode code, const String& errorMessage, PassRefPtr<JSONValue> data) const
{
    DEFINE_STATIC_LOCAL(Vector<int>,s_commonErrors,);
    if (!s_commonErrors.size()) {
        s_commonErrors.insert(ParseError, -32700);
        s_commonErrors.insert(InvalidRequest, -32600);
        s_commonErrors.insert(MethodNotFound, -32601);
        s_commonErrors.insert(InvalidParams, -32602);
        s_commonErrors.insert(InternalError, -32603);
        s_commonErrors.insert(ServerError, -32000);
    }
    ASSERT(code >=0);
    ASSERT((unsigned)code < s_commonErrors.size());
    ASSERT(s_commonErrors[code]);
    RefPtr<JSONObject> error = JSONObject::create();
    error->setNumber("code", s_commonErrors[code]);
    error->setString("message", errorMessage);
    ASSERT(error);
    if (data)
        error->setValue("data", data);
    RefPtr<JSONObject> message = JSONObject::create();
    message->setObject("error", error);
    if (callId)
        message->setNumber("id", *callId);
    else
        message->setValue("id", JSONValue::null());
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendMessageToFrontend(message.release());
}

template<typename R, typename V, typename V0>
R InspectorBackendDispatcherImpl::getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name)
{
    ASSERT(protocolErrors);

    if (valueFound)
        *valueFound = false;

    V value = initial_value;

    if (!object) {
        if (!valueFound) {
            // Required parameter in missing params container.
            protocolErrors->pushString(String::format("'params' object must contain required parameter '%s' with type '%s'.", name, type_name));
        }
        return value;
    }

    JSONObject::const_iterator end = object->end();
    JSONObject::const_iterator valueIterator = object->find(name);

    if (valueIterator == end) {
        if (!valueFound)
            protocolErrors->pushString(String::format("Parameter '%s' with type '%s' was not found.", name, type_name));
        return value;
    }

    if (!as_method(valueIterator->value.get(), &value))
        protocolErrors->pushString(String::format("Parameter '%s' has wrong type. It must be '%s'.", name, type_name));
    else
        if (valueFound)
            *valueFound = true;
    return value;
}

struct AsMethodBridges {
    static bool asInt(JSONValue* value, int* output) { return value->asNumber(output); }
    static bool asDouble(JSONValue* value, double* output) { return value->asNumber(output); }
    static bool asString(JSONValue* value, String* output) { return value->asString(output); }
    static bool asBoolean(JSONValue* value, bool* output) { return value->asBoolean(output); }
    static bool asObject(JSONValue* value, RefPtr<JSONObject>* output) { return value->asObject(output); }
    static bool asArray(JSONValue* value, RefPtr<JSONArray>* output) { return value->asArray(output); }
};

int InspectorBackendDispatcherImpl::getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<int, int, int>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asInt, "Number");
}

double InspectorBackendDispatcherImpl::getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<double, double, double>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asDouble, "Number");
}

String InspectorBackendDispatcherImpl::getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<String, String, String>(object, name, valueFound, protocolErrors, "", AsMethodBridges::asString, "String");
}

bool InspectorBackendDispatcherImpl::getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<bool, bool, bool>(object, name, valueFound, protocolErrors, false, AsMethodBridges::asBoolean, "Boolean");
}

PassRefPtr<JSONObject> InspectorBackendDispatcherImpl::getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONObject>, RefPtr<JSONObject>, JSONObject*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asObject, "Object");
}

PassRefPtr<JSONArray> InspectorBackendDispatcherImpl::getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONArray>, RefPtr<JSONArray>, JSONArray*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asArray, "Array");
}

bool InspectorBackendDispatcher::getCommandName(const String& message, String* result)
{
    RefPtr<JSONValue> value = parseJSON(message);
    if (!value)
        return false;

    RefPtr<JSONObject> object = value->asObject();
    if (!object)
        return false;

    if (!object->getString("method", result))
        return false;

    return true;
}

InspectorBackendDispatcher::CallbackBase::CallbackBase(PassRefPtr<InspectorBackendDispatcherImpl> backendImpl, int id)
    : m_backendImpl(backendImpl), m_id(id), m_alreadySent(false) {}

InspectorBackendDispatcher::CallbackBase::~CallbackBase() {}

void InspectorBackendDispatcher::CallbackBase::sendFailure(const ErrorString& error)
{
    ASSERT(error.length());
    sendIfActive(nullptr, error, PassRefPtr<JSONValue>());
}

bool InspectorBackendDispatcher::CallbackBase::isActive()
{
    return !m_alreadySent && m_backendImpl->isActive();
}

void InspectorBackendDispatcher::CallbackBase::sendIfActive(PassRefPtr<JSONObject> partialMessage, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData)
{
    if (m_alreadySent)
        return;
    m_backendImpl->sendResponse(m_id, invocationError, errorData, partialMessage);
    m_alreadySent = true;
}

} // namespace WebCore

