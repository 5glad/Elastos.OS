// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8Internals.h"

#include "bindings/core/v8/V8CSSStyleDeclaration.h"
#include "bindings/core/v8/V8ClientRect.h"
#include "bindings/core/v8/V8ClientRectList.h"
#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8GCObservation.h"
#include "bindings/core/v8/V8HTMLMediaElement.h"
#include "bindings/core/v8/V8InternalProfilers.h"
#include "bindings/core/v8/V8InternalRuntimeFlags.h"
#include "bindings/core/v8/V8InternalSettings.h"
#include "bindings/core/v8/V8LayerRectList.h"
#include "bindings/core/v8/V8MallocStatistics.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8PagePopupController.h"
#include "bindings/core/v8/V8Range.h"
#include "bindings/core/v8/V8ShadowRoot.h"
#include "bindings/core/v8/V8TypeConversions.h"
#include "bindings/core/v8/V8WebKitPoint.h"
#include "bindings/v8/ExceptionState.h"
#include "bindings/v8/ScriptPromise.h"
#include "bindings/v8/ScriptState.h"
#include "bindings/v8/ScriptValue.h"
#include "bindings/v8/SerializedScriptValue.h"
#include "bindings/v8/V8DOMConfiguration.h"
#include "bindings/v8/V8HiddenValue.h"
#include "bindings/v8/V8ObjectConstructor.h"
#include "bindings/v8/custom/V8ArrayBufferCustom.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/StaticNodeList.h"
#include "core/html/LabelsNodeList.h"
#include "modules/geolocation/testing/InternalsGeolocation.h"
#include "modules/navigatorcontentutils/testing/InternalsNavigatorContentUtils.h"
#include "modules/speech/testing/InternalsSpeechSynthesis.h"
#include "modules/vibration/testing/InternalsVibration.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace WebCore {

static void initializeScriptWrappableForInterface(Internals* object)
{
    if (ScriptWrappable::wrapperCanBeStoredInObject(object))
        ScriptWrappable::fromObject(object)->setTypeInfo(&V8Internals::wrapperTypeInfo);
    else
        ASSERT_NOT_REACHED();
}

} // namespace WebCore

void webCoreInitializeScriptWrappableForInterface(WebCore::Internals* object)
{
    WebCore::initializeScriptWrappableForInterface(object);
}

namespace WebCore {
const WrapperTypeInfo V8Internals::wrapperTypeInfo = { gin::kEmbedderBlink, V8Internals::domTemplate, V8Internals::derefObject, 0, 0, 0, V8Internals::installPerContextEnabledMethods, 0, WrapperTypeObjectPrototype, WillBeGarbageCollectedObject };

namespace InternalsV8Internal {

template <typename T> void V8_USE(T) { }

static void pagePopupControllerAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toNative(holder);
    RefPtrWillBeRawPtr<PagePopupController> result(impl->pagePopupController());
    if (result && DOMDataStore::setReturnValueFromWrapper<V8PagePopupController>(info.GetReturnValue(), result.get()))
        return;
    v8::Handle<v8::Value> wrapper = toV8(result.get(), holder, info.GetIsolate());
    if (!wrapper.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "pagePopupController"), wrapper);
        v8SetReturnValue(info, wrapper);
    }
}

static void pagePopupControllerAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    InternalsV8Internal::pagePopupControllerAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void settingsAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toNative(holder);
    RefPtrWillBeRawPtr<InternalSettings> result(impl->settings());
    if (result && DOMDataStore::setReturnValueFromWrapper<V8InternalSettings>(info.GetReturnValue(), result.get()))
        return;
    v8::Handle<v8::Value> wrapper = toV8(result.get(), holder, info.GetIsolate());
    if (!wrapper.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "settings"), wrapper);
        v8SetReturnValue(info, wrapper);
    }
}

static void settingsAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    InternalsV8Internal::settingsAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void profilersAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toNative(holder);
    RefPtrWillBeRawPtr<InternalProfilers> result(impl->profilers());
    if (result && DOMDataStore::setReturnValueFromWrapper<V8InternalProfilers>(info.GetReturnValue(), result.get()))
        return;
    v8::Handle<v8::Value> wrapper = toV8(result.get(), holder, info.GetIsolate());
    if (!wrapper.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "profilers"), wrapper);
        v8SetReturnValue(info, wrapper);
    }
}

static void profilersAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    InternalsV8Internal::profilersAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void runtimeFlagsAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toNative(holder);
    RefPtrWillBeRawPtr<InternalRuntimeFlags> result(impl->runtimeFlags());
    if (result && DOMDataStore::setReturnValueFromWrapper<V8InternalRuntimeFlags>(info.GetReturnValue(), result.get()))
        return;
    v8::Handle<v8::Value> wrapper = toV8(result.get(), holder, info.GetIsolate());
    if (!wrapper.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "runtimeFlags"), wrapper);
        v8SetReturnValue(info, wrapper);
    }
}

static void runtimeFlagsAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    InternalsV8Internal::runtimeFlagsAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void workerThreadCountAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toNative(holder);
    v8SetReturnValueUnsigned(info, impl->workerThreadCount());
}

static void workerThreadCountAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    InternalsV8Internal::workerThreadCountAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void addressMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("address", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueString(info, impl->address(node), info.GetIsolate());
}

static void addressMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::addressMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void observeGCMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("observeGC", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    ScriptValue observed;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(observed, ScriptValue(ScriptState::current(info.GetIsolate()), info[0]));
    }
    v8SetReturnValue(info, impl->observeGC(observed));
}

static void observeGCMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::observeGCMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void elementRenderTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementRenderTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->elementRenderTreeAsText(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void elementRenderTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::elementRenderTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isPreloadedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isPreloaded", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> url;
    {
        TOSTRING_VOID_INTERNAL(url, info[0]);
    }
    v8SetReturnValueBool(info, impl->isPreloaded(url));
}

static void isPreloadedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isPreloadedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isLoadingFromMemoryCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isLoadingFromMemoryCache", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> url;
    {
        TOSTRING_VOID_INTERNAL(url, info[0]);
    }
    v8SetReturnValueBool(info, impl->isLoadingFromMemoryCache(url));
}

static void isLoadingFromMemoryCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isLoadingFromMemoryCacheMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void crashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    impl->crash();
}

static void crashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::crashMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setStyleResolverStatsEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setStyleResolverStatsEnabled", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool enabled;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(enabled, info[0]->BooleanValue());
    }
    impl->setStyleResolverStatsEnabled(enabled);
}

static void setStyleResolverStatsEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setStyleResolverStatsEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void styleResolverStatsReportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "styleResolverStatsReport", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    String result = impl->styleResolverStatsReport(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void styleResolverStatsReportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::styleResolverStatsReportMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void styleResolverStatsTotalsReportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "styleResolverStatsTotalsReport", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    String result = impl->styleResolverStatsTotalsReport(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void styleResolverStatsTotalsReportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::styleResolverStatsTotalsReportMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isSharingStyleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isSharingStyle", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element1;
    Element* element2;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element1, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element2, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    bool result = impl->isSharingStyle(element1, element2, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isSharingStyleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isSharingStyleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void computedStyleIncludingVisitedInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "computedStyleIncludingVisitedInfo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<CSSStyleDeclaration> result = impl->computedStyleIncludingVisitedInfo(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void computedStyleIncludingVisitedInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::computedStyleIncludingVisitedInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "shadowRoot", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ShadowRoot> result = impl->shadowRoot(host, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void shadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::shadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void youngestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "youngestShadowRoot", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ShadowRoot> result = impl->youngestShadowRoot(host, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void youngestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::youngestShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void oldestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "oldestShadowRoot", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ShadowRoot> result = impl->oldestShadowRoot(host, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void oldestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::oldestShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void youngerShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "youngerShadowRoot", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* root;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(root, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ShadowRoot> result = impl->youngerShadowRoot(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void youngerShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::youngerShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowRootTypeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "shadowRootType", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* root;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(root, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->shadowRootType(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void shadowRootTypeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::shadowRootTypeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasShadowInsertionPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasShadowInsertionPoint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* root;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(root, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->hasShadowInsertionPoint(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasShadowInsertionPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasShadowInsertionPointMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasContentElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasContentElement", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* root;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(root, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->hasContentElement(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasContentElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasContentElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void countElementShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "countElementShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* Root;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(Root, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->countElementShadow(Root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void countElementShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::countElementShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowPseudoIdMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "shadowPseudoId", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->shadowPseudoId(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void shadowPseudoIdMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::shadowPseudoIdMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setShadowPseudoIdMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setShadowPseudoId", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    V8StringResource<> id;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(id, info[1]);
    }
    impl->setShadowPseudoId(element, id, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setShadowPseudoIdMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setShadowPseudoIdMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isValidContentSelectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isValidContentSelect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* contentElement;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(contentElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->isValidContentSelect(contentElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isValidContentSelectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isValidContentSelectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void treeScopeRootNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "treeScopeRootNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->treeScopeRootNode(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void treeScopeRootNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::treeScopeRootNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void parentTreeScopeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "parentTreeScope", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->parentTreeScope(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void parentTreeScopeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::parentTreeScopeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasSelectorForIdInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForIdInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    V8StringResource<> id;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(id, info[1]);
    }
    bool result = impl->hasSelectorForIdInShadow(host, id, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForIdInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForIdInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasSelectorForClassInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForClassInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    V8StringResource<> className;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(className, info[1]);
    }
    bool result = impl->hasSelectorForClassInShadow(host, className, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForClassInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForClassInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasSelectorForAttributeInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForAttributeInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    V8StringResource<> attributeName;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(attributeName, info[1]);
    }
    bool result = impl->hasSelectorForAttributeInShadow(host, attributeName, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForAttributeInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForAttributeInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasSelectorForPseudoClassInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForPseudoClassInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* host;
    V8StringResource<> pseudoClass;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(host, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(pseudoClass, info[1]);
    }
    bool result = impl->hasSelectorForPseudoClassInShadow(host, pseudoClass, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForPseudoClassInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForPseudoClassInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void compareTreeScopePositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "compareTreeScopePosition", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* treeScope1;
    Node* treeScope2;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(treeScope1, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(treeScope2, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    unsigned result = impl->compareTreeScopePosition(treeScope1, treeScope2, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void compareTreeScopePositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::compareTreeScopePositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void updateStyleAndReturnAffectedElementCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "updateStyleAndReturnAffectedElementCount", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    unsigned result = impl->updateStyleAndReturnAffectedElementCount(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void updateStyleAndReturnAffectedElementCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void needsLayoutCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "needsLayoutCount", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    unsigned result = impl->needsLayoutCount(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void needsLayoutCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::needsLayoutCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfActiveAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValueUnsigned(info, impl->numberOfActiveAnimations());
}

static void numberOfActiveAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfActiveAnimationsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pauseAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pauseAnimations", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    double pauseTime;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(pauseTime, static_cast<double>(info[0]->NumberValue()));
    }
    impl->pauseAnimations(pauseTime, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void pauseAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::pauseAnimationsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nextSiblingByWalkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nextSiblingByWalker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->nextSiblingByWalker(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nextSiblingByWalkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::nextSiblingByWalkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void firstChildByWalkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "firstChildByWalker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->firstChildByWalker(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void firstChildByWalkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::firstChildByWalkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lastChildByWalkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastChildByWalker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->lastChildByWalker(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void lastChildByWalkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::lastChildByWalkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nextNodeByWalkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nextNodeByWalker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->nextNodeByWalker(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nextNodeByWalkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::nextNodeByWalkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void previousNodeByWalkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "previousNodeByWalker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->previousNodeByWalker(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void previousNodeByWalkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::previousNodeByWalkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void visiblePlaceholderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("visiblePlaceholder", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueString(info, impl->visiblePlaceholder(element), info.GetIsolate());
}

static void visiblePlaceholderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::visiblePlaceholderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void selectColorInColorChooserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("selectColorInColorChooser", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    V8StringResource<> colorValue;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(colorValue, info[1]);
    }
    impl->selectColorInColorChooser(element, colorValue);
}

static void selectColorInColorChooserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::selectColorInColorChooserMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasAutofocusRequestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueBool(info, impl->hasAutofocusRequest());
            return;
        }
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->hasAutofocusRequest(document));
}

static void hasAutofocusRequestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasAutofocusRequestMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void formControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "formControlStateOfHistoryItem", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    Vector<String> result = impl->formControlStateOfHistoryItem(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, v8Array(result, info.Holder(), info.GetIsolate()));
}

static void formControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::formControlStateOfHistoryItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setFormControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setFormControlStateOfHistoryItem", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Vector<String> values;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(values, toNativeArray<String>(info[0], 1, info.GetIsolate()));
    }
    impl->setFormControlStateOfHistoryItem(values, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setFormControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setFormControlStateOfHistoryItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setEnableMockPagePopupMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setEnableMockPagePopup", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool enabled;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(enabled, info[0]->BooleanValue());
    }
    impl->setEnableMockPagePopup(enabled, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setEnableMockPagePopupMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setEnableMockPagePopupMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void unscaledViewportRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "unscaledViewportRect", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    RefPtrWillBeRawPtr<ClientRect> result = impl->unscaledViewportRect(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void unscaledViewportRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::unscaledViewportRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void absoluteCaretBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "absoluteCaretBounds", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    RefPtrWillBeRawPtr<ClientRect> result = impl->absoluteCaretBounds(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void absoluteCaretBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::absoluteCaretBoundsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void boundingBoxMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "boundingBox", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ClientRect> result = impl->boundingBox(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void boundingBoxMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::boundingBoxMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void markerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerCountForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(markerType, info[1]);
    }
    unsigned result = impl->markerCountForNode(node, markerType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void markerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::markerCountForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void activeMarkerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "activeMarkerCountForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->activeMarkerCountForNode(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void activeMarkerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::activeMarkerCountForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void markerRangeForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerRangeForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(markerType, info[1]);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[2], exceptionState), exceptionState);
    }
    RefPtrWillBeRawPtr<Range> result = impl->markerRangeForNode(node, markerType, index, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void markerRangeForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::markerRangeForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void markerDescriptionForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerDescriptionForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(markerType, info[1]);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[2], exceptionState), exceptionState);
    }
    String result = impl->markerDescriptionForNode(node, markerType, index, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void markerDescriptionForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::markerDescriptionForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void addTextMatchMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("addTextMatchMarker", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Range* range;
    bool isActive;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(range, V8Range::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(isActive, info[1]->BooleanValue());
    }
    impl->addTextMatchMarker(range, isActive);
}

static void addTextMatchMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::addTextMatchMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setMarkersActiveMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMarkersActive", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    unsigned startOffset;
    unsigned endOffset;
    bool active;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(startOffset, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(endOffset, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(active, info[3]->BooleanValue());
    }
    impl->setMarkersActive(node, startOffset, endOffset, active, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setMarkersActiveMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setMarkersActiveMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setMarkedTextMatchesAreHighlightedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMarkedTextMatchesAreHighlighted", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    bool highlight;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(highlight, info[1]->BooleanValue());
    }
    impl->setMarkedTextMatchesAreHighlighted(document, highlight, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setMarkedTextMatchesAreHighlightedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setScrollViewPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setScrollViewPosition", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    int x;
    int y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
    }
    impl->setScrollViewPosition(document, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setScrollViewPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setScrollViewPositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void viewportAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "viewportAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    float devicePixelRatio;
    int availableWidth;
    int availableHeight;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(devicePixelRatio, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(availableWidth, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(availableHeight, toInt32(info[3], exceptionState), exceptionState);
    }
    String result = impl->viewportAsText(document, devicePixelRatio, availableWidth, availableHeight, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void viewportAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::viewportAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void wasLastChangeUserEditMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "wasLastChangeUserEdit", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* textField;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(textField, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->wasLastChangeUserEdit(textField, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void wasLastChangeUserEditMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::wasLastChangeUserEditMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void elementShouldAutoCompleteMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementShouldAutoComplete", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* inputElement;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(inputElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->elementShouldAutoComplete(inputElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void elementShouldAutoCompleteMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::elementShouldAutoCompleteMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void suggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "suggestedValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* inputElement;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(inputElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->suggestedValue(inputElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void suggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::suggestedValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setSuggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setSuggestedValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* inputElement;
    V8StringResource<> value;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(inputElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(value, info[1]);
    }
    impl->setSuggestedValue(inputElement, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setSuggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setSuggestedValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setEditingValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setEditingValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* inputElement;
    V8StringResource<> value;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(inputElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(value, info[1]);
    }
    impl->setEditingValue(inputElement, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setEditingValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setEditingValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setAutofilledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAutofilled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* inputElement;
    bool enabled;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(inputElement, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(enabled, info[1]->BooleanValue());
    }
    impl->setAutofilled(inputElement, enabled, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setAutofilledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setAutofilledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scrollElementToRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollElementToRect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    int x;
    int y;
    int w;
    int h;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(w, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(h, toInt32(info[4], exceptionState), exceptionState);
    }
    impl->scrollElementToRect(element, x, y, w, h, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void scrollElementToRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::scrollElementToRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void rangeFromLocationAndLengthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "rangeFromLocationAndLength", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* scope;
    int rangeLocation;
    int rangeLength;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(scope, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(rangeLocation, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(rangeLength, toInt32(info[2], exceptionState), exceptionState);
    }
    RefPtrWillBeRawPtr<Range> result = impl->rangeFromLocationAndLength(scope, rangeLocation, rangeLength, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void rangeFromLocationAndLengthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::rangeFromLocationAndLengthMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void locationFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "locationFromRange", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* scope;
    Range* range;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(scope, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(range, V8Range::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    unsigned result = impl->locationFromRange(scope, range, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void locationFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::locationFromRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lengthFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lengthFromRange", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* scope;
    Range* range;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(scope, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(range, V8Range::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    unsigned result = impl->lengthFromRange(scope, range, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void lengthFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::lengthFromRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void rangeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "rangeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Range* range;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(range, V8Range::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->rangeAsText(range, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void rangeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::rangeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchPositionAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchPositionAdjustedToBestClickableNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[4]));
    }
    RefPtrWillBeRawPtr<DOMPoint> result = impl->touchPositionAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchPositionAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchNodeAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchNodeAdjustedToBestClickableNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[4]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->touchNodeAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchNodeAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchPositionAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchPositionAdjustedToBestContextMenuNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[4]));
    }
    RefPtrWillBeRawPtr<DOMPoint> result = impl->touchPositionAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchPositionAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchNodeAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchNodeAdjustedToBestContextMenuNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[4]));
    }
    RefPtrWillBeRawPtr<Node> result = impl->touchNodeAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchNodeAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bestZoomableAreaForTouchPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bestZoomableAreaForTouchPoint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[4]));
    }
    RefPtrWillBeRawPtr<ClientRect> result = impl->bestZoomableAreaForTouchPoint(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void bestZoomableAreaForTouchPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::bestZoomableAreaForTouchPointMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lastSpellCheckRequestSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastSpellCheckRequestSequence", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    int result = impl->lastSpellCheckRequestSequence(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueInt(info, result);
}

static void lastSpellCheckRequestSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::lastSpellCheckRequestSequenceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lastSpellCheckProcessedSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastSpellCheckProcessedSequence", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    int result = impl->lastSpellCheckProcessedSequence(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueInt(info, result);
}

static void lastSpellCheckProcessedSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::lastSpellCheckProcessedSequenceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void userPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValue(info, v8Array(impl->userPreferredLanguages(), info.Holder(), info.GetIsolate()));
}

static void userPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::userPreferredLanguagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setUserPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setUserPreferredLanguages", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Vector<String> languages;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(languages, toNativeArray<String>(info[0], 1, info.GetIsolate()));
    }
    impl->setUserPreferredLanguages(languages);
}

static void setUserPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setUserPreferredLanguagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void activeDOMObjectCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "activeDOMObjectCount", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->activeDOMObjectCount(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void activeDOMObjectCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::activeDOMObjectCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void wheelEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "wheelEventHandlerCount", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->wheelEventHandlerCount(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void wheelEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::wheelEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scrollEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollEventHandlerCount", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->scrollEventHandlerCount(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void scrollEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::scrollEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchEventHandlerCount", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->touchEventHandlerCount(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void touchEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void touchEventTargetLayerRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchEventTargetLayerRects", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<LayerRectList> result = impl->touchEventTargetLayerRects(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchEventTargetLayerRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::touchEventTargetLayerRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nodesFromRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nodesFromRect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 10)) {
        throwMinimumArityTypeError(exceptionState, 10, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    int x;
    int y;
    unsigned topPadding;
    unsigned rightPadding;
    unsigned bottomPadding;
    unsigned leftPadding;
    bool ignoreClipping;
    bool allowShadowContent;
    bool allowChildFrameContent;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(topPadding, toUInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(rightPadding, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(bottomPadding, toUInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(leftPadding, toUInt32(info[6], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(ignoreClipping, info[7]->BooleanValue());
        TONATIVE_VOID_INTERNAL(allowShadowContent, info[8]->BooleanValue());
        TONATIVE_VOID_INTERNAL(allowChildFrameContent, info[9]->BooleanValue());
    }
    RefPtrWillBeRawPtr<NodeList> result = impl->nodesFromRect(document, x, y, topPadding, rightPadding, bottomPadding, leftPadding, ignoreClipping, allowShadowContent, allowChildFrameContent, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nodesFromRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::nodesFromRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void emitInspectorDidBeginFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "emitInspectorDidBeginFrame", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    int frameId;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            impl->emitInspectorDidBeginFrame();
            return;
        }
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(frameId, toInt32(info[0], exceptionState), exceptionState);
    }
    impl->emitInspectorDidBeginFrame(frameId);
}

static void emitInspectorDidBeginFrameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::emitInspectorDidBeginFrameMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void emitInspectorDidCancelFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    impl->emitInspectorDidCancelFrame();
}

static void emitInspectorDidCancelFrameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::emitInspectorDidCancelFrameMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasSpellingMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSpellingMarker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    int from;
    int length;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(from, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(length, toInt32(info[2], exceptionState), exceptionState);
    }
    bool result = impl->hasSpellingMarker(document, from, length, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSpellingMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasSpellingMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hasGrammarMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasGrammarMarker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    int from;
    int length;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(from, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(length, toInt32(info[2], exceptionState), exceptionState);
    }
    bool result = impl->hasGrammarMarker(document, from, length, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasGrammarMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::hasGrammarMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setContinuousSpellCheckingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setContinuousSpellCheckingEnabled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool enabled;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(enabled, info[0]->BooleanValue());
    }
    impl->setContinuousSpellCheckingEnabled(enabled, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setContinuousSpellCheckingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setContinuousSpellCheckingEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isOverwriteModeEnabled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->isOverwriteModeEnabled(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isOverwriteModeEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void toggleOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "toggleOverwriteModeEnabled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->toggleOverwriteModeEnabled(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void toggleOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::toggleOverwriteModeEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfScrollableAreasMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "numberOfScrollableAreas", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    unsigned result = impl->numberOfScrollableAreas(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void numberOfScrollableAreasMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfScrollableAreasMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isPageBoxVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPageBoxVisible", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    int pageNumber;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pageNumber, toInt32(info[1], exceptionState), exceptionState);
    }
    bool result = impl->isPageBoxVisible(document, pageNumber, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isPageBoxVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isPageBoxVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void layerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "layerTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    unsigned flags;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            String result = impl->layerTreeAsText(document, exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(flags, toUInt16(info[1], exceptionState), exceptionState);
    }
    String result = impl->layerTreeAsText(document, flags, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void layerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::layerTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void elementLayerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementLayerTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    unsigned flags;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            String result = impl->elementLayerTreeAsText(element, exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(flags, toUInt16(info[1], exceptionState), exceptionState);
    }
    String result = impl->elementLayerTreeAsText(element, flags, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void elementLayerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::elementLayerTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scrollsWithRespectToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollsWithRespectTo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element1;
    Element* element2;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element1, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element2, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    bool result = impl->scrollsWithRespectTo(element1, element2, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void scrollsWithRespectToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::scrollsWithRespectToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isUnclippedDescendantMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isUnclippedDescendant", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->isUnclippedDescendant(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isUnclippedDescendantMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isUnclippedDescendantMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scrollingStateTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollingStateTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->scrollingStateTreeAsText(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void scrollingStateTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::scrollingStateTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void mainThreadScrollingReasonsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "mainThreadScrollingReasons", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->mainThreadScrollingReasons(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void mainThreadScrollingReasonsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::mainThreadScrollingReasonsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nonFastScrollableRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nonFastScrollableRects", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ClientRectList> result = impl->nonFastScrollableRects(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nonFastScrollableRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::nonFastScrollableRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void repaintRectsAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "repaintRectsAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->repaintRectsAsText(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void repaintRectsAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::repaintRectsAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void repaintRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "repaintRects", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ClientRectList> result = impl->repaintRects(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void repaintRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::repaintRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void garbageCollectDocumentResourcesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "garbageCollectDocumentResources", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->garbageCollectDocumentResources(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void garbageCollectDocumentResourcesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::garbageCollectDocumentResourcesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void evictAllResourcesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    impl->evictAllResources();
}

static void evictAllResourcesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::evictAllResourcesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void allowRoundingHacksMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    impl->allowRoundingHacks();
}

static void allowRoundingHacksMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::allowRoundingHacksMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfLiveNodesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValueUnsigned(info, impl->numberOfLiveNodes());
}

static void numberOfLiveNodesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfLiveNodesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfLiveDocumentsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValueUnsigned(info, impl->numberOfLiveDocuments());
}

static void numberOfLiveDocumentsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfLiveDocumentsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void dumpRefCountedInstanceCountsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValueString(info, impl->dumpRefCountedInstanceCounts(), info.GetIsolate());
}

static void dumpRefCountedInstanceCountsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::dumpRefCountedInstanceCountsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void consoleMessageArgumentCountsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("consoleMessageArgumentCounts", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValue(info, v8Array(impl->consoleMessageArgumentCounts(document), info.Holder(), info.GetIsolate()));
}

static void consoleMessageArgumentCountsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::consoleMessageArgumentCountsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setMemoryCacheCapacitiesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMemoryCacheCapacities", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    unsigned minDeadBytes;
    unsigned maxDeadBytes;
    unsigned totalBytes;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(minDeadBytes, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(maxDeadBytes, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(totalBytes, toUInt32(info[2], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, v8Array(impl->setMemoryCacheCapacities(minDeadBytes, maxDeadBytes, totalBytes), info.Holder(), info.GetIsolate()));
}

static void setMemoryCacheCapacitiesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setMemoryCacheCapacitiesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setInspectorResourcesDataSizeLimitsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setInspectorResourcesDataSizeLimits", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int maximumResourcesContentSize;
    int maximumSingleResourceContentSize;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(maximumResourcesContentSize, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(maximumSingleResourceContentSize, toInt32(info[1], exceptionState), exceptionState);
    }
    impl->setInspectorResourcesDataSizeLimits(maximumResourcesContentSize, maximumSingleResourceContentSize, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setInspectorResourcesDataSizeLimitsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setInspectorResourcesDataSizeLimitsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void counterValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("counterValue", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueString(info, impl->counterValue(element), info.GetIsolate());
}

static void counterValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::counterValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pageNumberMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("pageNumber", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    float pageWidth;
    float pageHeight;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            v8SetReturnValueInt(info, impl->pageNumber(element));
            return;
        }
        TONATIVE_VOID_INTERNAL(pageWidth, static_cast<float>(info[1]->NumberValue()));
        if (UNLIKELY(info.Length() <= 2)) {
            v8SetReturnValueInt(info, impl->pageNumber(element, pageWidth));
            return;
        }
        TONATIVE_VOID_INTERNAL(pageHeight, static_cast<float>(info[2]->NumberValue()));
    }
    v8SetReturnValueInt(info, impl->pageNumber(element, pageWidth, pageHeight));
}

static void pageNumberMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::pageNumberMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shortcutIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("shortcutIconURLs", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValue(info, v8Array(impl->shortcutIconURLs(document), info.Holder(), info.GetIsolate()));
}

static void shortcutIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::shortcutIconURLsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void allIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("allIconURLs", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValue(info, v8Array(impl->allIconURLs(document), info.Holder(), info.GetIsolate()));
}

static void allIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::allIconURLsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfPagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    double pageWidthInPixels;
    double pageHeightInPixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueInt(info, impl->numberOfPages());
            return;
        }
        TONATIVE_VOID_INTERNAL(pageWidthInPixels, static_cast<double>(info[0]->NumberValue()));
        if (UNLIKELY(info.Length() <= 1)) {
            v8SetReturnValueInt(info, impl->numberOfPages(pageWidthInPixels));
            return;
        }
        TONATIVE_VOID_INTERNAL(pageHeightInPixels, static_cast<double>(info[1]->NumberValue()));
    }
    v8SetReturnValueInt(info, impl->numberOfPages(pageWidthInPixels, pageHeightInPixels));
}

static void numberOfPagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfPagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pagePropertyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pageProperty", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> propertyName;
    int pageNumber;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TOSTRING_VOID_INTERNAL(propertyName, info[0]);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pageNumber, toInt32(info[1], exceptionState), exceptionState);
    }
    String result = impl->pageProperty(propertyName, pageNumber, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void pagePropertyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::pagePropertyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pageSizeAndMarginsInPixelsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pageSizeAndMarginsInPixels", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        throwMinimumArityTypeError(exceptionState, 7, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    int pageIndex;
    int width;
    int height;
    int marginTop;
    int marginRight;
    int marginBottom;
    int marginLeft;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pageIndex, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(marginTop, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(marginRight, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(marginBottom, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(marginLeft, toInt32(info[6], exceptionState), exceptionState);
    }
    String result = impl->pageSizeAndMarginsInPixels(pageIndex, width, height, marginTop, marginRight, marginBottom, marginLeft, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void pageSizeAndMarginsInPixelsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::pageSizeAndMarginsInPixelsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setDeviceScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setDeviceScaleFactor", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    float scaleFactor;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(scaleFactor, static_cast<float>(info[0]->NumberValue()));
    }
    impl->setDeviceScaleFactor(scaleFactor, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setDeviceScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setDeviceScaleFactorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setIsCursorVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setIsCursorVisible", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    bool isVisible;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(isVisible, info[1]->BooleanValue());
    }
    impl->setIsCursorVisible(document, isVisible, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setIsCursorVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setIsCursorVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitWillEnterFullScreenForElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("webkitWillEnterFullScreenForElement", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->webkitWillEnterFullScreenForElement(document, element);
}

static void webkitWillEnterFullScreenForElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::webkitWillEnterFullScreenForElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitDidEnterFullScreenForElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("webkitDidEnterFullScreenForElement", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->webkitDidEnterFullScreenForElement(document, element);
}

static void webkitDidEnterFullScreenForElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::webkitDidEnterFullScreenForElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitWillExitFullScreenForElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("webkitWillExitFullScreenForElement", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->webkitWillExitFullScreenForElement(document, element);
}

static void webkitWillExitFullScreenForElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::webkitWillExitFullScreenForElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitDidExitFullScreenForElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("webkitDidExitFullScreenForElement", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->webkitDidExitFullScreenForElement(document, element);
}

static void webkitDidExitFullScreenForElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::webkitDidExitFullScreenForElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void mediaPlayerRequestFullscreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("mediaPlayerRequestFullscreen", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    HTMLMediaElement* mediaElement;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(mediaElement, V8HTMLMediaElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->mediaPlayerRequestFullscreen(mediaElement);
}

static void mediaPlayerRequestFullscreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::mediaPlayerRequestFullscreenMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void registerURLSchemeAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("registerURLSchemeAsBypassingContentSecurityPolicy", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> scheme;
    {
        TOSTRING_VOID_INTERNAL(scheme, info[0]);
    }
    impl->registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
}

static void registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> scheme;
    {
        TOSTRING_VOID_INTERNAL(scheme, info[0]);
    }
    impl->removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
}

static void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void mallocStatisticsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValue(info, impl->mallocStatistics());
}

static void mallocStatisticsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::mallocStatisticsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void typeConversionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValue(info, impl->typeConversions());
}

static void typeConversionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::typeConversionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getReferencedFilePathsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValue(info, v8Array(impl->getReferencedFilePaths(), info.Holder(), info.GetIsolate()));
}

static void getReferencedFilePathsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::getReferencedFilePathsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void startTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "startTrackingRepaints", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->startTrackingRepaints(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void startTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::startTrackingRepaintsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stopTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stopTrackingRepaints", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->stopTrackingRepaints(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void stopTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::stopTrackingRepaintsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            impl->updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            return;
        }
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void forceFullRepaintMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forceFullRepaint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->forceFullRepaint(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forceFullRepaintMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::forceFullRepaintMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void draggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "draggableRegions", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ClientRectList> result = impl->draggableRegions(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void draggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::draggableRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void nonDraggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nonDraggableRegions", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    RefPtrWillBeRawPtr<ClientRectList> result = impl->nonDraggableRegions(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nonDraggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::nonDraggableRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getCurrentCursorInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getCurrentCursorInfo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->getCurrentCursorInfo(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void getCurrentCursorInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::getCurrentCursorInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void markerTextForListItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerTextForListItem", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->markerTextForListItem(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void markerTextForListItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::markerTextForListItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void baseURLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "baseURL", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->baseURL(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void baseURLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::baseURLMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deserializeBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deserializeBuffer", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    ArrayBuffer* buffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(buffer, info[0]->IsArrayBuffer() ? V8ArrayBuffer::toNative(v8::Handle<v8::ArrayBuffer>::Cast(info[0])) : 0);
    }
    v8SetReturnValue(info, impl->deserializeBuffer(buffer) ? impl->deserializeBuffer(buffer)->deserialize() : v8::Handle<v8::Value>(v8::Null(info.GetIsolate())));
}

static void deserializeBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::deserializeBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void serializeObjectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "serializeObject", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    RefPtr<SerializedScriptValue> obj;
    {
        obj = SerializedScriptValue::create(info[0], 0, 0, exceptionState, info.GetIsolate());
        if (exceptionState.hadException()) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    v8SetReturnValue(info, impl->serializeObject(obj));
}

static void serializeObjectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::serializeObjectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void forceReloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("forceReload", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool endToEnd;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(endToEnd, info[0]->BooleanValue());
    }
    impl->forceReload(endToEnd);
}

static void forceReloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::forceReloadMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getImageSourceURLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getImageSourceURL", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    String result = impl->getImageSourceURL(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void getImageSourceURLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::getImageSourceURLMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isSelectPopupVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isSelectPopupVisible", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isSelectPopupVisible(node));
}

static void isSelectPopupVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isSelectPopupVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void selectionBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "selectionBounds", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toNative(info.Holder());
    RefPtrWillBeRawPtr<ClientRect> result = impl->selectionBounds(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void selectionBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::selectionBoundsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void loseSharedGraphicsContext3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    v8SetReturnValueBool(info, impl->loseSharedGraphicsContext3D());
}

static void loseSharedGraphicsContext3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::loseSharedGraphicsContext3DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void forceCompositingUpdateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forceCompositingUpdate", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->forceCompositingUpdate(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forceCompositingUpdateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::forceCompositingUpdateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setZoomFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setZoomFactor", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    float factor;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(factor, static_cast<float>(info[0]->NumberValue()));
    }
    impl->setZoomFactor(factor);
}

static void setZoomFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setZoomFactorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setShouldRevealPasswordMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setShouldRevealPassword", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    bool reveal;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(reveal, info[1]->BooleanValue());
    }
    impl->setShouldRevealPassword(element, reveal, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setShouldRevealPasswordMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setShouldRevealPasswordMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toNative(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->createPromise(scriptState);
    v8SetReturnValue(info, result.v8Value());
}

static void createPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::createPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createResolvedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("createResolvedPromise", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    ScriptValue value;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(value, ScriptValue(ScriptState::current(info.GetIsolate()), info[0]));
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->createResolvedPromise(scriptState, value);
    v8SetReturnValue(info, result.v8Value());
}

static void createResolvedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::createResolvedPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createRejectedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("createRejectedPromise", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    ScriptValue reason;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(reason, ScriptValue(ScriptState::current(info.GetIsolate()), info[0]));
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->createRejectedPromise(scriptState, reason);
    v8SetReturnValue(info, result.v8Value());
}

static void createRejectedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::createRejectedPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void addOneToPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("addOneToPromise", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    ScriptPromise promise;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(promise, ScriptPromise::cast(ScriptState::current(info.GetIsolate()), info[0]));
        if (!promise.isUndefinedOrNull() && !promise.isObject()) {
            throwTypeError(ExceptionMessages::failedToExecute("addOneToPromise", "Internals", "parameter 1 ('promise') is not an object."), info.GetIsolate());
            return;
        }
    }
    ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
    v8SetReturnValue(info, impl->addOneToPromise(executionContext, promise).v8Value());
}

static void addOneToPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::addOneToPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setValueForUserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("setValueForUser", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Element* element;
    V8StringResource<> value;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(value, info[1]);
    }
    impl->setValueForUser(element, value);
}

static void setValueForUserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setValueForUserMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textSurroundingNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "textSurroundingNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Node* node;
    int x;
    int y;
    unsigned maxLength;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(node, V8Node::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(maxLength, toUInt32(info[3], exceptionState), exceptionState);
    }
    v8SetReturnValueString(info, impl->textSurroundingNode(node, x, y, maxLength), info.GetIsolate());
}

static void textSurroundingNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::textSurroundingNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setFocusedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setFocused", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool focused;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(focused, info[0]->BooleanValue());
    }
    impl->setFocused(focused);
}

static void setFocusedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setFocusedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void ignoreLayoutWithPendingStylesheetsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "ignoreLayoutWithPendingStylesheets", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    bool result = impl->ignoreLayoutWithPendingStylesheets(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void ignoreLayoutWithPendingStylesheetsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setNetworkStateNotifierTestOnlyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setNetworkStateNotifierTestOnly", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    bool testOnly;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(testOnly, info[0]->BooleanValue());
    }
    impl->setNetworkStateNotifierTestOnly(testOnly);
}

static void setNetworkStateNotifierTestOnlyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setNetworkStateNotifierTestOnlyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setNetworkConnectionInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setNetworkConnectionInfo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    V8StringResource<> type;
    {
        TOSTRING_VOID_INTERNAL(type, info[0]);
    }
    impl->setNetworkConnectionInfo(type, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setNetworkConnectionInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setNetworkConnectionInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setGeolocationClientMockMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setGeolocationClientMock", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    InternalsGeolocation::setGeolocationClientMock(*impl, document);
}

static void setGeolocationClientMockMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setGeolocationClientMockMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setGeolocationPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("setGeolocationPosition", "Internals", 4, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    double latitude;
    double longitude;
    double accuracy;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(latitude, static_cast<double>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(longitude, static_cast<double>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(accuracy, static_cast<double>(info[3]->NumberValue()));
    }
    InternalsGeolocation::setGeolocationPosition(*impl, document, latitude, longitude, accuracy);
}

static void setGeolocationPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setGeolocationPositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setGeolocationPositionUnavailableErrorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("setGeolocationPositionUnavailableError", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    V8StringResource<> message;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(message, info[1]);
    }
    InternalsGeolocation::setGeolocationPositionUnavailableError(*impl, document, message);
}

static void setGeolocationPositionUnavailableErrorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setGeolocationPositionUnavailableErrorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setGeolocationPermissionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("setGeolocationPermission", "Internals", 2, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    bool allowed;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(allowed, info[1]->BooleanValue());
    }
    InternalsGeolocation::setGeolocationPermission(*impl, document, allowed);
}

static void setGeolocationPermissionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setGeolocationPermissionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void numberOfPendingGeolocationPermissionRequestsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("numberOfPendingGeolocationPermissionRequests", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueInt(info, InternalsGeolocation::numberOfPendingGeolocationPermissionRequests(*impl, document));
}

static void numberOfPendingGeolocationPermissionRequestsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::numberOfPendingGeolocationPermissionRequestsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setNavigatorContentUtilsClientMockMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setNavigatorContentUtilsClientMock", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    InternalsNavigatorContentUtils::setNavigatorContentUtilsClientMock(*impl, document);
}

static void setNavigatorContentUtilsClientMockMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::setNavigatorContentUtilsClientMockMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void enableMockSpeechSynthesizerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("enableMockSpeechSynthesizer", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    InternalsSpeechSynthesis::enableMockSpeechSynthesizer(*impl, document);
}

static void enableMockSpeechSynthesizerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::enableMockSpeechSynthesizerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isVibratingMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isVibrating", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, InternalsVibration::isVibrating(*impl, document));
}

static void isVibratingMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::isVibratingMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pendingVibrationPatternMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("pendingVibrationPattern", "Internals", 1, info.Length(), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toNative(info.Holder());
    Document* document;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(document, V8Document::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValue(info, v8Array(InternalsVibration::pendingVibrationPattern(*impl, document), info.Holder(), info.GetIsolate()));
}

static void pendingVibrationPatternMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    InternalsV8Internal::pendingVibrationPatternMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

} // namespace InternalsV8Internal

static const V8DOMConfiguration::AttributeConfiguration V8InternalsAttributes[] = {
    {"pagePopupController", InternalsV8Internal::pagePopupControllerAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"settings", InternalsV8Internal::settingsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"profilers", InternalsV8Internal::profilersAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"runtimeFlags", InternalsV8Internal::runtimeFlagsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"workerThreadCount", InternalsV8Internal::workerThreadCountAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const V8DOMConfiguration::MethodConfiguration V8InternalsMethods[] = {
    {"address", InternalsV8Internal::addressMethodCallback, 0, 1},
    {"observeGC", InternalsV8Internal::observeGCMethodCallback, 0, 1},
    {"elementRenderTreeAsText", InternalsV8Internal::elementRenderTreeAsTextMethodCallback, 0, 1},
    {"isPreloaded", InternalsV8Internal::isPreloadedMethodCallback, 0, 1},
    {"isLoadingFromMemoryCache", InternalsV8Internal::isLoadingFromMemoryCacheMethodCallback, 0, 1},
    {"crash", InternalsV8Internal::crashMethodCallback, 0, 0},
    {"setStyleResolverStatsEnabled", InternalsV8Internal::setStyleResolverStatsEnabledMethodCallback, 0, 1},
    {"styleResolverStatsReport", InternalsV8Internal::styleResolverStatsReportMethodCallback, 0, 0},
    {"styleResolverStatsTotalsReport", InternalsV8Internal::styleResolverStatsTotalsReportMethodCallback, 0, 0},
    {"isSharingStyle", InternalsV8Internal::isSharingStyleMethodCallback, 0, 2},
    {"computedStyleIncludingVisitedInfo", InternalsV8Internal::computedStyleIncludingVisitedInfoMethodCallback, 0, 1},
    {"shadowRoot", InternalsV8Internal::shadowRootMethodCallback, 0, 1},
    {"youngestShadowRoot", InternalsV8Internal::youngestShadowRootMethodCallback, 0, 1},
    {"oldestShadowRoot", InternalsV8Internal::oldestShadowRootMethodCallback, 0, 1},
    {"youngerShadowRoot", InternalsV8Internal::youngerShadowRootMethodCallback, 0, 1},
    {"shadowRootType", InternalsV8Internal::shadowRootTypeMethodCallback, 0, 1},
    {"hasShadowInsertionPoint", InternalsV8Internal::hasShadowInsertionPointMethodCallback, 0, 1},
    {"hasContentElement", InternalsV8Internal::hasContentElementMethodCallback, 0, 1},
    {"countElementShadow", InternalsV8Internal::countElementShadowMethodCallback, 0, 1},
    {"shadowPseudoId", InternalsV8Internal::shadowPseudoIdMethodCallback, 0, 1},
    {"setShadowPseudoId", InternalsV8Internal::setShadowPseudoIdMethodCallback, 0, 2},
    {"isValidContentSelect", InternalsV8Internal::isValidContentSelectMethodCallback, 0, 1},
    {"treeScopeRootNode", InternalsV8Internal::treeScopeRootNodeMethodCallback, 0, 1},
    {"parentTreeScope", InternalsV8Internal::parentTreeScopeMethodCallback, 0, 1},
    {"hasSelectorForIdInShadow", InternalsV8Internal::hasSelectorForIdInShadowMethodCallback, 0, 2},
    {"hasSelectorForClassInShadow", InternalsV8Internal::hasSelectorForClassInShadowMethodCallback, 0, 2},
    {"hasSelectorForAttributeInShadow", InternalsV8Internal::hasSelectorForAttributeInShadowMethodCallback, 0, 2},
    {"hasSelectorForPseudoClassInShadow", InternalsV8Internal::hasSelectorForPseudoClassInShadowMethodCallback, 0, 2},
    {"compareTreeScopePosition", InternalsV8Internal::compareTreeScopePositionMethodCallback, 0, 2},
    {"updateStyleAndReturnAffectedElementCount", InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethodCallback, 0, 0},
    {"needsLayoutCount", InternalsV8Internal::needsLayoutCountMethodCallback, 0, 0},
    {"numberOfActiveAnimations", InternalsV8Internal::numberOfActiveAnimationsMethodCallback, 0, 0},
    {"pauseAnimations", InternalsV8Internal::pauseAnimationsMethodCallback, 0, 1},
    {"nextSiblingByWalker", InternalsV8Internal::nextSiblingByWalkerMethodCallback, 0, 1},
    {"firstChildByWalker", InternalsV8Internal::firstChildByWalkerMethodCallback, 0, 1},
    {"lastChildByWalker", InternalsV8Internal::lastChildByWalkerMethodCallback, 0, 1},
    {"nextNodeByWalker", InternalsV8Internal::nextNodeByWalkerMethodCallback, 0, 1},
    {"previousNodeByWalker", InternalsV8Internal::previousNodeByWalkerMethodCallback, 0, 1},
    {"visiblePlaceholder", InternalsV8Internal::visiblePlaceholderMethodCallback, 0, 1},
    {"selectColorInColorChooser", InternalsV8Internal::selectColorInColorChooserMethodCallback, 0, 2},
    {"hasAutofocusRequest", InternalsV8Internal::hasAutofocusRequestMethodCallback, 0, 0},
    {"formControlStateOfHistoryItem", InternalsV8Internal::formControlStateOfHistoryItemMethodCallback, 0, 0},
    {"setFormControlStateOfHistoryItem", InternalsV8Internal::setFormControlStateOfHistoryItemMethodCallback, 0, 1},
    {"setEnableMockPagePopup", InternalsV8Internal::setEnableMockPagePopupMethodCallback, 0, 1},
    {"unscaledViewportRect", InternalsV8Internal::unscaledViewportRectMethodCallback, 0, 0},
    {"absoluteCaretBounds", InternalsV8Internal::absoluteCaretBoundsMethodCallback, 0, 0},
    {"boundingBox", InternalsV8Internal::boundingBoxMethodCallback, 0, 1},
    {"markerCountForNode", InternalsV8Internal::markerCountForNodeMethodCallback, 0, 2},
    {"activeMarkerCountForNode", InternalsV8Internal::activeMarkerCountForNodeMethodCallback, 0, 1},
    {"markerRangeForNode", InternalsV8Internal::markerRangeForNodeMethodCallback, 0, 3},
    {"markerDescriptionForNode", InternalsV8Internal::markerDescriptionForNodeMethodCallback, 0, 3},
    {"addTextMatchMarker", InternalsV8Internal::addTextMatchMarkerMethodCallback, 0, 2},
    {"setMarkersActive", InternalsV8Internal::setMarkersActiveMethodCallback, 0, 4},
    {"setMarkedTextMatchesAreHighlighted", InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethodCallback, 0, 2},
    {"setScrollViewPosition", InternalsV8Internal::setScrollViewPositionMethodCallback, 0, 3},
    {"viewportAsText", InternalsV8Internal::viewportAsTextMethodCallback, 0, 4},
    {"wasLastChangeUserEdit", InternalsV8Internal::wasLastChangeUserEditMethodCallback, 0, 1},
    {"elementShouldAutoComplete", InternalsV8Internal::elementShouldAutoCompleteMethodCallback, 0, 1},
    {"suggestedValue", InternalsV8Internal::suggestedValueMethodCallback, 0, 1},
    {"setSuggestedValue", InternalsV8Internal::setSuggestedValueMethodCallback, 0, 2},
    {"setEditingValue", InternalsV8Internal::setEditingValueMethodCallback, 0, 2},
    {"setAutofilled", InternalsV8Internal::setAutofilledMethodCallback, 0, 2},
    {"scrollElementToRect", InternalsV8Internal::scrollElementToRectMethodCallback, 0, 5},
    {"rangeFromLocationAndLength", InternalsV8Internal::rangeFromLocationAndLengthMethodCallback, 0, 3},
    {"locationFromRange", InternalsV8Internal::locationFromRangeMethodCallback, 0, 2},
    {"lengthFromRange", InternalsV8Internal::lengthFromRangeMethodCallback, 0, 2},
    {"rangeAsText", InternalsV8Internal::rangeAsTextMethodCallback, 0, 1},
    {"touchPositionAdjustedToBestClickableNode", InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethodCallback, 0, 5},
    {"touchNodeAdjustedToBestClickableNode", InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethodCallback, 0, 5},
    {"touchPositionAdjustedToBestContextMenuNode", InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethodCallback, 0, 5},
    {"touchNodeAdjustedToBestContextMenuNode", InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethodCallback, 0, 5},
    {"bestZoomableAreaForTouchPoint", InternalsV8Internal::bestZoomableAreaForTouchPointMethodCallback, 0, 5},
    {"lastSpellCheckRequestSequence", InternalsV8Internal::lastSpellCheckRequestSequenceMethodCallback, 0, 1},
    {"lastSpellCheckProcessedSequence", InternalsV8Internal::lastSpellCheckProcessedSequenceMethodCallback, 0, 1},
    {"userPreferredLanguages", InternalsV8Internal::userPreferredLanguagesMethodCallback, 0, 0},
    {"setUserPreferredLanguages", InternalsV8Internal::setUserPreferredLanguagesMethodCallback, 0, 1},
    {"activeDOMObjectCount", InternalsV8Internal::activeDOMObjectCountMethodCallback, 0, 1},
    {"wheelEventHandlerCount", InternalsV8Internal::wheelEventHandlerCountMethodCallback, 0, 1},
    {"scrollEventHandlerCount", InternalsV8Internal::scrollEventHandlerCountMethodCallback, 0, 1},
    {"touchEventHandlerCount", InternalsV8Internal::touchEventHandlerCountMethodCallback, 0, 1},
    {"touchEventTargetLayerRects", InternalsV8Internal::touchEventTargetLayerRectsMethodCallback, 0, 1},
    {"nodesFromRect", InternalsV8Internal::nodesFromRectMethodCallback, 0, 10},
    {"emitInspectorDidBeginFrame", InternalsV8Internal::emitInspectorDidBeginFrameMethodCallback, 0, 0},
    {"emitInspectorDidCancelFrame", InternalsV8Internal::emitInspectorDidCancelFrameMethodCallback, 0, 0},
    {"hasSpellingMarker", InternalsV8Internal::hasSpellingMarkerMethodCallback, 0, 3},
    {"hasGrammarMarker", InternalsV8Internal::hasGrammarMarkerMethodCallback, 0, 3},
    {"setContinuousSpellCheckingEnabled", InternalsV8Internal::setContinuousSpellCheckingEnabledMethodCallback, 0, 1},
    {"isOverwriteModeEnabled", InternalsV8Internal::isOverwriteModeEnabledMethodCallback, 0, 1},
    {"toggleOverwriteModeEnabled", InternalsV8Internal::toggleOverwriteModeEnabledMethodCallback, 0, 1},
    {"numberOfScrollableAreas", InternalsV8Internal::numberOfScrollableAreasMethodCallback, 0, 1},
    {"isPageBoxVisible", InternalsV8Internal::isPageBoxVisibleMethodCallback, 0, 2},
    {"layerTreeAsText", InternalsV8Internal::layerTreeAsTextMethodCallback, 0, 1},
    {"elementLayerTreeAsText", InternalsV8Internal::elementLayerTreeAsTextMethodCallback, 0, 1},
    {"scrollsWithRespectTo", InternalsV8Internal::scrollsWithRespectToMethodCallback, 0, 2},
    {"isUnclippedDescendant", InternalsV8Internal::isUnclippedDescendantMethodCallback, 0, 1},
    {"scrollingStateTreeAsText", InternalsV8Internal::scrollingStateTreeAsTextMethodCallback, 0, 1},
    {"mainThreadScrollingReasons", InternalsV8Internal::mainThreadScrollingReasonsMethodCallback, 0, 1},
    {"nonFastScrollableRects", InternalsV8Internal::nonFastScrollableRectsMethodCallback, 0, 1},
    {"repaintRectsAsText", InternalsV8Internal::repaintRectsAsTextMethodCallback, 0, 1},
    {"repaintRects", InternalsV8Internal::repaintRectsMethodCallback, 0, 1},
    {"garbageCollectDocumentResources", InternalsV8Internal::garbageCollectDocumentResourcesMethodCallback, 0, 1},
    {"evictAllResources", InternalsV8Internal::evictAllResourcesMethodCallback, 0, 0},
    {"allowRoundingHacks", InternalsV8Internal::allowRoundingHacksMethodCallback, 0, 0},
    {"numberOfLiveNodes", InternalsV8Internal::numberOfLiveNodesMethodCallback, 0, 0},
    {"numberOfLiveDocuments", InternalsV8Internal::numberOfLiveDocumentsMethodCallback, 0, 0},
    {"dumpRefCountedInstanceCounts", InternalsV8Internal::dumpRefCountedInstanceCountsMethodCallback, 0, 0},
    {"consoleMessageArgumentCounts", InternalsV8Internal::consoleMessageArgumentCountsMethodCallback, 0, 1},
    {"setMemoryCacheCapacities", InternalsV8Internal::setMemoryCacheCapacitiesMethodCallback, 0, 3},
    {"setInspectorResourcesDataSizeLimits", InternalsV8Internal::setInspectorResourcesDataSizeLimitsMethodCallback, 0, 2},
    {"counterValue", InternalsV8Internal::counterValueMethodCallback, 0, 1},
    {"pageNumber", InternalsV8Internal::pageNumberMethodCallback, 0, 1},
    {"shortcutIconURLs", InternalsV8Internal::shortcutIconURLsMethodCallback, 0, 1},
    {"allIconURLs", InternalsV8Internal::allIconURLsMethodCallback, 0, 1},
    {"numberOfPages", InternalsV8Internal::numberOfPagesMethodCallback, 0, 0},
    {"pageProperty", InternalsV8Internal::pagePropertyMethodCallback, 0, 2},
    {"pageSizeAndMarginsInPixels", InternalsV8Internal::pageSizeAndMarginsInPixelsMethodCallback, 0, 7},
    {"setDeviceScaleFactor", InternalsV8Internal::setDeviceScaleFactorMethodCallback, 0, 1},
    {"setIsCursorVisible", InternalsV8Internal::setIsCursorVisibleMethodCallback, 0, 2},
    {"webkitWillEnterFullScreenForElement", InternalsV8Internal::webkitWillEnterFullScreenForElementMethodCallback, 0, 2},
    {"webkitDidEnterFullScreenForElement", InternalsV8Internal::webkitDidEnterFullScreenForElementMethodCallback, 0, 2},
    {"webkitWillExitFullScreenForElement", InternalsV8Internal::webkitWillExitFullScreenForElementMethodCallback, 0, 2},
    {"webkitDidExitFullScreenForElement", InternalsV8Internal::webkitDidExitFullScreenForElementMethodCallback, 0, 2},
    {"mediaPlayerRequestFullscreen", InternalsV8Internal::mediaPlayerRequestFullscreenMethodCallback, 0, 1},
    {"registerURLSchemeAsBypassingContentSecurityPolicy", InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback, 0, 1},
    {"removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback, 0, 1},
    {"mallocStatistics", InternalsV8Internal::mallocStatisticsMethodCallback, 0, 0},
    {"typeConversions", InternalsV8Internal::typeConversionsMethodCallback, 0, 0},
    {"getReferencedFilePaths", InternalsV8Internal::getReferencedFilePathsMethodCallback, 0, 0},
    {"startTrackingRepaints", InternalsV8Internal::startTrackingRepaintsMethodCallback, 0, 1},
    {"stopTrackingRepaints", InternalsV8Internal::stopTrackingRepaintsMethodCallback, 0, 1},
    {"updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks", InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback, 0, 0},
    {"forceFullRepaint", InternalsV8Internal::forceFullRepaintMethodCallback, 0, 1},
    {"draggableRegions", InternalsV8Internal::draggableRegionsMethodCallback, 0, 1},
    {"nonDraggableRegions", InternalsV8Internal::nonDraggableRegionsMethodCallback, 0, 1},
    {"getCurrentCursorInfo", InternalsV8Internal::getCurrentCursorInfoMethodCallback, 0, 1},
    {"markerTextForListItem", InternalsV8Internal::markerTextForListItemMethodCallback, 0, 1},
    {"baseURL", InternalsV8Internal::baseURLMethodCallback, 0, 1},
    {"deserializeBuffer", InternalsV8Internal::deserializeBufferMethodCallback, 0, 1},
    {"serializeObject", InternalsV8Internal::serializeObjectMethodCallback, 0, 1},
    {"forceReload", InternalsV8Internal::forceReloadMethodCallback, 0, 1},
    {"getImageSourceURL", InternalsV8Internal::getImageSourceURLMethodCallback, 0, 1},
    {"isSelectPopupVisible", InternalsV8Internal::isSelectPopupVisibleMethodCallback, 0, 1},
    {"selectionBounds", InternalsV8Internal::selectionBoundsMethodCallback, 0, 0},
    {"loseSharedGraphicsContext3D", InternalsV8Internal::loseSharedGraphicsContext3DMethodCallback, 0, 0},
    {"forceCompositingUpdate", InternalsV8Internal::forceCompositingUpdateMethodCallback, 0, 1},
    {"setZoomFactor", InternalsV8Internal::setZoomFactorMethodCallback, 0, 1},
    {"setShouldRevealPassword", InternalsV8Internal::setShouldRevealPasswordMethodCallback, 0, 2},
    {"createPromise", InternalsV8Internal::createPromiseMethodCallback, 0, 0},
    {"createResolvedPromise", InternalsV8Internal::createResolvedPromiseMethodCallback, 0, 1},
    {"createRejectedPromise", InternalsV8Internal::createRejectedPromiseMethodCallback, 0, 1},
    {"addOneToPromise", InternalsV8Internal::addOneToPromiseMethodCallback, 0, 1},
    {"setValueForUser", InternalsV8Internal::setValueForUserMethodCallback, 0, 2},
    {"textSurroundingNode", InternalsV8Internal::textSurroundingNodeMethodCallback, 0, 4},
    {"setFocused", InternalsV8Internal::setFocusedMethodCallback, 0, 1},
    {"ignoreLayoutWithPendingStylesheets", InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethodCallback, 0, 1},
    {"setNetworkStateNotifierTestOnly", InternalsV8Internal::setNetworkStateNotifierTestOnlyMethodCallback, 0, 1},
    {"setNetworkConnectionInfo", InternalsV8Internal::setNetworkConnectionInfoMethodCallback, 0, 1},
    {"setGeolocationClientMock", InternalsV8Internal::setGeolocationClientMockMethodCallback, 0, 1},
    {"setGeolocationPosition", InternalsV8Internal::setGeolocationPositionMethodCallback, 0, 4},
    {"setGeolocationPositionUnavailableError", InternalsV8Internal::setGeolocationPositionUnavailableErrorMethodCallback, 0, 2},
    {"setGeolocationPermission", InternalsV8Internal::setGeolocationPermissionMethodCallback, 0, 2},
    {"numberOfPendingGeolocationPermissionRequests", InternalsV8Internal::numberOfPendingGeolocationPermissionRequestsMethodCallback, 0, 1},
    {"setNavigatorContentUtilsClientMock", InternalsV8Internal::setNavigatorContentUtilsClientMockMethodCallback, 0, 1},
    {"enableMockSpeechSynthesizer", InternalsV8Internal::enableMockSpeechSynthesizerMethodCallback, 0, 1},
    {"isVibrating", InternalsV8Internal::isVibratingMethodCallback, 0, 1},
    {"pendingVibrationPattern", InternalsV8Internal::pendingVibrationPatternMethodCallback, 0, 1},
};

static void configureV8InternalsTemplate(v8::Handle<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(functionTemplate, "Internals", v8::Local<v8::FunctionTemplate>(), V8Internals::internalFieldCount,
        V8InternalsAttributes, WTF_ARRAY_LENGTH(V8InternalsAttributes),
        0, 0,
        V8InternalsMethods, WTF_ARRAY_LENGTH(V8InternalsMethods),
        isolate);
    v8::Local<v8::ObjectTemplate> instanceTemplate ALLOW_UNUSED = functionTemplate->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototypeTemplate ALLOW_UNUSED = functionTemplate->PrototypeTemplate();
    static const V8DOMConfiguration::ConstantConfiguration V8InternalsConstants[] = {
        {"LAYER_TREE_INCLUDES_REPAINT_RECTS", 2},
        {"LAYER_TREE_INCLUDES_PAINTING_PHASES", 4},
        {"LAYER_TREE_INCLUDES_ROOT_LAYER", 8},
        {"LAYER_TREE_INCLUDES_CLIP_AND_SCROLL_PARENTS", 16},
    };
    V8DOMConfiguration::installConstants(functionTemplate, prototypeTemplate, V8InternalsConstants, WTF_ARRAY_LENGTH(V8InternalsConstants), isolate);

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Handle<v8::FunctionTemplate> V8Internals::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), configureV8InternalsTemplate);
}

bool V8Internals::hasInstance(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Handle<v8::Object> V8Internals::findInstanceInPrototypeChain(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Internals* V8Internals::toNativeWithTypeCheck(v8::Isolate* isolate, v8::Handle<v8::Value> value)
{
    return hasInstance(value, isolate) ? fromInternalPointer(v8::Handle<v8::Object>::Cast(value)->GetAlignedPointerFromInternalField(v8DOMWrapperObjectIndex)) : 0;
}

v8::Handle<v8::Object> wrap(Internals* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8Internals>(impl, isolate));
    return V8Internals::createWrapper(impl, creationContext, isolate);
}

v8::Handle<v8::Object> V8Internals::createWrapper(PassRefPtrWillBeRawPtr<Internals> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8Internals>(impl.get(), isolate));
    if (ScriptWrappable::wrapperCanBeStoredInObject(impl.get())) {
        const WrapperTypeInfo* actualInfo = ScriptWrappable::fromObject(impl.get())->typeInfo();
        // Might be a XXXConstructor::wrapperTypeInfo instead of an XXX::wrapperTypeInfo. These will both have
        // the same object de-ref functions, though, so use that as the basis of the check.
        RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(actualInfo->derefObjectFunction == wrapperTypeInfo.derefObjectFunction);
    }

    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &wrapperTypeInfo, toInternalPointer(impl.get()), isolate);
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    installPerContextEnabledProperties(wrapper, impl.get(), isolate);
    V8DOMWrapper::associateObjectWithWrapper<V8Internals>(impl, &wrapperTypeInfo, wrapper, isolate, WrapperConfiguration::Independent);
    return wrapper;
}

void V8Internals::derefObject(void* object)
{
#if !ENABLE(OILPAN)
    fromInternalPointer(object)->deref();
#endif // !ENABLE(OILPAN)
}

template<>
v8::Handle<v8::Value> toV8NoInline(Internals* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    return toV8(impl, creationContext, isolate);
}

} // namespace WebCore
