// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8CanvasRenderingContext2D.h"

#include "bindings/core/v8/V8Canvas2DContextAttributes.h"
#include "bindings/core/v8/V8CanvasGradient.h"
#include "bindings/core/v8/V8CanvasPattern.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8HTMLCanvasElement.h"
#include "bindings/core/v8/V8HTMLImageElement.h"
#include "bindings/core/v8/V8HTMLVideoElement.h"
#include "bindings/core/v8/V8ImageBitmap.h"
#include "bindings/core/v8/V8ImageData.h"
#include "bindings/core/v8/V8Path2D.h"
#include "bindings/core/v8/V8SVGMatrix.h"
#include "bindings/core/v8/V8TextMetrics.h"
#include "bindings/v8/ExceptionState.h"
#include "bindings/v8/V8DOMConfiguration.h"
#include "bindings/v8/V8HiddenValue.h"
#include "bindings/v8/V8ObjectConstructor.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/frame/UseCounter.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace WebCore {

static void initializeScriptWrappableForInterface(CanvasRenderingContext2D* object)
{
    if (ScriptWrappable::wrapperCanBeStoredInObject(object))
        ScriptWrappable::fromObject(object)->setTypeInfo(&V8CanvasRenderingContext2D::wrapperTypeInfo);
    else
        ASSERT_NOT_REACHED();
}

} // namespace WebCore

void webCoreInitializeScriptWrappableForInterface(WebCore::CanvasRenderingContext2D* object)
{
    WebCore::initializeScriptWrappableForInterface(object);
}

namespace WebCore {
const WrapperTypeInfo V8CanvasRenderingContext2D::wrapperTypeInfo = { gin::kEmbedderBlink, V8CanvasRenderingContext2D::domTemplate, V8CanvasRenderingContext2D::derefObject, 0, 0, 0, V8CanvasRenderingContext2D::installPerContextEnabledMethods, 0, WrapperTypeObjectPrototype, WillBeGarbageCollectedObject };

namespace CanvasRenderingContext2DV8Internal {

template <typename T> void V8_USE(T) { }

static void canvasAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->canvas()), impl);
}

static void canvasAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::canvasAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void currentTransformAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->currentTransform()), impl);
}

static void currentTransformAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::currentTransformAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void currentTransformAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "currentTransform", "CanvasRenderingContext2D", holder, info.GetIsolate());
    if (!V8SVGMatrix::hasInstance(v8Value, info.GetIsolate())) {
        exceptionState.throwTypeError("The provided value is not of type 'SVGMatrix'.");
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(SVGMatrixTearOff*, cppValue, V8SVGMatrix::toNativeWithTypeCheck(info.GetIsolate(), v8Value));
    impl->setCurrentTransform(WTF::getPtr(cppValue));
}

static void currentTransformAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::currentTransformAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void globalAlphaAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->globalAlpha());
}

static void globalAlphaAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::globalAlphaAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void globalAlphaAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setGlobalAlpha(cppValue);
}

static void globalAlphaAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::globalAlphaAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void globalCompositeOperationAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->globalCompositeOperation(), info.GetIsolate());
}

static void globalCompositeOperationAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void globalCompositeOperationAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithNullCheck>, cppValue, v8Value);
    impl->setGlobalCompositeOperation(cppValue);
}

static void globalCompositeOperationAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitImageSmoothingEnabledAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueBool(info, impl->imageSmoothingEnabled());
}

static void webkitImageSmoothingEnabledAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void webkitImageSmoothingEnabledAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(bool, cppValue, v8Value->BooleanValue());
    impl->setImageSmoothingEnabled(cppValue);
}

static void webkitImageSmoothingEnabledAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void imageSmoothingEnabledAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueBool(info, impl->imageSmoothingEnabled());
}

static void imageSmoothingEnabledAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::UnprefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void imageSmoothingEnabledAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(bool, cppValue, v8Value->BooleanValue());
    impl->setImageSmoothingEnabled(cppValue);
}

static void imageSmoothingEnabledAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::UnprefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void strokeStyleAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    V8CanvasRenderingContext2D::strokeStyleAttributeGetterCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void strokeStyleAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    V8CanvasRenderingContext2D::strokeStyleAttributeSetterCustom(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fillStyleAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    V8CanvasRenderingContext2D::fillStyleAttributeGetterCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fillStyleAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    V8CanvasRenderingContext2D::fillStyleAttributeSetterCustom(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowOffsetXAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->shadowOffsetX());
}

static void shadowOffsetXAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowOffsetXAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setShadowOffsetX(cppValue);
}

static void shadowOffsetXAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowOffsetYAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->shadowOffsetY());
}

static void shadowOffsetYAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowOffsetYAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setShadowOffsetY(cppValue);
}

static void shadowOffsetYAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowBlurAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->shadowBlur());
}

static void shadowBlurAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowBlurAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowBlurAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setShadowBlur(cppValue);
}

static void shadowBlurAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowBlurAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowColorAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->shadowColor(), info.GetIsolate());
}

static void shadowColorAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowColorAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shadowColorAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithNullCheck>, cppValue, v8Value);
    impl->setShadowColor(cppValue);
}

static void shadowColorAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowColorAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineWidthAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->lineWidth());
}

static void lineWidthAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineWidthAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineWidthAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setLineWidth(cppValue);
}

static void lineWidthAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineWidthAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineCapAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->lineCap(), info.GetIsolate());
}

static void lineCapAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineCapAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineCapAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithNullCheck>, cppValue, v8Value);
    impl->setLineCap(cppValue);
}

static void lineCapAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineCapAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineJoinAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->lineJoin(), info.GetIsolate());
}

static void lineJoinAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineJoinAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineJoinAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<WithNullCheck>, cppValue, v8Value);
    impl->setLineJoin(cppValue);
}

static void lineJoinAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineJoinAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void miterLimitAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->miterLimit());
}

static void miterLimitAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::miterLimitAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void miterLimitAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setMiterLimit(cppValue);
}

static void miterLimitAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::miterLimitAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineDashOffsetAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValue(info, impl->lineDashOffset());
}

static void lineDashOffsetAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineDashOffsetAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TONATIVE_VOID(float, cppValue, static_cast<float>(v8Value->NumberValue()));
    impl->setLineDashOffset(cppValue);
}

static void lineDashOffsetAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fontAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->font(), info.GetIsolate());
}

static void fontAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::fontAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fontAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<>, cppValue, v8Value);
    impl->setFont(cppValue);
}

static void fontAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::fontAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textAlignAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->textAlign(), info.GetIsolate());
}

static void textAlignAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::textAlignAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textAlignAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<>, cppValue, v8Value);
    impl->setTextAlign(cppValue);
}

static void textAlignAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::textAlignAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textBaselineAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    v8SetReturnValueString(info, impl->textBaseline(), info.GetIsolate());
}

static void textBaselineAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::textBaselineAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void textBaselineAttributeSetter(v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(holder);
    TOSTRING_VOID(V8StringResource<>, cppValue, v8Value);
    impl->setTextBaseline(cppValue);
}

static void textBaselineAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::textBaselineAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void saveMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->save();
}

static void saveMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::saveMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void restoreMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->restore();
}

static void restoreMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::restoreMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scaleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("scale", "CanvasRenderingContext2D", 2, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
    }
    impl->scale(x, y);
}

static void scaleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::scaleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void rotateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("rotate", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float angle;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(angle, static_cast<float>(info[0]->NumberValue()));
    }
    impl->rotate(angle);
}

static void rotateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::rotateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void translateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("translate", "CanvasRenderingContext2D", 2, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
    }
    impl->translate(x, y);
}

static void translateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::translateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void transformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 6)) {
        throwMinimumArityTypeErrorForMethod("transform", "CanvasRenderingContext2D", 6, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(b, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(c, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(d, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(e, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(f, static_cast<float>(info[5]->NumberValue()));
    }
    impl->transform(a, b, c, d, e, f);
}

static void transformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::transformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setTransformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 6)) {
        throwMinimumArityTypeErrorForMethod("setTransform", "CanvasRenderingContext2D", 6, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(b, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(c, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(d, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(e, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(f, static_cast<float>(info[5]->NumberValue()));
    }
    impl->setTransform(a, b, c, d, e, f);
}

static void setTransformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setTransformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void resetTransformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->resetTransform();
}

static void resetTransformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::resetTransformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createLinearGradientMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("createLinearGradient", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x0;
    float y0;
    float x1;
    float y1;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x0, static_cast<float>(info[0]->NumberValue()));
        if (!std::isfinite(x0)) {
            throwTypeError(ExceptionMessages::failedToExecute("createLinearGradient", "CanvasRenderingContext2D", "float parameter 1 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(y0, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(y0)) {
            throwTypeError(ExceptionMessages::failedToExecute("createLinearGradient", "CanvasRenderingContext2D", "float parameter 2 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(x1, static_cast<float>(info[2]->NumberValue()));
        if (!std::isfinite(x1)) {
            throwTypeError(ExceptionMessages::failedToExecute("createLinearGradient", "CanvasRenderingContext2D", "float parameter 3 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(y1, static_cast<float>(info[3]->NumberValue()));
        if (!std::isfinite(y1)) {
            throwTypeError(ExceptionMessages::failedToExecute("createLinearGradient", "CanvasRenderingContext2D", "float parameter 4 is non-finite."), info.GetIsolate());
            return;
        }
    }
    v8SetReturnValue(info, impl->createLinearGradient(x0, y0, x1, y1));
}

static void createLinearGradientMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createLinearGradientMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createRadialGradientMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createRadialGradient", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        throwMinimumArityTypeError(exceptionState, 6, info.Length());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x0;
    float y0;
    float r0;
    float x1;
    float y1;
    float r1;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x0, static_cast<float>(info[0]->NumberValue()));
        if (!std::isfinite(x0)) {
            exceptionState.throwTypeError("float parameter 1 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(y0, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(y0)) {
            exceptionState.throwTypeError("float parameter 2 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(r0, static_cast<float>(info[2]->NumberValue()));
        if (!std::isfinite(r0)) {
            exceptionState.throwTypeError("float parameter 3 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(x1, static_cast<float>(info[3]->NumberValue()));
        if (!std::isfinite(x1)) {
            exceptionState.throwTypeError("float parameter 4 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(y1, static_cast<float>(info[4]->NumberValue()));
        if (!std::isfinite(y1)) {
            exceptionState.throwTypeError("float parameter 5 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(r1, static_cast<float>(info[5]->NumberValue()));
        if (!std::isfinite(r1)) {
            exceptionState.throwTypeError("float parameter 6 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtr<CanvasGradient> result = impl->createRadialGradient(x0, y0, r0, x1, y1, r1, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createRadialGradientMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createRadialGradientMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createPattern1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createPattern", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLCanvasElement* canvas;
    V8StringResource<WithNullCheck> repetitionType;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLCanvasElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(repetitionType, info[1]);
    }
    RefPtr<CanvasPattern> result = impl->createPattern(canvas, repetitionType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createPattern2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createPattern", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLImageElement* image;
    V8StringResource<WithNullCheck> repetitionType;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLImageElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(repetitionType, info[1]);
    }
    RefPtr<CanvasPattern> result = impl->createPattern(image, repetitionType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createPattern3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createPattern", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLVideoElement* image;
    V8StringResource<WithNullCheck> repetitionType;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLVideoElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(repetitionType, info[1]);
    }
    RefPtr<CanvasPattern> result = impl->createPattern(image, repetitionType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createPatternMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createPattern", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(2, info.Length())) {
    case 2:
        if (V8HTMLCanvasElement::hasInstance(info[0], isolate)) {
            createPattern1Method(info);
            return;
        }
        if (V8HTMLImageElement::hasInstance(info[0], isolate)) {
            createPattern2Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[0], isolate)) {
            createPattern3Method(info);
            return;
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void createPatternMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createPatternMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("clearRect", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[3]->NumberValue()));
    }
    impl->clearRect(x, y, width, height);
}

static void clearRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::clearRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fillRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("fillRect", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[3]->NumberValue()));
    }
    impl->fillRect(x, y, width, height);
}

static void fillRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void strokeRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("strokeRect", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[3]->NumberValue()));
    }
    impl->strokeRect(x, y, width, height);
}

static void strokeRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void beginPathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->beginPath();
}

static void beginPathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::beginPathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fill1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            impl->fill();
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[0]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("fill", "CanvasRenderingContext2D", "parameter 1 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    impl->fill(winding);
}

static void fill2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("fill", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            impl->fill(path);
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[1]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("fill", "CanvasRenderingContext2D", "parameter 2 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    impl->fill(path, winding);
}

static void fillMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fill", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            fill1Method(info);
            return;
        }
        break;
    case 1:
        if (info[0]->IsUndefined()) {
            fill1Method(info);
            return;
        }
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (V8Path2D::hasInstance(info[0], isolate)) {
                fill2Method(info);
                return;
            }
        }
        if (true) {
            fill1Method(info);
            return;
        }
        break;
    case 2:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                fill2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(0, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void fillMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stroke1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->stroke();
}

static void stroke2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("stroke", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->stroke(path);
}

static void strokeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stroke", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(1, info.Length())) {
    case 0:
        if (true) {
            stroke1Method(info);
            return;
        }
        break;
    case 1:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                stroke2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(0, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void strokeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawFocusIfNeeded1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Element::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 1 is not of type 'Element'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->drawFocusIfNeeded(element);
}

static void drawFocusIfNeeded2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    Element* element;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (info.Length() > 1 && !V8Element::hasInstance(info[1], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 2 is not of type 'Element'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(element, V8Element::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->drawFocusIfNeeded(path, element);
}

static void drawFocusIfNeededMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawFocusIfNeeded", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            drawFocusIfNeeded1Method(info);
            return;
        }
        break;
    case 2:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                drawFocusIfNeeded2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void drawFocusIfNeededMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::drawFocusIfNeededMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scrollPathIntoViewMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            impl->scrollPathIntoView();
            return;
        }
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("scrollPathIntoView", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->scrollPathIntoView(path);
}

static void scrollPathIntoViewMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::scrollPathIntoViewMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clip1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (UNLIKELY(info.Length() <= 0)) {
            impl->clip();
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[0]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("clip", "CanvasRenderingContext2D", "parameter 1 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    impl->clip(winding);
}

static void clip2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("clip", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            impl->clip(path);
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[1]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("clip", "CanvasRenderingContext2D", "parameter 2 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    impl->clip(path, winding);
}

static void clipMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clip", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            clip1Method(info);
            return;
        }
        break;
    case 1:
        if (info[0]->IsUndefined()) {
            clip1Method(info);
            return;
        }
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (V8Path2D::hasInstance(info[0], isolate)) {
                clip2Method(info);
                return;
            }
        }
        if (true) {
            clip1Method(info);
            return;
        }
        break;
    case 2:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                clip2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(0, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void clipMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::clipMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isPointInPath1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        if (UNLIKELY(info.Length() <= 2)) {
            v8SetReturnValueBool(info, impl->isPointInPath(x, y));
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[2]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("isPointInPath", "CanvasRenderingContext2D", "parameter 3 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isPointInPath(x, y, winding));
}

static void isPointInPath2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    float x;
    float y;
    V8StringResource<> winding;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isPointInPath", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        if (UNLIKELY(info.Length() <= 3)) {
            v8SetReturnValueBool(info, impl->isPointInPath(path, x, y));
            return;
        }
        TOSTRING_VOID_INTERNAL(winding, info[3]);
        String string = winding;
        if (!(string == "nonzero" || string == "evenodd")) {
            throwTypeError(ExceptionMessages::failedToExecute("isPointInPath", "CanvasRenderingContext2D", "parameter 4 ('" + string + "') is not a valid enum value."), info.GetIsolate());
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isPointInPath(path, x, y, winding));
}

static void isPointInPathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInPath", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(4, info.Length())) {
    case 2:
        if (true) {
            isPointInPath1Method(info);
            return;
        }
        break;
    case 3:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (V8Path2D::hasInstance(info[0], isolate)) {
                isPointInPath2Method(info);
                return;
            }
        }
        if (true) {
            isPointInPath1Method(info);
            return;
        }
        break;
    case 4:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                isPointInPath2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void isPointInPathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isPointInPathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isPointInStroke1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
    }
    v8SetReturnValueBool(info, impl->isPointInStroke(x, y));
}

static void isPointInStroke2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Path2D* path;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isPointInStroke", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(path, V8Path2D::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    v8SetReturnValueBool(info, impl->isPointInStroke(path, x, y));
}

static void isPointInStrokeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInStroke", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(3, info.Length())) {
    case 2:
        if (true) {
            isPointInStroke1Method(info);
            return;
        }
        break;
    case 3:
        if (RuntimeEnabledFeatures::path2DEnabled()) {
            if (true) {
                isPointInStroke2Method(info);
                return;
            }
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void isPointInStrokeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isPointInStrokeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void fillTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeErrorForMethod("fillText", "CanvasRenderingContext2D", 3, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> text;
    float x;
    float y;
    float maxWidth;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TOSTRING_VOID_INTERNAL(text, info[0]);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        if (UNLIKELY(info.Length() <= 3)) {
            impl->fillText(text, x, y);
            return;
        }
        TONATIVE_VOID_INTERNAL(maxWidth, static_cast<float>(info[3]->NumberValue()));
    }
    impl->fillText(text, x, y, maxWidth);
}

static void fillTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void strokeTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeErrorForMethod("strokeText", "CanvasRenderingContext2D", 3, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> text;
    float x;
    float y;
    float maxWidth;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TOSTRING_VOID_INTERNAL(text, info[0]);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        if (UNLIKELY(info.Length() <= 3)) {
            impl->strokeText(text, x, y);
            return;
        }
        TONATIVE_VOID_INTERNAL(maxWidth, static_cast<float>(info[3]->NumberValue()));
    }
    impl->strokeText(text, x, y, maxWidth);
}

static void strokeTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void measureTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("measureText", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> text;
    {
        TOSTRING_VOID_INTERNAL(text, info[0]);
    }
    v8SetReturnValue(info, impl->measureText(text));
}

static void measureTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::measureTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawImage1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLImageElement* image;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLImageElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->drawImage(image, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLImageElement* image;
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLImageElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[4]->NumberValue()));
    }
    impl->drawImage(image, x, y, width, height, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLImageElement* image;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLImageElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dw, static_cast<float>(info[7]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dh, static_cast<float>(info[8]->NumberValue()));
    }
    impl->drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLCanvasElement* canvas;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLCanvasElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->drawImage(canvas, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLCanvasElement* canvas;
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLCanvasElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[4]->NumberValue()));
    }
    impl->drawImage(canvas, x, y, width, height, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage6Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLCanvasElement* canvas;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLCanvasElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dw, static_cast<float>(info[7]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dh, static_cast<float>(info[8]->NumberValue()));
    }
    impl->drawImage(canvas, sx, sy, sw, sh, dx, dy, dw, dh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage7Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLVideoElement* video;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLVideoElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(video, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->drawImage(video, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage8Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLVideoElement* video;
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLVideoElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(video, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[4]->NumberValue()));
    }
    impl->drawImage(video, x, y, width, height, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage9Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLVideoElement* video;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8HTMLVideoElement::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(video, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dw, static_cast<float>(info[7]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dh, static_cast<float>(info[8]->NumberValue()));
    }
    impl->drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage10Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageBitmap* imageBitmap;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageBitmap::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ImageBitmap'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(imageBitmap, V8ImageBitmap::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->drawImage(imageBitmap, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage11Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageBitmap* imageBitmap;
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageBitmap::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ImageBitmap'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(imageBitmap, V8ImageBitmap::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[4]->NumberValue()));
    }
    impl->drawImage(imageBitmap, x, y, width, height, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage12Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageBitmap* imageBitmap;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageBitmap::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ImageBitmap'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(imageBitmap, V8ImageBitmap::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dw, static_cast<float>(info[7]->NumberValue()));
        TONATIVE_VOID_INTERNAL(dh, static_cast<float>(info[8]->NumberValue()));
    }
    impl->drawImage(imageBitmap, sx, sy, sw, sh, dx, dy, dw, dh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(9, info.Length())) {
    case 3:
        if (V8HTMLImageElement::hasInstance(info[0], isolate)) {
            drawImage1Method(info);
            return;
        }
        if (V8HTMLCanvasElement::hasInstance(info[0], isolate)) {
            drawImage4Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[0], isolate)) {
            drawImage7Method(info);
            return;
        }
        if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
            if (V8ImageBitmap::hasInstance(info[0], isolate)) {
                drawImage10Method(info);
                return;
            }
        }
        break;
    case 5:
        if (V8HTMLImageElement::hasInstance(info[0], isolate)) {
            drawImage2Method(info);
            return;
        }
        if (V8HTMLCanvasElement::hasInstance(info[0], isolate)) {
            drawImage5Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[0], isolate)) {
            drawImage8Method(info);
            return;
        }
        if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
            if (V8ImageBitmap::hasInstance(info[0], isolate)) {
                drawImage11Method(info);
                return;
            }
        }
        break;
    case 9:
        if (V8HTMLImageElement::hasInstance(info[0], isolate)) {
            drawImage3Method(info);
            return;
        }
        if (V8HTMLCanvasElement::hasInstance(info[0], isolate)) {
            drawImage6Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[0], isolate)) {
            drawImage9Method(info);
            return;
        }
        if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
            if (V8ImageBitmap::hasInstance(info[0], isolate)) {
                drawImage12Method(info);
                return;
            }
        }
        break;
    default:
        if (info.Length() >= 3) {
            throwArityTypeError(exceptionState, "[3, 5, 9]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void drawImageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::drawImageMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createImageData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageData* imagedata;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageData::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("createImageData", "CanvasRenderingContext2D", "parameter 1 is not of type 'ImageData'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(imagedata, V8ImageData::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValue(info, impl->createImageData(imagedata));
}

static void createImageData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float sw;
    float sh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[0]->NumberValue()));
        if (!std::isfinite(sw)) {
            exceptionState.throwTypeError("float parameter 1 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(sh)) {
            exceptionState.throwTypeError("float parameter 2 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<ImageData> result = impl->createImageData(sw, sh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createImageData", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            createImageData1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            createImageData2Method(info);
            return;
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void createImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float sx;
    float sy;
    float sw;
    float sh;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[0]->NumberValue()));
        if (!std::isfinite(sx)) {
            exceptionState.throwTypeError("float parameter 1 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(sy)) {
            exceptionState.throwTypeError("float parameter 2 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[2]->NumberValue()));
        if (!std::isfinite(sw)) {
            exceptionState.throwTypeError("float parameter 3 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[3]->NumberValue()));
        if (!std::isfinite(sh)) {
            exceptionState.throwTypeError("float parameter 4 is non-finite.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<ImageData> result = impl->getImageData(sx, sy, sw, sh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void getImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void putImageData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageData* imagedata;
    float dx;
    float dy;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageData::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "parameter 1 is not of type 'ImageData'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(imagedata, V8ImageData::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(dx)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 2 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[2]->NumberValue()));
        if (!std::isfinite(dy)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 3 is non-finite."), info.GetIsolate());
            return;
        }
    }
    impl->putImageData(imagedata, dx, dy);
}

static void putImageData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    ImageData* imagedata;
    float dx;
    float dy;
    float dirtyX;
    float dirtyY;
    float dirtyWidth;
    float dirtyHeight;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !V8ImageData::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "parameter 1 is not of type 'ImageData'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(imagedata, V8ImageData::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[1]->NumberValue()));
        if (!std::isfinite(dx)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 2 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[2]->NumberValue()));
        if (!std::isfinite(dy)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 3 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dirtyX, static_cast<float>(info[3]->NumberValue()));
        if (!std::isfinite(dirtyX)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 4 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dirtyY, static_cast<float>(info[4]->NumberValue()));
        if (!std::isfinite(dirtyY)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 5 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dirtyWidth, static_cast<float>(info[5]->NumberValue()));
        if (!std::isfinite(dirtyWidth)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 6 is non-finite."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(dirtyHeight, static_cast<float>(info[6]->NumberValue()));
        if (!std::isfinite(dirtyHeight)) {
            throwTypeError(ExceptionMessages::failedToExecute("putImageData", "CanvasRenderingContext2D", "float parameter 7 is non-finite."), info.GetIsolate());
            return;
        }
    }
    impl->putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
}

static void putImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "putImageData", "CanvasRenderingContext2D", info.Holder(), isolate);
    switch (std::min(7, info.Length())) {
    case 3:
        if (true) {
            putImageData1Method(info);
            return;
        }
        break;
    case 7:
        if (true) {
            putImageData2Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 3) {
            throwArityTypeError(exceptionState, "[3, 7]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void putImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::putImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isContextLostMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    v8SetReturnValueBool(info, impl->isContextLost());
}

static void isContextLostMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isContextLostMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getContextAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    v8SetReturnValue(info, impl->getContextAttributes());
}

static void getContextAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getContextAttributesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setLineDashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setLineDash", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    Vector<float> dash;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(dash, toNativeArray<float>(info[0], 1, info.GetIsolate()));
    }
    impl->setLineDash(dash);
}

static void setLineDashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setLineDashMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getLineDashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    v8SetReturnValue(info, v8Array(impl->getLineDash(), info.Holder(), info.GetIsolate()));
}

static void getLineDashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getLineDashMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setAlphaMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setAlpha", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[0]->NumberValue()));
    }
    impl->setAlpha(alpha);
}

static void setAlphaMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetAlpha);
    CanvasRenderingContext2DV8Internal::setAlphaMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setCompositeOperationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setCompositeOperation", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> compositeOperation;
    {
        TOSTRING_VOID_INTERNAL(compositeOperation, info[0]);
    }
    impl->setCompositeOperation(compositeOperation);
}

static void setCompositeOperationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetCompositeOperation);
    CanvasRenderingContext2DV8Internal::setCompositeOperationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setLineWidthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setLineWidth", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float width;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
    }
    impl->setLineWidth(width);
}

static void setLineWidthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetLineWidth);
    CanvasRenderingContext2DV8Internal::setLineWidthMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setLineCapMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setLineCap", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> cap;
    {
        TOSTRING_VOID_INTERNAL(cap, info[0]);
    }
    impl->setLineCap(cap);
}

static void setLineCapMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetLineCap);
    CanvasRenderingContext2DV8Internal::setLineCapMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setLineJoinMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setLineJoin", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> join;
    {
        TOSTRING_VOID_INTERNAL(join, info[0]);
    }
    impl->setLineJoin(join);
}

static void setLineJoinMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetLineJoin);
    CanvasRenderingContext2DV8Internal::setLineJoinMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setMiterLimitMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("setMiterLimit", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float limit;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(limit, static_cast<float>(info[0]->NumberValue()));
    }
    impl->setMiterLimit(limit);
}

static void setMiterLimitMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DSetMiterLimit);
    CanvasRenderingContext2DV8Internal::setMiterLimitMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->clearShadow();
}

static void clearShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DClearShadow);
    CanvasRenderingContext2DV8Internal::clearShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setStrokeColor1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> color;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TOSTRING_VOID_INTERNAL(color, info[0]);
        if (UNLIKELY(info.Length() <= 1)) {
            impl->setStrokeColor(color);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[1]->NumberValue()));
    }
    impl->setStrokeColor(color, alpha);
}

static void setStrokeColor2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float grayLevel;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(grayLevel, static_cast<float>(info[0]->NumberValue()));
        if (UNLIKELY(info.Length() <= 1)) {
            impl->setStrokeColor(grayLevel);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[1]->NumberValue()));
    }
    impl->setStrokeColor(grayLevel, alpha);
}

static void setStrokeColor3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float r;
    float g;
    float b;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(r, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(g, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(b, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[3]->NumberValue()));
    }
    impl->setStrokeColor(r, g, b, a);
}

static void setStrokeColor4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float c;
    float m;
    float y;
    float k;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(c, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(m, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(k, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[4]->NumberValue()));
    }
    impl->setStrokeColor(c, m, y, k, a);
}

static void setStrokeColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setStrokeColor", "CanvasRenderingContext2D", info.Holder(), isolate);
    UseCounter::count(callingExecutionContext(isolate), UseCounter::CanvasRenderingContext2DSetStrokeColor);
    switch (std::min(5, info.Length())) {
    case 1:
        if (info[0]->IsNumber()) {
            setStrokeColor2Method(info);
            return;
        }
        if (true) {
            setStrokeColor1Method(info);
            return;
        }
        if (true) {
            setStrokeColor2Method(info);
            return;
        }
        break;
    case 2:
        if (info[0]->IsNumber()) {
            setStrokeColor2Method(info);
            return;
        }
        if (true) {
            setStrokeColor1Method(info);
            return;
        }
        if (true) {
            setStrokeColor2Method(info);
            return;
        }
        break;
    case 4:
        if (true) {
            setStrokeColor3Method(info);
            return;
        }
        break;
    case 5:
        if (true) {
            setStrokeColor4Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 1) {
            throwArityTypeError(exceptionState, "[1, 2, 4, 5]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void setStrokeColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setStrokeColorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setFillColor1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    V8StringResource<> color;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TOSTRING_VOID_INTERNAL(color, info[0]);
        if (UNLIKELY(info.Length() <= 1)) {
            impl->setFillColor(color);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[1]->NumberValue()));
    }
    impl->setFillColor(color, alpha);
}

static void setFillColor2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float grayLevel;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(grayLevel, static_cast<float>(info[0]->NumberValue()));
        if (UNLIKELY(info.Length() <= 1)) {
            impl->setFillColor(grayLevel);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[1]->NumberValue()));
    }
    impl->setFillColor(grayLevel, alpha);
}

static void setFillColor3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float r;
    float g;
    float b;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(r, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(g, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(b, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[3]->NumberValue()));
    }
    impl->setFillColor(r, g, b, a);
}

static void setFillColor4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float c;
    float m;
    float y;
    float k;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(c, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(m, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(k, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[4]->NumberValue()));
    }
    impl->setFillColor(c, m, y, k, a);
}

static void setFillColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setFillColor", "CanvasRenderingContext2D", info.Holder(), isolate);
    UseCounter::count(callingExecutionContext(isolate), UseCounter::CanvasRenderingContext2DSetFillColor);
    switch (std::min(5, info.Length())) {
    case 1:
        if (info[0]->IsNumber()) {
            setFillColor2Method(info);
            return;
        }
        if (true) {
            setFillColor1Method(info);
            return;
        }
        if (true) {
            setFillColor2Method(info);
            return;
        }
        break;
    case 2:
        if (info[0]->IsNumber()) {
            setFillColor2Method(info);
            return;
        }
        if (true) {
            setFillColor1Method(info);
            return;
        }
        if (true) {
            setFillColor2Method(info);
            return;
        }
        break;
    case 4:
        if (true) {
            setFillColor3Method(info);
            return;
        }
        break;
    case 5:
        if (true) {
            setFillColor4Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 1) {
            throwArityTypeError(exceptionState, "[1, 2, 4, 5]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void setFillColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setFillColorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawImageFromRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("drawImageFromRect", "CanvasRenderingContext2D", 1, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    HTMLImageElement* image;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    V8StringResource<> compositeOperation;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8HTMLImageElement::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("drawImageFromRect", "CanvasRenderingContext2D", "parameter 1 is not of type 'HTMLImageElement'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (UNLIKELY(info.Length() <= 1)) {
            impl->drawImageFromRect(image);
            return;
        }
        TONATIVE_VOID_INTERNAL(sx, static_cast<float>(info[1]->NumberValue()));
        if (UNLIKELY(info.Length() <= 2)) {
            impl->drawImageFromRect(image, sx);
            return;
        }
        TONATIVE_VOID_INTERNAL(sy, static_cast<float>(info[2]->NumberValue()));
        if (UNLIKELY(info.Length() <= 3)) {
            impl->drawImageFromRect(image, sx, sy);
            return;
        }
        TONATIVE_VOID_INTERNAL(sw, static_cast<float>(info[3]->NumberValue()));
        if (UNLIKELY(info.Length() <= 4)) {
            impl->drawImageFromRect(image, sx, sy, sw);
            return;
        }
        TONATIVE_VOID_INTERNAL(sh, static_cast<float>(info[4]->NumberValue()));
        if (UNLIKELY(info.Length() <= 5)) {
            impl->drawImageFromRect(image, sx, sy, sw, sh);
            return;
        }
        TONATIVE_VOID_INTERNAL(dx, static_cast<float>(info[5]->NumberValue()));
        if (UNLIKELY(info.Length() <= 6)) {
            impl->drawImageFromRect(image, sx, sy, sw, sh, dx);
            return;
        }
        TONATIVE_VOID_INTERNAL(dy, static_cast<float>(info[6]->NumberValue()));
        if (UNLIKELY(info.Length() <= 7)) {
            impl->drawImageFromRect(image, sx, sy, sw, sh, dx, dy);
            return;
        }
        TONATIVE_VOID_INTERNAL(dw, static_cast<float>(info[7]->NumberValue()));
        if (UNLIKELY(info.Length() <= 8)) {
            impl->drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw);
            return;
        }
        TONATIVE_VOID_INTERNAL(dh, static_cast<float>(info[8]->NumberValue()));
        if (UNLIKELY(info.Length() <= 9)) {
            impl->drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh);
            return;
        }
        TOSTRING_VOID_INTERNAL(compositeOperation, info[9]);
    }
    impl->drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh, compositeOperation);
}

static void drawImageFromRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    UseCounter::count(callingExecutionContext(info.GetIsolate()), UseCounter::CanvasRenderingContext2DDrawImageFromRect);
    CanvasRenderingContext2DV8Internal::drawImageFromRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void setShadow1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float width;
    float height;
    float blur;
    V8StringResource<> color;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blur, static_cast<float>(info[2]->NumberValue()));
        if (UNLIKELY(info.Length() <= 3)) {
            impl->setShadow(width, height, blur);
            return;
        }
        TOSTRING_VOID_INTERNAL(color, info[3]);
        if (UNLIKELY(info.Length() <= 4)) {
            impl->setShadow(width, height, blur, color);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[4]->NumberValue()));
    }
    impl->setShadow(width, height, blur, color, alpha);
}

static void setShadow2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float width;
    float height;
    float blur;
    float grayLevel;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blur, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(grayLevel, static_cast<float>(info[3]->NumberValue()));
        if (UNLIKELY(info.Length() <= 4)) {
            impl->setShadow(width, height, blur, grayLevel);
            return;
        }
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[4]->NumberValue()));
    }
    impl->setShadow(width, height, blur, grayLevel, alpha);
}

static void setShadow3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float width;
    float height;
    float blur;
    float r;
    float g;
    float b;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blur, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(r, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(g, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(b, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[6]->NumberValue()));
    }
    impl->setShadow(width, height, blur, r, g, b, a);
}

static void setShadow4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float width;
    float height;
    float blur;
    float c;
    float m;
    float y;
    float k;
    float a;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blur, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(c, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(m, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(k, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(a, static_cast<float>(info[7]->NumberValue()));
    }
    impl->setShadow(width, height, blur, c, m, y, k, a);
}

static void setShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setShadow", "CanvasRenderingContext2D", info.Holder(), isolate);
    UseCounter::count(callingExecutionContext(isolate), UseCounter::CanvasRenderingContext2DSetShadow);
    switch (std::min(8, info.Length())) {
    case 3:
        if (true) {
            setShadow1Method(info);
            return;
        }
        break;
    case 4:
        if (info[3]->IsUndefined()) {
            setShadow1Method(info);
            return;
        }
        if (info[3]->IsNumber()) {
            setShadow2Method(info);
            return;
        }
        if (true) {
            setShadow1Method(info);
            return;
        }
        if (true) {
            setShadow2Method(info);
            return;
        }
        break;
    case 5:
        if (info[3]->IsUndefined()) {
            setShadow1Method(info);
            return;
        }
        if (info[3]->IsNumber()) {
            setShadow2Method(info);
            return;
        }
        if (true) {
            setShadow1Method(info);
            return;
        }
        if (true) {
            setShadow2Method(info);
            return;
        }
        break;
    case 7:
        if (true) {
            setShadow3Method(info);
            return;
        }
        break;
    case 8:
        if (true) {
            setShadow4Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 3) {
            throwArityTypeError(exceptionState, "[3, 4, 5, 7, 8]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void setShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void closePathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    impl->closePath();
}

static void closePathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::closePathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void moveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("moveTo", "CanvasRenderingContext2D", 2, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
    }
    impl->moveTo(x, y);
}

static void moveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::moveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("lineTo", "CanvasRenderingContext2D", 2, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
    }
    impl->lineTo(x, y);
}

static void lineToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::lineToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void quadraticCurveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("quadraticCurveTo", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float cpx;
    float cpy;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(cpx, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(cpy, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[3]->NumberValue()));
    }
    impl->quadraticCurveTo(cpx, cpy, x, y);
}

static void quadraticCurveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::quadraticCurveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bezierCurveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 6)) {
        throwMinimumArityTypeErrorForMethod("bezierCurveTo", "CanvasRenderingContext2D", 6, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float cp1x;
    float cp1y;
    float cp2x;
    float cp2y;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(cp1x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(cp1y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(cp2x, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(cp2y, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[5]->NumberValue()));
    }
    impl->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

static void bezierCurveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::bezierCurveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void arcToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "arcTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x1;
    float y1;
    float x2;
    float y2;
    float radius;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x1, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y1, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(x2, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y2, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(radius, static_cast<float>(info[4]->NumberValue()));
    }
    impl->arcTo(x1, y1, x2, y2, radius, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void arcToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::arcToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void rectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("rect", "CanvasRenderingContext2D", 4, info.Length(), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(height, static_cast<float>(info[3]->NumberValue()));
    }
    impl->rect(x, y, width, height);
}

static void rectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::rectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void arcMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "arc", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float radius;
    float startAngle;
    float endAngle;
    bool anticlockwise;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(radius, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(startAngle, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(endAngle, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(anticlockwise, info[5]->BooleanValue());
    }
    impl->arc(x, y, radius, startAngle, endAngle, anticlockwise, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void arcMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::arcMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void ellipseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "ellipse", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        throwMinimumArityTypeError(exceptionState, 7, info.Length());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toNative(info.Holder());
    float x;
    float y;
    float radiusX;
    float radiusY;
    float rotation;
    float startAngle;
    float endAngle;
    bool anticlockwise;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(radiusX, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(radiusY, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(rotation, static_cast<float>(info[4]->NumberValue()));
        TONATIVE_VOID_INTERNAL(startAngle, static_cast<float>(info[5]->NumberValue()));
        TONATIVE_VOID_INTERNAL(endAngle, static_cast<float>(info[6]->NumberValue()));
        TONATIVE_VOID_INTERNAL(anticlockwise, info[7]->BooleanValue());
    }
    impl->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void ellipseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::ellipseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

} // namespace CanvasRenderingContext2DV8Internal

static const V8DOMConfiguration::AttributeConfiguration V8CanvasRenderingContext2DAttributes[] = {
    {"canvas", CanvasRenderingContext2DV8Internal::canvasAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"globalAlpha", CanvasRenderingContext2DV8Internal::globalAlphaAttributeGetterCallback, CanvasRenderingContext2DV8Internal::globalAlphaAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"globalCompositeOperation", CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeGetterCallback, CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"webkitImageSmoothingEnabled", CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeGetterCallback, CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"imageSmoothingEnabled", CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeGetterCallback, CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"strokeStyle", CanvasRenderingContext2DV8Internal::strokeStyleAttributeGetterCallback, CanvasRenderingContext2DV8Internal::strokeStyleAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"fillStyle", CanvasRenderingContext2DV8Internal::fillStyleAttributeGetterCallback, CanvasRenderingContext2DV8Internal::fillStyleAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"shadowOffsetX", CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"shadowOffsetY", CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"shadowBlur", CanvasRenderingContext2DV8Internal::shadowBlurAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowBlurAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"shadowColor", CanvasRenderingContext2DV8Internal::shadowColorAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowColorAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"lineWidth", CanvasRenderingContext2DV8Internal::lineWidthAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineWidthAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"lineCap", CanvasRenderingContext2DV8Internal::lineCapAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineCapAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"lineJoin", CanvasRenderingContext2DV8Internal::lineJoinAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineJoinAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"miterLimit", CanvasRenderingContext2DV8Internal::miterLimitAttributeGetterCallback, CanvasRenderingContext2DV8Internal::miterLimitAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"lineDashOffset", CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"font", CanvasRenderingContext2DV8Internal::fontAttributeGetterCallback, CanvasRenderingContext2DV8Internal::fontAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"textAlign", CanvasRenderingContext2DV8Internal::textAlignAttributeGetterCallback, CanvasRenderingContext2DV8Internal::textAlignAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"textBaseline", CanvasRenderingContext2DV8Internal::textBaselineAttributeGetterCallback, CanvasRenderingContext2DV8Internal::textBaselineAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const V8DOMConfiguration::MethodConfiguration V8CanvasRenderingContext2DMethods[] = {
    {"save", CanvasRenderingContext2DV8Internal::saveMethodCallback, 0, 0},
    {"restore", CanvasRenderingContext2DV8Internal::restoreMethodCallback, 0, 0},
    {"scale", CanvasRenderingContext2DV8Internal::scaleMethodCallback, 0, 2},
    {"rotate", CanvasRenderingContext2DV8Internal::rotateMethodCallback, 0, 1},
    {"translate", CanvasRenderingContext2DV8Internal::translateMethodCallback, 0, 2},
    {"transform", CanvasRenderingContext2DV8Internal::transformMethodCallback, 0, 6},
    {"setTransform", CanvasRenderingContext2DV8Internal::setTransformMethodCallback, 0, 6},
    {"resetTransform", CanvasRenderingContext2DV8Internal::resetTransformMethodCallback, 0, 0},
    {"createLinearGradient", CanvasRenderingContext2DV8Internal::createLinearGradientMethodCallback, 0, 4},
    {"createRadialGradient", CanvasRenderingContext2DV8Internal::createRadialGradientMethodCallback, 0, 6},
    {"createPattern", CanvasRenderingContext2DV8Internal::createPatternMethodCallback, 0, 2},
    {"clearRect", CanvasRenderingContext2DV8Internal::clearRectMethodCallback, 0, 4},
    {"fillRect", CanvasRenderingContext2DV8Internal::fillRectMethodCallback, 0, 4},
    {"strokeRect", CanvasRenderingContext2DV8Internal::strokeRectMethodCallback, 0, 4},
    {"beginPath", CanvasRenderingContext2DV8Internal::beginPathMethodCallback, 0, 0},
    {"fill", CanvasRenderingContext2DV8Internal::fillMethodCallback, 0, 0},
    {"stroke", CanvasRenderingContext2DV8Internal::strokeMethodCallback, 0, 0},
    {"drawFocusIfNeeded", CanvasRenderingContext2DV8Internal::drawFocusIfNeededMethodCallback, 0, 1},
    {"clip", CanvasRenderingContext2DV8Internal::clipMethodCallback, 0, 0},
    {"isPointInPath", CanvasRenderingContext2DV8Internal::isPointInPathMethodCallback, 0, 2},
    {"isPointInStroke", CanvasRenderingContext2DV8Internal::isPointInStrokeMethodCallback, 0, 2},
    {"fillText", CanvasRenderingContext2DV8Internal::fillTextMethodCallback, 0, 3},
    {"strokeText", CanvasRenderingContext2DV8Internal::strokeTextMethodCallback, 0, 3},
    {"measureText", CanvasRenderingContext2DV8Internal::measureTextMethodCallback, 0, 1},
    {"drawImage", CanvasRenderingContext2DV8Internal::drawImageMethodCallback, 0, 3},
    {"createImageData", CanvasRenderingContext2DV8Internal::createImageDataMethodCallback, 0, 1},
    {"getImageData", CanvasRenderingContext2DV8Internal::getImageDataMethodCallback, 0, 4},
    {"putImageData", CanvasRenderingContext2DV8Internal::putImageDataMethodCallback, 0, 3},
    {"getContextAttributes", CanvasRenderingContext2DV8Internal::getContextAttributesMethodCallback, 0, 0},
    {"setLineDash", CanvasRenderingContext2DV8Internal::setLineDashMethodCallback, 0, 1},
    {"getLineDash", CanvasRenderingContext2DV8Internal::getLineDashMethodCallback, 0, 0},
    {"setAlpha", CanvasRenderingContext2DV8Internal::setAlphaMethodCallback, 0, 1},
    {"setCompositeOperation", CanvasRenderingContext2DV8Internal::setCompositeOperationMethodCallback, 0, 1},
    {"setLineWidth", CanvasRenderingContext2DV8Internal::setLineWidthMethodCallback, 0, 1},
    {"setLineCap", CanvasRenderingContext2DV8Internal::setLineCapMethodCallback, 0, 1},
    {"setLineJoin", CanvasRenderingContext2DV8Internal::setLineJoinMethodCallback, 0, 1},
    {"setMiterLimit", CanvasRenderingContext2DV8Internal::setMiterLimitMethodCallback, 0, 1},
    {"clearShadow", CanvasRenderingContext2DV8Internal::clearShadowMethodCallback, 0, 0},
    {"setStrokeColor", CanvasRenderingContext2DV8Internal::setStrokeColorMethodCallback, 0, 1},
    {"setFillColor", CanvasRenderingContext2DV8Internal::setFillColorMethodCallback, 0, 1},
    {"drawImageFromRect", CanvasRenderingContext2DV8Internal::drawImageFromRectMethodCallback, 0, 1},
    {"setShadow", CanvasRenderingContext2DV8Internal::setShadowMethodCallback, 0, 3},
    {"closePath", CanvasRenderingContext2DV8Internal::closePathMethodCallback, 0, 0},
    {"moveTo", CanvasRenderingContext2DV8Internal::moveToMethodCallback, 0, 2},
    {"lineTo", CanvasRenderingContext2DV8Internal::lineToMethodCallback, 0, 2},
    {"quadraticCurveTo", CanvasRenderingContext2DV8Internal::quadraticCurveToMethodCallback, 0, 4},
    {"bezierCurveTo", CanvasRenderingContext2DV8Internal::bezierCurveToMethodCallback, 0, 6},
    {"arcTo", CanvasRenderingContext2DV8Internal::arcToMethodCallback, 0, 5},
    {"rect", CanvasRenderingContext2DV8Internal::rectMethodCallback, 0, 4},
    {"arc", CanvasRenderingContext2DV8Internal::arcMethodCallback, 0, 5},
    {"ellipse", CanvasRenderingContext2DV8Internal::ellipseMethodCallback, 0, 7},
};

static void configureV8CanvasRenderingContext2DTemplate(v8::Handle<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(functionTemplate, "CanvasRenderingContext2D", v8::Local<v8::FunctionTemplate>(), V8CanvasRenderingContext2D::internalFieldCount,
        V8CanvasRenderingContext2DAttributes, WTF_ARRAY_LENGTH(V8CanvasRenderingContext2DAttributes),
        0, 0,
        V8CanvasRenderingContext2DMethods, WTF_ARRAY_LENGTH(V8CanvasRenderingContext2DMethods),
        isolate);
    v8::Local<v8::ObjectTemplate> instanceTemplate ALLOW_UNUSED = functionTemplate->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototypeTemplate ALLOW_UNUSED = functionTemplate->PrototypeTemplate();
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        static const V8DOMConfiguration::AttributeConfiguration attributeConfiguration =\
        {"currentTransform", CanvasRenderingContext2DV8Internal::currentTransformAttributeGetterCallback, CanvasRenderingContext2DV8Internal::currentTransformAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */};
        V8DOMConfiguration::installAttribute(instanceTemplate, prototypeTemplate, attributeConfiguration, isolate);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        prototypeTemplate->Set(v8AtomicString(isolate, "scrollPathIntoView"), v8::FunctionTemplate::New(isolate, CanvasRenderingContext2DV8Internal::scrollPathIntoViewMethodCallback, v8Undefined(), defaultSignature, 0));
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        prototypeTemplate->Set(v8AtomicString(isolate, "isContextLost"), v8::FunctionTemplate::New(isolate, CanvasRenderingContext2DV8Internal::isContextLostMethodCallback, v8Undefined(), defaultSignature, 0));
    }

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Handle<v8::FunctionTemplate> V8CanvasRenderingContext2D::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), configureV8CanvasRenderingContext2DTemplate);
}

bool V8CanvasRenderingContext2D::hasInstance(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Handle<v8::Object> V8CanvasRenderingContext2D::findInstanceInPrototypeChain(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

CanvasRenderingContext2D* V8CanvasRenderingContext2D::toNativeWithTypeCheck(v8::Isolate* isolate, v8::Handle<v8::Value> value)
{
    return hasInstance(value, isolate) ? fromInternalPointer(v8::Handle<v8::Object>::Cast(value)->GetAlignedPointerFromInternalField(v8DOMWrapperObjectIndex)) : 0;
}

v8::Handle<v8::Object> wrap(CanvasRenderingContext2D* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8CanvasRenderingContext2D>(impl, isolate));
    return V8CanvasRenderingContext2D::createWrapper(impl, creationContext, isolate);
}

v8::Handle<v8::Object> V8CanvasRenderingContext2D::createWrapper(PassRefPtrWillBeRawPtr<CanvasRenderingContext2D> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8CanvasRenderingContext2D>(impl.get(), isolate));
    if (ScriptWrappable::wrapperCanBeStoredInObject(impl.get())) {
        const WrapperTypeInfo* actualInfo = ScriptWrappable::fromObject(impl.get())->typeInfo();
        // Might be a XXXConstructor::wrapperTypeInfo instead of an XXX::wrapperTypeInfo. These will both have
        // the same object de-ref functions, though, so use that as the basis of the check.
        RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(actualInfo->derefObjectFunction == wrapperTypeInfo.derefObjectFunction);
    }

    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &wrapperTypeInfo, toInternalPointer(impl.get()), isolate);
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    installPerContextEnabledProperties(wrapper, impl.get(), isolate);
    V8DOMWrapper::associateObjectWithWrapper<V8CanvasRenderingContext2D>(impl, &wrapperTypeInfo, wrapper, isolate, WrapperConfiguration::Independent);
    return wrapper;
}

void V8CanvasRenderingContext2D::derefObject(void* object)
{
#if !ENABLE(OILPAN)
    fromInternalPointer(object)->deref();
#endif // !ENABLE(OILPAN)
}

template<>
v8::Handle<v8::Value> toV8NoInline(CanvasRenderingContext2D* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    return toV8(impl, creationContext, isolate);
}

} // namespace WebCore
