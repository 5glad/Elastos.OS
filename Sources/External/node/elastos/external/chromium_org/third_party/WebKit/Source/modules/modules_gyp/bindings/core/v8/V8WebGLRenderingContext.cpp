// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8WebGLRenderingContext.h"

#include "bindings/core/v8/V8HTMLCanvasElement.h"
#include "bindings/core/v8/V8HTMLImageElement.h"
#include "bindings/core/v8/V8HTMLVideoElement.h"
#include "bindings/core/v8/V8ImageData.h"
#include "bindings/core/v8/V8WebGLActiveInfo.h"
#include "bindings/core/v8/V8WebGLBuffer.h"
#include "bindings/core/v8/V8WebGLContextAttributes.h"
#include "bindings/core/v8/V8WebGLFramebuffer.h"
#include "bindings/core/v8/V8WebGLProgram.h"
#include "bindings/core/v8/V8WebGLRenderbuffer.h"
#include "bindings/core/v8/V8WebGLShader.h"
#include "bindings/core/v8/V8WebGLShaderPrecisionFormat.h"
#include "bindings/core/v8/V8WebGLTexture.h"
#include "bindings/core/v8/V8WebGLUniformLocation.h"
#include "bindings/v8/ExceptionState.h"
#include "bindings/v8/ScriptValue.h"
#include "bindings/v8/V8DOMConfiguration.h"
#include "bindings/v8/V8HiddenValue.h"
#include "bindings/v8/V8ObjectConstructor.h"
#include "bindings/v8/custom/V8ArrayBufferCustom.h"
#include "bindings/v8/custom/V8ArrayBufferViewCustom.h"
#include "bindings/v8/custom/V8Float32ArrayCustom.h"
#include "bindings/v8/custom/V8Int32ArrayCustom.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace WebCore {

static void initializeScriptWrappableForInterface(WebGLRenderingContext* object)
{
    if (ScriptWrappable::wrapperCanBeStoredInObject(object))
        ScriptWrappable::fromObject(object)->setTypeInfo(&V8WebGLRenderingContext::wrapperTypeInfo);
    else
        ASSERT_NOT_REACHED();
}

} // namespace WebCore

void webCoreInitializeScriptWrappableForInterface(WebCore::WebGLRenderingContext* object)
{
    WebCore::initializeScriptWrappableForInterface(object);
}

namespace WebCore {
const WrapperTypeInfo V8WebGLRenderingContext::wrapperTypeInfo = { gin::kEmbedderBlink, V8WebGLRenderingContext::domTemplate, V8WebGLRenderingContext::derefObject, 0, 0, 0, V8WebGLRenderingContext::installPerContextEnabledMethods, 0, WrapperTypeObjectPrototype, WillBeGarbageCollectedObject };

namespace WebGLRenderingContextV8Internal {

template <typename T> void V8_USE(T) { }

static void canvasAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->canvas()), impl);
}

static void canvasAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    WebGLRenderingContextV8Internal::canvasAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawingBufferWidthAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(holder);
    v8SetReturnValueInt(info, impl->drawingBufferWidth());
}

static void drawingBufferWidthAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    WebGLRenderingContextV8Internal::drawingBufferWidthAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawingBufferHeightAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Object> holder = info.Holder();
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(holder);
    v8SetReturnValueInt(info, impl->drawingBufferHeight());
}

static void drawingBufferHeightAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMGetter");
    WebGLRenderingContextV8Internal::drawingBufferHeightAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void activeTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "activeTexture", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned texture;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(texture, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->activeTexture(texture);
}

static void activeTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::activeTextureMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void attachShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("attachShader", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("attachShader", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLShader::hasInstance(info[1], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("attachShader", "WebGLRenderingContext", "parameter 2 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->attachShader(program, shader);
}

static void attachShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::attachShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bindAttribLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bindAttribLocation", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    unsigned index;
    V8StringResource<> name;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[1], exceptionState), exceptionState);
        TOSTRING_VOID_INTERNAL(name, info[2]);
    }
    impl->bindAttribLocation(program, index, name);
}

static void bindAttribLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bindAttribLocationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bindBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bindBuffer", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    WebGLBuffer* buffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLBuffer::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLBuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(buffer, V8WebGLBuffer::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->bindBuffer(target, buffer);
}

static void bindBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bindBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bindFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bindFramebuffer", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    WebGLFramebuffer* framebuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLFramebuffer::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLFramebuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(framebuffer, V8WebGLFramebuffer::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->bindFramebuffer(target, framebuffer);
}

static void bindFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bindFramebufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bindRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bindRenderbuffer", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    WebGLRenderbuffer* renderbuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLRenderbuffer::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLRenderbuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(renderbuffer, V8WebGLRenderbuffer::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->bindRenderbuffer(target, renderbuffer);
}

static void bindRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bindRenderbufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bindTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bindTexture", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    WebGLTexture* texture;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLTexture::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLTexture'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(texture, V8WebGLTexture::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->bindTexture(target, texture);
}

static void bindTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bindTextureMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void blendColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("blendColor", "WebGLRenderingContext", 4, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float red;
    float green;
    float blue;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(red, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(green, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blue, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[3]->NumberValue()));
    }
    impl->blendColor(red, green, blue, alpha);
}

static void blendColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::blendColorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void blendEquationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "blendEquation", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mode;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->blendEquation(mode);
}

static void blendEquationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::blendEquationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void blendEquationSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "blendEquationSeparate", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned modeRGB;
    unsigned modeAlpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(modeRGB, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(modeAlpha, toUInt32(info[1], exceptionState), exceptionState);
    }
    impl->blendEquationSeparate(modeRGB, modeAlpha);
}

static void blendEquationSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::blendEquationSeparateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void blendFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "blendFunc", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned sfactor;
    unsigned dfactor;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(sfactor, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(dfactor, toUInt32(info[1], exceptionState), exceptionState);
    }
    impl->blendFunc(sfactor, dfactor);
}

static void blendFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::blendFuncMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void blendFuncSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "blendFuncSeparate", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned srcRGB;
    unsigned dstRGB;
    unsigned srcAlpha;
    unsigned dstAlpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(srcRGB, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(dstRGB, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(srcAlpha, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(dstAlpha, toUInt32(info[3], exceptionState), exceptionState);
    }
    impl->blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void blendFuncSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::blendFuncSeparateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bufferData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferData", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    long long size;
    unsigned usage;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(size, toInt64(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(usage, toUInt32(info[2], exceptionState), exceptionState);
    }
    impl->bufferData(target, size, usage);
}

static void bufferData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferData", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    ArrayBufferView* data;
    unsigned usage;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !V8ArrayBufferView::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[1]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[1])) : 0);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(usage, toUInt32(info[2], exceptionState), exceptionState);
    }
    impl->bufferData(target, data, usage);
}

static void bufferData3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferData", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    ArrayBuffer* data;
    unsigned usage;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8ArrayBuffer::hasInstance(info[1], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 2 is not of type 'ArrayBuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[1]->IsArrayBuffer() ? V8ArrayBuffer::toNative(v8::Handle<v8::ArrayBuffer>::Cast(info[1])) : 0);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(usage, toUInt32(info[2], exceptionState), exceptionState);
    }
    impl->bufferData(target, data, usage);
}

static void bufferDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferData", "WebGLRenderingContext", info.Holder(), isolate);
    switch (std::min(3, info.Length())) {
    case 3:
        if (isUndefinedOrNull(info[1])) {
            bufferData3Method(info);
            return;
        }
        if (V8ArrayBufferView::hasInstance(info[1], isolate)) {
            bufferData2Method(info);
            return;
        }
        if (V8ArrayBuffer::hasInstance(info[1], isolate)) {
            bufferData3Method(info);
            return;
        }
        if (true) {
            bufferData1Method(info);
            return;
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void bufferDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bufferDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void bufferSubData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferSubData", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    long long offset;
    ArrayBufferView* data;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(offset, toInt64(info[1], exceptionState), exceptionState);
        if (info.Length() > 2 && !V8ArrayBufferView::hasInstance(info[2], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[2]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[2])) : 0);
    }
    impl->bufferSubData(target, offset, data);
}

static void bufferSubData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferSubData", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    long long offset;
    ArrayBuffer* data;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(offset, toInt64(info[1], exceptionState), exceptionState);
        if (info.Length() > 2 && !isUndefinedOrNull(info[2]) && !V8ArrayBuffer::hasInstance(info[2], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[2]->IsArrayBuffer() ? V8ArrayBuffer::toNative(v8::Handle<v8::ArrayBuffer>::Cast(info[2])) : 0);
    }
    impl->bufferSubData(target, offset, data);
}

static void bufferSubDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bufferSubData", "WebGLRenderingContext", info.Holder(), isolate);
    switch (std::min(3, info.Length())) {
    case 3:
        if (isUndefinedOrNull(info[2])) {
            bufferSubData2Method(info);
            return;
        }
        if (V8ArrayBufferView::hasInstance(info[2], isolate)) {
            bufferSubData1Method(info);
            return;
        }
        if (V8ArrayBuffer::hasInstance(info[2], isolate)) {
            bufferSubData2Method(info);
            return;
        }
        break;
    default:
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void bufferSubDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::bufferSubDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void checkFramebufferStatusMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "checkFramebufferStatus", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
    }
    v8SetReturnValueUnsigned(info, impl->checkFramebufferStatus(target));
}

static void checkFramebufferStatusMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::checkFramebufferStatusMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clear", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mask;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mask, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->clear(mask);
}

static void clearMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::clearMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("clearColor", "WebGLRenderingContext", 4, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float red;
    float green;
    float blue;
    float alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(red, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(green, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(blue, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(alpha, static_cast<float>(info[3]->NumberValue()));
    }
    impl->clearColor(red, green, blue, alpha);
}

static void clearColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::clearColorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearDepthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("clearDepth", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float depth;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(depth, static_cast<float>(info[0]->NumberValue()));
    }
    impl->clearDepth(depth);
}

static void clearDepthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::clearDepthMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void clearStencilMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clearStencil", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    int s;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(s, toInt32(info[0], exceptionState), exceptionState);
    }
    impl->clearStencil(s);
}

static void clearStencilMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::clearStencilMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void colorMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("colorMask", "WebGLRenderingContext", 4, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    bool red;
    bool green;
    bool blue;
    bool alpha;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(red, info[0]->BooleanValue());
        TONATIVE_VOID_INTERNAL(green, info[1]->BooleanValue());
        TONATIVE_VOID_INTERNAL(blue, info[2]->BooleanValue());
        TONATIVE_VOID_INTERNAL(alpha, info[3]->BooleanValue());
    }
    impl->colorMask(red, green, blue, alpha);
}

static void colorMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::colorMaskMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void compileShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("compileShader", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("compileShader", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->compileShader(shader);
}

static void compileShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::compileShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void compressedTexImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "compressedTexImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        throwMinimumArityTypeError(exceptionState, 7, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    int width;
    int height;
    int border;
    ArrayBufferView* data;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(border, toInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !isUndefinedOrNull(info[6]) && !V8ArrayBufferView::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[6]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[6])) : 0);
    }
    impl->compressedTexImage2D(target, level, internalformat, width, height, border, data);
}

static void compressedTexImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::compressedTexImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void compressedTexSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "compressedTexSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 8)) {
        throwMinimumArityTypeError(exceptionState, 8, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    int width;
    int height;
    unsigned format;
    ArrayBufferView* data;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[6], exceptionState), exceptionState);
        if (info.Length() > 7 && !isUndefinedOrNull(info[7]) && !V8ArrayBufferView::hasInstance(info[7], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 8 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(data, info[7]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[7])) : 0);
    }
    impl->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
}

static void compressedTexSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::compressedTexSubImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void copyTexImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "copyTexImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 8)) {
        throwMinimumArityTypeError(exceptionState, 8, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    int x;
    int y;
    int width;
    int height;
    int border;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[6], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(border, toInt32(info[7], exceptionState), exceptionState);
    }
    impl->copyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

static void copyTexImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::copyTexImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void copyTexSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "copyTexSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 8)) {
        throwMinimumArityTypeError(exceptionState, 8, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    int x;
    int y;
    int width;
    int height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[6], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[7], exceptionState), exceptionState);
    }
    impl->copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

static void copyTexSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::copyTexSubImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->createBuffer());
}

static void createBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->createFramebuffer());
}

static void createFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createFramebufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->createProgram());
}

static void createProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->createRenderbuffer());
}

static void createRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createRenderbufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createShader", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned type;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[0], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, impl->createShader(type));
}

static void createShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void createTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->createTexture());
}

static void createTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::createTextureMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void cullFaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "cullFace", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mode;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->cullFace(mode);
}

static void cullFaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::cullFaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteBuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLBuffer* buffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLBuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteBuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLBuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(buffer, V8WebGLBuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteBuffer(buffer);
}

static void deleteBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteFramebuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLFramebuffer* framebuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLFramebuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteFramebuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLFramebuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(framebuffer, V8WebGLFramebuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteFramebuffer(framebuffer);
}

static void deleteFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteFramebufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteProgram", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteProgram", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteProgram(program);
}

static void deleteProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteRenderbuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLRenderbuffer* renderbuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLRenderbuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteRenderbuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLRenderbuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(renderbuffer, V8WebGLRenderbuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteRenderbuffer(renderbuffer);
}

static void deleteRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteRenderbufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteShader", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteShader", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteShader(shader);
}

static void deleteShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void deleteTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("deleteTexture", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLTexture* texture;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLTexture::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("deleteTexture", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLTexture'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(texture, V8WebGLTexture::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->deleteTexture(texture);
}

static void deleteTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::deleteTextureMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void depthFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "depthFunc", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned func;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(func, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->depthFunc(func);
}

static void depthFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::depthFuncMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void depthMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("depthMask", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    bool flag;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(flag, info[0]->BooleanValue());
    }
    impl->depthMask(flag);
}

static void depthMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::depthMaskMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void depthRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("depthRange", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float zNear;
    float zFar;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(zNear, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(zFar, static_cast<float>(info[1]->NumberValue()));
    }
    impl->depthRange(zNear, zFar);
}

static void depthRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::depthRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void detachShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("detachShader", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("detachShader", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        if (info.Length() > 1 && !isUndefinedOrNull(info[1]) && !V8WebGLShader::hasInstance(info[1], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("detachShader", "WebGLRenderingContext", "parameter 2 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[1]));
    }
    impl->detachShader(program, shader);
}

static void detachShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::detachShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void disableMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "disable", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned cap;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(cap, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->disable(cap);
}

static void disableMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::disableMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void disableVertexAttribArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "disableVertexAttribArray", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->disableVertexAttribArray(index);
}

static void disableVertexAttribArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::disableVertexAttribArrayMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawArraysMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawArrays", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mode;
    int first;
    int count;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(first, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(count, toInt32(info[2], exceptionState), exceptionState);
    }
    impl->drawArrays(mode, first, count);
}

static void drawArraysMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::drawArraysMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void drawElementsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawElements", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mode;
    int count;
    unsigned type;
    long long offset;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(count, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(offset, toInt64(info[3], exceptionState), exceptionState);
    }
    impl->drawElements(mode, count, type, offset);
}

static void drawElementsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::drawElementsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void enableMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "enable", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned cap;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(cap, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->enable(cap);
}

static void enableMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::enableMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void enableVertexAttribArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "enableVertexAttribArray", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->enableVertexAttribArray(index);
}

static void enableVertexAttribArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::enableVertexAttribArrayMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void finishMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    impl->finish();
}

static void finishMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::finishMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void flushMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    impl->flush();
}

static void flushMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::flushMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void framebufferRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "framebufferRenderbuffer", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned attachment;
    unsigned renderbuffertarget;
    WebGLRenderbuffer* renderbuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(attachment, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(renderbuffertarget, toUInt32(info[2], exceptionState), exceptionState);
        if (info.Length() > 3 && !isUndefinedOrNull(info[3]) && !V8WebGLRenderbuffer::hasInstance(info[3], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 4 is not of type 'WebGLRenderbuffer'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(renderbuffer, V8WebGLRenderbuffer::toNativeWithTypeCheck(info.GetIsolate(), info[3]));
    }
    impl->framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

static void framebufferRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::framebufferRenderbufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void framebufferTexture2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "framebufferTexture2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned attachment;
    unsigned textarget;
    WebGLTexture* texture;
    int level;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(attachment, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(textarget, toUInt32(info[2], exceptionState), exceptionState);
        if (info.Length() > 3 && !isUndefinedOrNull(info[3]) && !V8WebGLTexture::hasInstance(info[3], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 4 is not of type 'WebGLTexture'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(texture, V8WebGLTexture::toNativeWithTypeCheck(info.GetIsolate(), info[3]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[4], exceptionState), exceptionState);
    }
    impl->framebufferTexture2D(target, attachment, textarget, texture, level);
}

static void framebufferTexture2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::framebufferTexture2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void frontFaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "frontFace", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mode;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->frontFace(mode);
}

static void frontFaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::frontFaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void generateMipmapMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "generateMipmap", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->generateMipmap(target);
}

static void generateMipmapMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::generateMipmapMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getActiveAttribMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getActiveAttrib", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[1], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, impl->getActiveAttrib(program, index));
}

static void getActiveAttribMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getActiveAttribMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getActiveUniformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getActiveUniform", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    unsigned index;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[1], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, impl->getActiveUniform(program, index));
}

static void getActiveUniformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getActiveUniformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getAttachedShadersMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getAttachedShadersMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getAttribLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("getAttribLocation", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    V8StringResource<> name;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("getAttribLocation", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(name, info[1]);
    }
    v8SetReturnValueInt(info, impl->getAttribLocation(program, name));
}

static void getAttribLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getAttribLocationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getBufferParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getBufferParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getContextAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValue(info, impl->getContextAttributes());
}

static void getContextAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getContextAttributesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getErrorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValueUnsigned(info, impl->getError());
}

static void getErrorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getErrorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getExtensionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getExtensionMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getFramebufferAttachmentParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getFramebufferAttachmentParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getProgramParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getProgramParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getProgramInfoLogMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("getProgramInfoLog", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("getProgramInfoLog", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueStringOrNull(info, impl->getProgramInfoLog(program), info.GetIsolate());
}

static void getProgramInfoLogMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getProgramInfoLogMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getRenderbufferParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getRenderbufferParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getShaderParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getShaderParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getShaderInfoLogMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("getShaderInfoLog", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("getShaderInfoLog", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueStringOrNull(info, impl->getShaderInfoLog(shader), info.GetIsolate());
}

static void getShaderInfoLogMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getShaderInfoLogMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getShaderPrecisionFormatMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getShaderPrecisionFormat", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned shadertype;
    unsigned precisiontype;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(shadertype, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(precisiontype, toUInt32(info[1], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, impl->getShaderPrecisionFormat(shadertype, precisiontype));
}

static void getShaderPrecisionFormatMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getShaderPrecisionFormatMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getShaderSourceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("getShaderSource", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("getShaderSource", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueStringOrNull(info, impl->getShaderSource(shader), info.GetIsolate());
}

static void getShaderSourceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getShaderSourceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getSupportedExtensionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getSupportedExtensionsMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getTexParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getTexParameterMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getUniformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getUniformMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getUniformLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("getUniformLocation", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    V8StringResource<> name;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("getUniformLocation", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(name, info[1]);
    }
    v8SetReturnValue(info, impl->getUniformLocation(program, name));
}

static void getUniformLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getUniformLocationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getVertexAttribMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::getVertexAttribMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void getVertexAttribOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getVertexAttribOffset", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned index;
    unsigned pname;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(index, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pname, toUInt32(info[1], exceptionState), exceptionState);
    }
    v8SetReturnValue(info, static_cast<double>(impl->getVertexAttribOffset(index, pname)));
}

static void getVertexAttribOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::getVertexAttribOffsetMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void hintMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hint", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned mode;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mode, toUInt32(info[1], exceptionState), exceptionState);
    }
    impl->hint(target, mode);
}

static void hintMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::hintMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isBuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLBuffer* buffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLBuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isBuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLBuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(buffer, V8WebGLBuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isBuffer(buffer));
}

static void isBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isContextLostMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    v8SetReturnValueBool(info, impl->isContextLost());
}

static void isContextLostMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isContextLostMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isEnabled", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned cap;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(cap, toUInt32(info[0], exceptionState), exceptionState);
    }
    v8SetReturnValueBool(info, impl->isEnabled(cap));
}

static void isEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isFramebuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLFramebuffer* framebuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLFramebuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isFramebuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLFramebuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(framebuffer, V8WebGLFramebuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isFramebuffer(framebuffer));
}

static void isFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isFramebufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isProgram", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isProgram", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isProgram(program));
}

static void isProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isRenderbuffer", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLRenderbuffer* renderbuffer;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLRenderbuffer::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isRenderbuffer", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLRenderbuffer'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(renderbuffer, V8WebGLRenderbuffer::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isRenderbuffer(renderbuffer));
}

static void isRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isRenderbufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isShader", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isShader", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isShader(shader));
}

static void isShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isShaderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void isTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("isTexture", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLTexture* texture;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLTexture::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("isTexture", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLTexture'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(texture, V8WebGLTexture::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    v8SetReturnValueBool(info, impl->isTexture(texture));
}

static void isTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::isTextureMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void lineWidthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("lineWidth", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float width;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(width, static_cast<float>(info[0]->NumberValue()));
    }
    impl->lineWidth(width);
}

static void lineWidthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::lineWidthMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void linkProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("linkProgram", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("linkProgram", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->linkProgram(program);
}

static void linkProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::linkProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void pixelStoreiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pixelStorei", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned pname;
    int param;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pname, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(param, toInt32(info[1], exceptionState), exceptionState);
    }
    impl->pixelStorei(pname, param);
}

static void pixelStoreiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::pixelStoreiMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void polygonOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("polygonOffset", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float factor;
    float units;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(factor, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(units, static_cast<float>(info[1]->NumberValue()));
    }
    impl->polygonOffset(factor, units);
}

static void polygonOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::polygonOffsetMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void readPixelsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "readPixels", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        throwMinimumArityTypeError(exceptionState, 7, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    unsigned format;
    unsigned type;
    ArrayBufferView* pixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !isUndefinedOrNull(info[6]) && !V8ArrayBufferView::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(pixels, info[6]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[6])) : 0);
    }
    impl->readPixels(x, y, width, height, format, type, pixels);
}

static void readPixelsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::readPixelsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void renderbufferStorageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "renderbufferStorage", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned internalformat;
    int width;
    int height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
    }
    impl->renderbufferStorage(target, internalformat, width, height);
}

static void renderbufferStorageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::renderbufferStorageMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void sampleCoverageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("sampleCoverage", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    float value;
    bool invert;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_INTERNAL(value, static_cast<float>(info[0]->NumberValue()));
        TONATIVE_VOID_INTERNAL(invert, info[1]->BooleanValue());
    }
    impl->sampleCoverage(value, invert);
}

static void sampleCoverageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::sampleCoverageMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void scissorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scissor", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
    }
    impl->scissor(x, y, width, height);
}

static void scissorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::scissorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void shaderSourceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("shaderSource", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLShader* shader;
    V8StringResource<> string;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLShader::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("shaderSource", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLShader'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(shader, V8WebGLShader::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TOSTRING_VOID_INTERNAL(string, info[1]);
    }
    impl->shaderSource(shader, string);
}

static void shaderSourceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::shaderSourceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilFunc", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned func;
    int ref;
    unsigned mask;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(func, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(ref, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mask, toUInt32(info[2], exceptionState), exceptionState);
    }
    impl->stencilFunc(func, ref, mask);
}

static void stencilFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilFuncMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilFuncSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilFuncSeparate", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned face;
    unsigned func;
    int ref;
    unsigned mask;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(face, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(func, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(ref, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mask, toUInt32(info[3], exceptionState), exceptionState);
    }
    impl->stencilFuncSeparate(face, func, ref, mask);
}

static void stencilFuncSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilFuncSeparateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilMask", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned mask;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mask, toUInt32(info[0], exceptionState), exceptionState);
    }
    impl->stencilMask(mask);
}

static void stencilMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilMaskMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilMaskSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilMaskSeparate", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned face;
    unsigned mask;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(face, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(mask, toUInt32(info[1], exceptionState), exceptionState);
    }
    impl->stencilMaskSeparate(face, mask);
}

static void stencilMaskSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilMaskSeparateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilOpMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilOp", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned fail;
    unsigned zfail;
    unsigned zpass;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(fail, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(zfail, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(zpass, toUInt32(info[2], exceptionState), exceptionState);
    }
    impl->stencilOp(fail, zfail, zpass);
}

static void stencilOpMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilOpMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void stencilOpSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stencilOpSeparate", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned face;
    unsigned fail;
    unsigned zfail;
    unsigned zpass;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(face, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(fail, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(zfail, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(zpass, toUInt32(info[3], exceptionState), exceptionState);
    }
    impl->stencilOpSeparate(face, fail, zfail, zpass);
}

static void stencilOpSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::stencilOpSeparateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void texParameterfMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texParameterf", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned pname;
    float param;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pname, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(param, static_cast<float>(info[2]->NumberValue()));
    }
    impl->texParameterf(target, pname, param);
}

static void texParameterfMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::texParameterfMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void texParameteriMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texParameteri", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    unsigned pname;
    int param;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(pname, toUInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(param, toInt32(info[2], exceptionState), exceptionState);
    }
    impl->texParameteri(target, pname, param);
}

static void texParameteriMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::texParameteriMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void texImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    int width;
    int height;
    int border;
    unsigned format;
    unsigned type;
    ArrayBufferView* pixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(border, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[6], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[7], exceptionState), exceptionState);
        if (info.Length() > 8 && !isUndefinedOrNull(info[8]) && !V8ArrayBufferView::hasInstance(info[8], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(pixels, info[8]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[8])) : 0);
    }
    impl->texImage2D(target, level, internalformat, width, height, border, format, type, pixels, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    unsigned format;
    unsigned type;
    ImageData* pixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[4], exceptionState), exceptionState);
        if (info.Length() > 5 && !isUndefinedOrNull(info[5]) && !V8ImageData::hasInstance(info[5], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 6 is not of type 'ImageData'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(pixels, V8ImageData::toNativeWithTypeCheck(info.GetIsolate(), info[5]));
    }
    impl->texImage2D(target, level, internalformat, format, type, pixels, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    unsigned format;
    unsigned type;
    HTMLImageElement* image;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[4], exceptionState), exceptionState);
        if (info.Length() > 5 && !V8HTMLImageElement::hasInstance(info[5], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[5]));
    }
    impl->texImage2D(target, level, internalformat, format, type, image, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texImage2D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    unsigned format;
    unsigned type;
    HTMLCanvasElement* canvas;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[4], exceptionState), exceptionState);
        if (info.Length() > 5 && !V8HTMLCanvasElement::hasInstance(info[5], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[5]));
    }
    impl->texImage2D(target, level, internalformat, format, type, canvas, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texImage2D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    unsigned internalformat;
    unsigned format;
    unsigned type;
    HTMLVideoElement* video;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(internalformat, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[4], exceptionState), exceptionState);
        if (info.Length() > 5 && !V8HTMLVideoElement::hasInstance(info[5], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(video, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[5]));
    }
    impl->texImage2D(target, level, internalformat, format, type, video, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texImage2D", "WebGLRenderingContext", info.Holder(), isolate);
    switch (std::min(9, info.Length())) {
    case 6:
        if (isUndefinedOrNull(info[5])) {
            texImage2D2Method(info);
            return;
        }
        if (V8ImageData::hasInstance(info[5], isolate)) {
            texImage2D2Method(info);
            return;
        }
        if (V8HTMLImageElement::hasInstance(info[5], isolate)) {
            texImage2D3Method(info);
            return;
        }
        if (V8HTMLCanvasElement::hasInstance(info[5], isolate)) {
            texImage2D4Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[5], isolate)) {
            texImage2D5Method(info);
            return;
        }
        break;
    case 9:
        if (true) {
            texImage2D1Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 6) {
            throwArityTypeError(exceptionState, "[6, 9]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void texImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::texImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void texSubImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    int width;
    int height;
    unsigned format;
    unsigned type;
    ArrayBufferView* pixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[5], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[6], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[7], exceptionState), exceptionState);
        if (info.Length() > 8 && !isUndefinedOrNull(info[8]) && !V8ArrayBufferView::hasInstance(info[8], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(pixels, info[8]->IsArrayBufferView() ? V8ArrayBufferView::toNative(v8::Handle<v8::ArrayBufferView>::Cast(info[8])) : 0);
    }
    impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texSubImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    unsigned format;
    unsigned type;
    ImageData* pixels;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !isUndefinedOrNull(info[6]) && !V8ImageData::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ImageData'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(pixels, V8ImageData::toNativeWithTypeCheck(info.GetIsolate(), info[6]));
    }
    impl->texSubImage2D(target, level, xoffset, yoffset, format, type, pixels, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texSubImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    unsigned format;
    unsigned type;
    HTMLImageElement* image;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !V8HTMLImageElement::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLImageElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(image, V8HTMLImageElement::toNativeWithTypeCheck(info.GetIsolate(), info[6]));
    }
    impl->texSubImage2D(target, level, xoffset, yoffset, format, type, image, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texSubImage2D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    unsigned format;
    unsigned type;
    HTMLCanvasElement* canvas;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !V8HTMLCanvasElement::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLCanvasElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(canvas, V8HTMLCanvasElement::toNativeWithTypeCheck(info.GetIsolate(), info[6]));
    }
    impl->texSubImage2D(target, level, xoffset, yoffset, format, type, canvas, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texSubImage2D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned target;
    int level;
    int xoffset;
    int yoffset;
    unsigned format;
    unsigned type;
    HTMLVideoElement* video;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(target, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(level, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(xoffset, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(yoffset, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(format, toUInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[5], exceptionState), exceptionState);
        if (info.Length() > 6 && !V8HTMLVideoElement::hasInstance(info[6], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLVideoElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(video, V8HTMLVideoElement::toNativeWithTypeCheck(info.GetIsolate(), info[6]));
    }
    impl->texSubImage2D(target, level, xoffset, yoffset, format, type, video, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void texSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "texSubImage2D", "WebGLRenderingContext", info.Holder(), isolate);
    switch (std::min(9, info.Length())) {
    case 7:
        if (isUndefinedOrNull(info[6])) {
            texSubImage2D2Method(info);
            return;
        }
        if (V8ImageData::hasInstance(info[6], isolate)) {
            texSubImage2D2Method(info);
            return;
        }
        if (V8HTMLImageElement::hasInstance(info[6], isolate)) {
            texSubImage2D3Method(info);
            return;
        }
        if (V8HTMLCanvasElement::hasInstance(info[6], isolate)) {
            texSubImage2D4Method(info);
            return;
        }
        if (V8HTMLVideoElement::hasInstance(info[6], isolate)) {
            texSubImage2D5Method(info);
            return;
        }
        break;
    case 9:
        if (true) {
            texSubImage2D1Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 7) {
            throwArityTypeError(exceptionState, "[7, 9]", info.Length());
            return;
        }
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(7, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
}

static void texSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::texSubImage2DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform1fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeErrorForMethod("uniform1f", "WebGLRenderingContext", 2, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    float x;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("uniform1f", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
    }
    impl->uniform1f(location, x);
}

static void uniform1fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform1fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform1fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform1fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform1iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "uniform1i", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    int x;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
    }
    impl->uniform1i(location, x);
}

static void uniform1iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform1iMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform1ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform1ivMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform2fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeErrorForMethod("uniform2f", "WebGLRenderingContext", 3, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("uniform2f", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->uniform2f(location, x, y);
}

static void uniform2fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform2fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform2fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform2iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "uniform2i", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    int x;
    int y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
    }
    impl->uniform2i(location, x, y);
}

static void uniform2iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform2iMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform2ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform2ivMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform3fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeErrorForMethod("uniform3f", "WebGLRenderingContext", 4, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    float x;
    float y;
    float z;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("uniform3f", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(z, static_cast<float>(info[3]->NumberValue()));
    }
    impl->uniform3f(location, x, y, z);
}

static void uniform3fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform3fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform3fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform3iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "uniform3i", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    int x;
    int y;
    int z;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(z, toInt32(info[3], exceptionState), exceptionState);
    }
    impl->uniform3i(location, x, y, z);
}

static void uniform3iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform3iMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform3ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform3ivMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform4fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeErrorForMethod("uniform4f", "WebGLRenderingContext", 5, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    float x;
    float y;
    float z;
    float w;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("uniform4f", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(z, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(w, static_cast<float>(info[4]->NumberValue()));
    }
    impl->uniform4f(location, x, y, z, w);
}

static void uniform4fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform4fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform4fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform4iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "uniform4i", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLUniformLocation* location;
    int x;
    int y;
    int z;
    int w;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLUniformLocation::hasInstance(info[0], info.GetIsolate())) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");
            exceptionState.throwIfNeeded();
            return;
        }
        TONATIVE_VOID_INTERNAL(location, V8WebGLUniformLocation::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(z, toInt32(info[3], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(w, toInt32(info[4], exceptionState), exceptionState);
    }
    impl->uniform4i(location, x, y, z, w);
}

static void uniform4iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::uniform4iMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniform4ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniform4ivMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniformMatrix2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniformMatrix2fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniformMatrix3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniformMatrix3fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void uniformMatrix4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::uniformMatrix4fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void useProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("useProgram", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("useProgram", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->useProgram(program);
}

static void useProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::useProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void validateProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        throwMinimumArityTypeErrorForMethod("validateProgram", "WebGLRenderingContext", 1, info.Length(), info.GetIsolate());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    WebGLProgram* program;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        if (info.Length() > 0 && !isUndefinedOrNull(info[0]) && !V8WebGLProgram::hasInstance(info[0], info.GetIsolate())) {
            throwTypeError(ExceptionMessages::failedToExecute("validateProgram", "WebGLRenderingContext", "parameter 1 is not of type 'WebGLProgram'."), info.GetIsolate());
            return;
        }
        TONATIVE_VOID_INTERNAL(program, V8WebGLProgram::toNativeWithTypeCheck(info.GetIsolate(), info[0]));
    }
    impl->validateProgram(program);
}

static void validateProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::validateProgramMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib1fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vertexAttrib1f", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        throwMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned indx;
    float x;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(indx, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
    }
    impl->vertexAttrib1f(indx, x);
}

static void vertexAttrib1fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::vertexAttrib1fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib1fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::vertexAttrib1fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib2fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vertexAttrib2f", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        throwMinimumArityTypeError(exceptionState, 3, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned indx;
    float x;
    float y;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(indx, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
    }
    impl->vertexAttrib2f(indx, x, y);
}

static void vertexAttrib2fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::vertexAttrib2fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::vertexAttrib2fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib3fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vertexAttrib3f", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned indx;
    float x;
    float y;
    float z;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(indx, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(z, static_cast<float>(info[3]->NumberValue()));
    }
    impl->vertexAttrib3f(indx, x, y, z);
}

static void vertexAttrib3fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::vertexAttrib3fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::vertexAttrib3fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib4fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vertexAttrib4f", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        throwMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned indx;
    float x;
    float y;
    float z;
    float w;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(indx, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(x, static_cast<float>(info[1]->NumberValue()));
        TONATIVE_VOID_INTERNAL(y, static_cast<float>(info[2]->NumberValue()));
        TONATIVE_VOID_INTERNAL(z, static_cast<float>(info[3]->NumberValue()));
        TONATIVE_VOID_INTERNAL(w, static_cast<float>(info[4]->NumberValue()));
    }
    impl->vertexAttrib4f(indx, x, y, z, w);
}

static void vertexAttrib4fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::vertexAttrib4fMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttrib4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    V8WebGLRenderingContext::vertexAttrib4fvMethodCustom(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void vertexAttribPointerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vertexAttribPointer", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        throwMinimumArityTypeError(exceptionState, 6, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    unsigned indx;
    int size;
    unsigned type;
    bool normalized;
    int stride;
    long long offset;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(indx, toUInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(size, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(type, toUInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_INTERNAL(normalized, info[3]->BooleanValue());
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(stride, toInt32(info[4], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(offset, toInt64(info[5], exceptionState), exceptionState);
    }
    impl->vertexAttribPointer(indx, size, type, normalized, stride, offset);
}

static void vertexAttribPointerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::vertexAttribPointerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

static void viewportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "viewport", "WebGLRenderingContext", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        throwMinimumArityTypeError(exceptionState, 4, info.Length());
        return;
    }
    WebGLRenderingContext* impl = V8WebGLRenderingContext::toNative(info.Holder());
    int x;
    int y;
    int width;
    int height;
    {
        v8::TryCatch block;
        V8RethrowTryCatchScope rethrow(block);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(x, toInt32(info[0], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(y, toInt32(info[1], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(width, toInt32(info[2], exceptionState), exceptionState);
        TONATIVE_VOID_EXCEPTIONSTATE_INTERNAL(height, toInt32(info[3], exceptionState), exceptionState);
    }
    impl->viewport(x, y, width, height);
}

static void viewportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("Blink", "DOMMethod");
    WebGLRenderingContextV8Internal::viewportMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("V8", "V8Execution");
}

} // namespace WebGLRenderingContextV8Internal

static const V8DOMConfiguration::AttributeConfiguration V8WebGLRenderingContextAttributes[] = {
    {"canvas", WebGLRenderingContextV8Internal::canvasAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"drawingBufferWidth", WebGLRenderingContextV8Internal::drawingBufferWidthAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    {"drawingBufferHeight", WebGLRenderingContextV8Internal::drawingBufferHeightAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const V8DOMConfiguration::MethodConfiguration V8WebGLRenderingContextMethods[] = {
    {"activeTexture", WebGLRenderingContextV8Internal::activeTextureMethodCallback, 0, 1},
    {"attachShader", WebGLRenderingContextV8Internal::attachShaderMethodCallback, 0, 2},
    {"bindAttribLocation", WebGLRenderingContextV8Internal::bindAttribLocationMethodCallback, 0, 3},
    {"bindBuffer", WebGLRenderingContextV8Internal::bindBufferMethodCallback, 0, 2},
    {"bindFramebuffer", WebGLRenderingContextV8Internal::bindFramebufferMethodCallback, 0, 2},
    {"bindRenderbuffer", WebGLRenderingContextV8Internal::bindRenderbufferMethodCallback, 0, 2},
    {"bindTexture", WebGLRenderingContextV8Internal::bindTextureMethodCallback, 0, 2},
    {"blendColor", WebGLRenderingContextV8Internal::blendColorMethodCallback, 0, 4},
    {"blendEquation", WebGLRenderingContextV8Internal::blendEquationMethodCallback, 0, 1},
    {"blendEquationSeparate", WebGLRenderingContextV8Internal::blendEquationSeparateMethodCallback, 0, 2},
    {"blendFunc", WebGLRenderingContextV8Internal::blendFuncMethodCallback, 0, 2},
    {"blendFuncSeparate", WebGLRenderingContextV8Internal::blendFuncSeparateMethodCallback, 0, 4},
    {"bufferData", WebGLRenderingContextV8Internal::bufferDataMethodCallback, 0, 3},
    {"bufferSubData", WebGLRenderingContextV8Internal::bufferSubDataMethodCallback, 0, 3},
    {"checkFramebufferStatus", WebGLRenderingContextV8Internal::checkFramebufferStatusMethodCallback, 0, 1},
    {"clear", WebGLRenderingContextV8Internal::clearMethodCallback, 0, 1},
    {"clearColor", WebGLRenderingContextV8Internal::clearColorMethodCallback, 0, 4},
    {"clearDepth", WebGLRenderingContextV8Internal::clearDepthMethodCallback, 0, 1},
    {"clearStencil", WebGLRenderingContextV8Internal::clearStencilMethodCallback, 0, 1},
    {"colorMask", WebGLRenderingContextV8Internal::colorMaskMethodCallback, 0, 4},
    {"compileShader", WebGLRenderingContextV8Internal::compileShaderMethodCallback, 0, 1},
    {"compressedTexImage2D", WebGLRenderingContextV8Internal::compressedTexImage2DMethodCallback, 0, 7},
    {"compressedTexSubImage2D", WebGLRenderingContextV8Internal::compressedTexSubImage2DMethodCallback, 0, 8},
    {"copyTexImage2D", WebGLRenderingContextV8Internal::copyTexImage2DMethodCallback, 0, 8},
    {"copyTexSubImage2D", WebGLRenderingContextV8Internal::copyTexSubImage2DMethodCallback, 0, 8},
    {"createBuffer", WebGLRenderingContextV8Internal::createBufferMethodCallback, 0, 0},
    {"createFramebuffer", WebGLRenderingContextV8Internal::createFramebufferMethodCallback, 0, 0},
    {"createProgram", WebGLRenderingContextV8Internal::createProgramMethodCallback, 0, 0},
    {"createRenderbuffer", WebGLRenderingContextV8Internal::createRenderbufferMethodCallback, 0, 0},
    {"createShader", WebGLRenderingContextV8Internal::createShaderMethodCallback, 0, 1},
    {"createTexture", WebGLRenderingContextV8Internal::createTextureMethodCallback, 0, 0},
    {"cullFace", WebGLRenderingContextV8Internal::cullFaceMethodCallback, 0, 1},
    {"deleteBuffer", WebGLRenderingContextV8Internal::deleteBufferMethodCallback, 0, 1},
    {"deleteFramebuffer", WebGLRenderingContextV8Internal::deleteFramebufferMethodCallback, 0, 1},
    {"deleteProgram", WebGLRenderingContextV8Internal::deleteProgramMethodCallback, 0, 1},
    {"deleteRenderbuffer", WebGLRenderingContextV8Internal::deleteRenderbufferMethodCallback, 0, 1},
    {"deleteShader", WebGLRenderingContextV8Internal::deleteShaderMethodCallback, 0, 1},
    {"deleteTexture", WebGLRenderingContextV8Internal::deleteTextureMethodCallback, 0, 1},
    {"depthFunc", WebGLRenderingContextV8Internal::depthFuncMethodCallback, 0, 1},
    {"depthMask", WebGLRenderingContextV8Internal::depthMaskMethodCallback, 0, 1},
    {"depthRange", WebGLRenderingContextV8Internal::depthRangeMethodCallback, 0, 2},
    {"detachShader", WebGLRenderingContextV8Internal::detachShaderMethodCallback, 0, 2},
    {"disable", WebGLRenderingContextV8Internal::disableMethodCallback, 0, 1},
    {"disableVertexAttribArray", WebGLRenderingContextV8Internal::disableVertexAttribArrayMethodCallback, 0, 1},
    {"drawArrays", WebGLRenderingContextV8Internal::drawArraysMethodCallback, 0, 3},
    {"drawElements", WebGLRenderingContextV8Internal::drawElementsMethodCallback, 0, 4},
    {"enable", WebGLRenderingContextV8Internal::enableMethodCallback, 0, 1},
    {"enableVertexAttribArray", WebGLRenderingContextV8Internal::enableVertexAttribArrayMethodCallback, 0, 1},
    {"finish", WebGLRenderingContextV8Internal::finishMethodCallback, 0, 0},
    {"flush", WebGLRenderingContextV8Internal::flushMethodCallback, 0, 0},
    {"framebufferRenderbuffer", WebGLRenderingContextV8Internal::framebufferRenderbufferMethodCallback, 0, 4},
    {"framebufferTexture2D", WebGLRenderingContextV8Internal::framebufferTexture2DMethodCallback, 0, 5},
    {"frontFace", WebGLRenderingContextV8Internal::frontFaceMethodCallback, 0, 1},
    {"generateMipmap", WebGLRenderingContextV8Internal::generateMipmapMethodCallback, 0, 1},
    {"getActiveAttrib", WebGLRenderingContextV8Internal::getActiveAttribMethodCallback, 0, 2},
    {"getActiveUniform", WebGLRenderingContextV8Internal::getActiveUniformMethodCallback, 0, 2},
    {"getAttachedShaders", WebGLRenderingContextV8Internal::getAttachedShadersMethodCallback, 0, 1},
    {"getAttribLocation", WebGLRenderingContextV8Internal::getAttribLocationMethodCallback, 0, 2},
    {"getBufferParameter", WebGLRenderingContextV8Internal::getBufferParameterMethodCallback, 0, 2},
    {"getContextAttributes", WebGLRenderingContextV8Internal::getContextAttributesMethodCallback, 0, 0},
    {"getError", WebGLRenderingContextV8Internal::getErrorMethodCallback, 0, 0},
    {"getExtension", WebGLRenderingContextV8Internal::getExtensionMethodCallback, 0, 1},
    {"getFramebufferAttachmentParameter", WebGLRenderingContextV8Internal::getFramebufferAttachmentParameterMethodCallback, 0, 3},
    {"getParameter", WebGLRenderingContextV8Internal::getParameterMethodCallback, 0, 1},
    {"getProgramParameter", WebGLRenderingContextV8Internal::getProgramParameterMethodCallback, 0, 2},
    {"getProgramInfoLog", WebGLRenderingContextV8Internal::getProgramInfoLogMethodCallback, 0, 1},
    {"getRenderbufferParameter", WebGLRenderingContextV8Internal::getRenderbufferParameterMethodCallback, 0, 2},
    {"getShaderParameter", WebGLRenderingContextV8Internal::getShaderParameterMethodCallback, 0, 2},
    {"getShaderInfoLog", WebGLRenderingContextV8Internal::getShaderInfoLogMethodCallback, 0, 1},
    {"getShaderPrecisionFormat", WebGLRenderingContextV8Internal::getShaderPrecisionFormatMethodCallback, 0, 2},
    {"getShaderSource", WebGLRenderingContextV8Internal::getShaderSourceMethodCallback, 0, 1},
    {"getSupportedExtensions", WebGLRenderingContextV8Internal::getSupportedExtensionsMethodCallback, 0, 0},
    {"getTexParameter", WebGLRenderingContextV8Internal::getTexParameterMethodCallback, 0, 2},
    {"getUniform", WebGLRenderingContextV8Internal::getUniformMethodCallback, 0, 2},
    {"getUniformLocation", WebGLRenderingContextV8Internal::getUniformLocationMethodCallback, 0, 2},
    {"getVertexAttrib", WebGLRenderingContextV8Internal::getVertexAttribMethodCallback, 0, 2},
    {"getVertexAttribOffset", WebGLRenderingContextV8Internal::getVertexAttribOffsetMethodCallback, 0, 2},
    {"hint", WebGLRenderingContextV8Internal::hintMethodCallback, 0, 2},
    {"isBuffer", WebGLRenderingContextV8Internal::isBufferMethodCallback, 0, 1},
    {"isContextLost", WebGLRenderingContextV8Internal::isContextLostMethodCallback, 0, 0},
    {"isEnabled", WebGLRenderingContextV8Internal::isEnabledMethodCallback, 0, 1},
    {"isFramebuffer", WebGLRenderingContextV8Internal::isFramebufferMethodCallback, 0, 1},
    {"isProgram", WebGLRenderingContextV8Internal::isProgramMethodCallback, 0, 1},
    {"isRenderbuffer", WebGLRenderingContextV8Internal::isRenderbufferMethodCallback, 0, 1},
    {"isShader", WebGLRenderingContextV8Internal::isShaderMethodCallback, 0, 1},
    {"isTexture", WebGLRenderingContextV8Internal::isTextureMethodCallback, 0, 1},
    {"lineWidth", WebGLRenderingContextV8Internal::lineWidthMethodCallback, 0, 1},
    {"linkProgram", WebGLRenderingContextV8Internal::linkProgramMethodCallback, 0, 1},
    {"pixelStorei", WebGLRenderingContextV8Internal::pixelStoreiMethodCallback, 0, 2},
    {"polygonOffset", WebGLRenderingContextV8Internal::polygonOffsetMethodCallback, 0, 2},
    {"readPixels", WebGLRenderingContextV8Internal::readPixelsMethodCallback, 0, 7},
    {"renderbufferStorage", WebGLRenderingContextV8Internal::renderbufferStorageMethodCallback, 0, 4},
    {"sampleCoverage", WebGLRenderingContextV8Internal::sampleCoverageMethodCallback, 0, 2},
    {"scissor", WebGLRenderingContextV8Internal::scissorMethodCallback, 0, 4},
    {"shaderSource", WebGLRenderingContextV8Internal::shaderSourceMethodCallback, 0, 2},
    {"stencilFunc", WebGLRenderingContextV8Internal::stencilFuncMethodCallback, 0, 3},
    {"stencilFuncSeparate", WebGLRenderingContextV8Internal::stencilFuncSeparateMethodCallback, 0, 4},
    {"stencilMask", WebGLRenderingContextV8Internal::stencilMaskMethodCallback, 0, 1},
    {"stencilMaskSeparate", WebGLRenderingContextV8Internal::stencilMaskSeparateMethodCallback, 0, 2},
    {"stencilOp", WebGLRenderingContextV8Internal::stencilOpMethodCallback, 0, 3},
    {"stencilOpSeparate", WebGLRenderingContextV8Internal::stencilOpSeparateMethodCallback, 0, 4},
    {"texParameterf", WebGLRenderingContextV8Internal::texParameterfMethodCallback, 0, 3},
    {"texParameteri", WebGLRenderingContextV8Internal::texParameteriMethodCallback, 0, 3},
    {"texImage2D", WebGLRenderingContextV8Internal::texImage2DMethodCallback, 0, 6},
    {"texSubImage2D", WebGLRenderingContextV8Internal::texSubImage2DMethodCallback, 0, 7},
    {"uniform1f", WebGLRenderingContextV8Internal::uniform1fMethodCallback, 0, 2},
    {"uniform1fv", WebGLRenderingContextV8Internal::uniform1fvMethodCallback, 0, 2},
    {"uniform1i", WebGLRenderingContextV8Internal::uniform1iMethodCallback, 0, 2},
    {"uniform1iv", WebGLRenderingContextV8Internal::uniform1ivMethodCallback, 0, 2},
    {"uniform2f", WebGLRenderingContextV8Internal::uniform2fMethodCallback, 0, 3},
    {"uniform2fv", WebGLRenderingContextV8Internal::uniform2fvMethodCallback, 0, 2},
    {"uniform2i", WebGLRenderingContextV8Internal::uniform2iMethodCallback, 0, 3},
    {"uniform2iv", WebGLRenderingContextV8Internal::uniform2ivMethodCallback, 0, 2},
    {"uniform3f", WebGLRenderingContextV8Internal::uniform3fMethodCallback, 0, 4},
    {"uniform3fv", WebGLRenderingContextV8Internal::uniform3fvMethodCallback, 0, 2},
    {"uniform3i", WebGLRenderingContextV8Internal::uniform3iMethodCallback, 0, 4},
    {"uniform3iv", WebGLRenderingContextV8Internal::uniform3ivMethodCallback, 0, 2},
    {"uniform4f", WebGLRenderingContextV8Internal::uniform4fMethodCallback, 0, 5},
    {"uniform4fv", WebGLRenderingContextV8Internal::uniform4fvMethodCallback, 0, 2},
    {"uniform4i", WebGLRenderingContextV8Internal::uniform4iMethodCallback, 0, 5},
    {"uniform4iv", WebGLRenderingContextV8Internal::uniform4ivMethodCallback, 0, 2},
    {"uniformMatrix2fv", WebGLRenderingContextV8Internal::uniformMatrix2fvMethodCallback, 0, 3},
    {"uniformMatrix3fv", WebGLRenderingContextV8Internal::uniformMatrix3fvMethodCallback, 0, 3},
    {"uniformMatrix4fv", WebGLRenderingContextV8Internal::uniformMatrix4fvMethodCallback, 0, 3},
    {"useProgram", WebGLRenderingContextV8Internal::useProgramMethodCallback, 0, 1},
    {"validateProgram", WebGLRenderingContextV8Internal::validateProgramMethodCallback, 0, 1},
    {"vertexAttrib1f", WebGLRenderingContextV8Internal::vertexAttrib1fMethodCallback, 0, 2},
    {"vertexAttrib1fv", WebGLRenderingContextV8Internal::vertexAttrib1fvMethodCallback, 0, 2},
    {"vertexAttrib2f", WebGLRenderingContextV8Internal::vertexAttrib2fMethodCallback, 0, 3},
    {"vertexAttrib2fv", WebGLRenderingContextV8Internal::vertexAttrib2fvMethodCallback, 0, 2},
    {"vertexAttrib3f", WebGLRenderingContextV8Internal::vertexAttrib3fMethodCallback, 0, 4},
    {"vertexAttrib3fv", WebGLRenderingContextV8Internal::vertexAttrib3fvMethodCallback, 0, 2},
    {"vertexAttrib4f", WebGLRenderingContextV8Internal::vertexAttrib4fMethodCallback, 0, 5},
    {"vertexAttrib4fv", WebGLRenderingContextV8Internal::vertexAttrib4fvMethodCallback, 0, 2},
    {"vertexAttribPointer", WebGLRenderingContextV8Internal::vertexAttribPointerMethodCallback, 0, 6},
    {"viewport", WebGLRenderingContextV8Internal::viewportMethodCallback, 0, 4},
};

static void configureV8WebGLRenderingContextTemplate(v8::Handle<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(functionTemplate, "WebGLRenderingContext", v8::Local<v8::FunctionTemplate>(), V8WebGLRenderingContext::internalFieldCount,
        V8WebGLRenderingContextAttributes, WTF_ARRAY_LENGTH(V8WebGLRenderingContextAttributes),
        0, 0,
        V8WebGLRenderingContextMethods, WTF_ARRAY_LENGTH(V8WebGLRenderingContextMethods),
        isolate);
    v8::Local<v8::ObjectTemplate> instanceTemplate ALLOW_UNUSED = functionTemplate->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototypeTemplate ALLOW_UNUSED = functionTemplate->PrototypeTemplate();
    static const V8DOMConfiguration::ConstantConfiguration V8WebGLRenderingContextConstants[] = {
        {"DEPTH_BUFFER_BIT", 0x00000100},
        {"STENCIL_BUFFER_BIT", 0x00000400},
        {"COLOR_BUFFER_BIT", 0x00004000},
        {"POINTS", 0x0000},
        {"LINES", 0x0001},
        {"LINE_LOOP", 0x0002},
        {"LINE_STRIP", 0x0003},
        {"TRIANGLES", 0x0004},
        {"TRIANGLE_STRIP", 0x0005},
        {"TRIANGLE_FAN", 0x0006},
        {"ZERO", 0},
        {"ONE", 1},
        {"SRC_COLOR", 0x0300},
        {"ONE_MINUS_SRC_COLOR", 0x0301},
        {"SRC_ALPHA", 0x0302},
        {"ONE_MINUS_SRC_ALPHA", 0x0303},
        {"DST_ALPHA", 0x0304},
        {"ONE_MINUS_DST_ALPHA", 0x0305},
        {"DST_COLOR", 0x0306},
        {"ONE_MINUS_DST_COLOR", 0x0307},
        {"SRC_ALPHA_SATURATE", 0x0308},
        {"FUNC_ADD", 0x8006},
        {"BLEND_EQUATION", 0x8009},
        {"BLEND_EQUATION_RGB", 0x8009},
        {"BLEND_EQUATION_ALPHA", 0x883D},
        {"FUNC_SUBTRACT", 0x800A},
        {"FUNC_REVERSE_SUBTRACT", 0x800B},
        {"BLEND_DST_RGB", 0x80C8},
        {"BLEND_SRC_RGB", 0x80C9},
        {"BLEND_DST_ALPHA", 0x80CA},
        {"BLEND_SRC_ALPHA", 0x80CB},
        {"CONSTANT_COLOR", 0x8001},
        {"ONE_MINUS_CONSTANT_COLOR", 0x8002},
        {"CONSTANT_ALPHA", 0x8003},
        {"ONE_MINUS_CONSTANT_ALPHA", 0x8004},
        {"BLEND_COLOR", 0x8005},
        {"ARRAY_BUFFER", 0x8892},
        {"ELEMENT_ARRAY_BUFFER", 0x8893},
        {"ARRAY_BUFFER_BINDING", 0x8894},
        {"ELEMENT_ARRAY_BUFFER_BINDING", 0x8895},
        {"STREAM_DRAW", 0x88E0},
        {"STATIC_DRAW", 0x88E4},
        {"DYNAMIC_DRAW", 0x88E8},
        {"BUFFER_SIZE", 0x8764},
        {"BUFFER_USAGE", 0x8765},
        {"CURRENT_VERTEX_ATTRIB", 0x8626},
        {"FRONT", 0x0404},
        {"BACK", 0x0405},
        {"FRONT_AND_BACK", 0x0408},
        {"TEXTURE_2D", 0x0DE1},
        {"CULL_FACE", 0x0B44},
        {"BLEND", 0x0BE2},
        {"DITHER", 0x0BD0},
        {"STENCIL_TEST", 0x0B90},
        {"DEPTH_TEST", 0x0B71},
        {"SCISSOR_TEST", 0x0C11},
        {"POLYGON_OFFSET_FILL", 0x8037},
        {"SAMPLE_ALPHA_TO_COVERAGE", 0x809E},
        {"SAMPLE_COVERAGE", 0x80A0},
        {"NO_ERROR", 0},
        {"INVALID_ENUM", 0x0500},
        {"INVALID_VALUE", 0x0501},
        {"INVALID_OPERATION", 0x0502},
        {"OUT_OF_MEMORY", 0x0505},
        {"CW", 0x0900},
        {"CCW", 0x0901},
        {"LINE_WIDTH", 0x0B21},
        {"ALIASED_POINT_SIZE_RANGE", 0x846D},
        {"ALIASED_LINE_WIDTH_RANGE", 0x846E},
        {"CULL_FACE_MODE", 0x0B45},
        {"FRONT_FACE", 0x0B46},
        {"DEPTH_RANGE", 0x0B70},
        {"DEPTH_WRITEMASK", 0x0B72},
        {"DEPTH_CLEAR_VALUE", 0x0B73},
        {"DEPTH_FUNC", 0x0B74},
        {"STENCIL_CLEAR_VALUE", 0x0B91},
        {"STENCIL_FUNC", 0x0B92},
        {"STENCIL_FAIL", 0x0B94},
        {"STENCIL_PASS_DEPTH_FAIL", 0x0B95},
        {"STENCIL_PASS_DEPTH_PASS", 0x0B96},
        {"STENCIL_REF", 0x0B97},
        {"STENCIL_VALUE_MASK", 0x0B93},
        {"STENCIL_WRITEMASK", 0x0B98},
        {"STENCIL_BACK_FUNC", 0x8800},
        {"STENCIL_BACK_FAIL", 0x8801},
        {"STENCIL_BACK_PASS_DEPTH_FAIL", 0x8802},
        {"STENCIL_BACK_PASS_DEPTH_PASS", 0x8803},
        {"STENCIL_BACK_REF", 0x8CA3},
        {"STENCIL_BACK_VALUE_MASK", 0x8CA4},
        {"STENCIL_BACK_WRITEMASK", 0x8CA5},
        {"VIEWPORT", 0x0BA2},
        {"SCISSOR_BOX", 0x0C10},
        {"COLOR_CLEAR_VALUE", 0x0C22},
        {"COLOR_WRITEMASK", 0x0C23},
        {"UNPACK_ALIGNMENT", 0x0CF5},
        {"PACK_ALIGNMENT", 0x0D05},
        {"MAX_TEXTURE_SIZE", 0x0D33},
        {"MAX_VIEWPORT_DIMS", 0x0D3A},
        {"SUBPIXEL_BITS", 0x0D50},
        {"RED_BITS", 0x0D52},
        {"GREEN_BITS", 0x0D53},
        {"BLUE_BITS", 0x0D54},
        {"ALPHA_BITS", 0x0D55},
        {"DEPTH_BITS", 0x0D56},
        {"STENCIL_BITS", 0x0D57},
        {"POLYGON_OFFSET_UNITS", 0x2A00},
        {"POLYGON_OFFSET_FACTOR", 0x8038},
        {"TEXTURE_BINDING_2D", 0x8069},
        {"SAMPLE_BUFFERS", 0x80A8},
        {"SAMPLES", 0x80A9},
        {"SAMPLE_COVERAGE_VALUE", 0x80AA},
        {"SAMPLE_COVERAGE_INVERT", 0x80AB},
        {"COMPRESSED_TEXTURE_FORMATS", 0x86A3},
        {"DONT_CARE", 0x1100},
        {"FASTEST", 0x1101},
        {"NICEST", 0x1102},
        {"GENERATE_MIPMAP_HINT", 0x8192},
        {"BYTE", 0x1400},
        {"UNSIGNED_BYTE", 0x1401},
        {"SHORT", 0x1402},
        {"UNSIGNED_SHORT", 0x1403},
        {"INT", 0x1404},
        {"UNSIGNED_INT", 0x1405},
        {"FLOAT", 0x1406},
        {"DEPTH_COMPONENT", 0x1902},
        {"ALPHA", 0x1906},
        {"RGB", 0x1907},
        {"RGBA", 0x1908},
        {"LUMINANCE", 0x1909},
        {"LUMINANCE_ALPHA", 0x190A},
        {"UNSIGNED_SHORT_4_4_4_4", 0x8033},
        {"UNSIGNED_SHORT_5_5_5_1", 0x8034},
        {"UNSIGNED_SHORT_5_6_5", 0x8363},
        {"FRAGMENT_SHADER", 0x8B30},
        {"VERTEX_SHADER", 0x8B31},
        {"MAX_VERTEX_ATTRIBS", 0x8869},
        {"MAX_VERTEX_UNIFORM_VECTORS", 0x8DFB},
        {"MAX_VARYING_VECTORS", 0x8DFC},
        {"MAX_COMBINED_TEXTURE_IMAGE_UNITS", 0x8B4D},
        {"MAX_VERTEX_TEXTURE_IMAGE_UNITS", 0x8B4C},
        {"MAX_TEXTURE_IMAGE_UNITS", 0x8872},
        {"MAX_FRAGMENT_UNIFORM_VECTORS", 0x8DFD},
        {"SHADER_TYPE", 0x8B4F},
        {"DELETE_STATUS", 0x8B80},
        {"LINK_STATUS", 0x8B82},
        {"VALIDATE_STATUS", 0x8B83},
        {"ATTACHED_SHADERS", 0x8B85},
        {"ACTIVE_UNIFORMS", 0x8B86},
        {"ACTIVE_ATTRIBUTES", 0x8B89},
        {"SHADING_LANGUAGE_VERSION", 0x8B8C},
        {"CURRENT_PROGRAM", 0x8B8D},
        {"NEVER", 0x0200},
        {"LESS", 0x0201},
        {"EQUAL", 0x0202},
        {"LEQUAL", 0x0203},
        {"GREATER", 0x0204},
        {"NOTEQUAL", 0x0205},
        {"GEQUAL", 0x0206},
        {"ALWAYS", 0x0207},
        {"KEEP", 0x1E00},
        {"REPLACE", 0x1E01},
        {"INCR", 0x1E02},
        {"DECR", 0x1E03},
        {"INVERT", 0x150A},
        {"INCR_WRAP", 0x8507},
        {"DECR_WRAP", 0x8508},
        {"VENDOR", 0x1F00},
        {"RENDERER", 0x1F01},
        {"VERSION", 0x1F02},
        {"NEAREST", 0x2600},
        {"LINEAR", 0x2601},
        {"NEAREST_MIPMAP_NEAREST", 0x2700},
        {"LINEAR_MIPMAP_NEAREST", 0x2701},
        {"NEAREST_MIPMAP_LINEAR", 0x2702},
        {"LINEAR_MIPMAP_LINEAR", 0x2703},
        {"TEXTURE_MAG_FILTER", 0x2800},
        {"TEXTURE_MIN_FILTER", 0x2801},
        {"TEXTURE_WRAP_S", 0x2802},
        {"TEXTURE_WRAP_T", 0x2803},
        {"TEXTURE", 0x1702},
        {"TEXTURE_CUBE_MAP", 0x8513},
        {"TEXTURE_BINDING_CUBE_MAP", 0x8514},
        {"TEXTURE_CUBE_MAP_POSITIVE_X", 0x8515},
        {"TEXTURE_CUBE_MAP_NEGATIVE_X", 0x8516},
        {"TEXTURE_CUBE_MAP_POSITIVE_Y", 0x8517},
        {"TEXTURE_CUBE_MAP_NEGATIVE_Y", 0x8518},
        {"TEXTURE_CUBE_MAP_POSITIVE_Z", 0x8519},
        {"TEXTURE_CUBE_MAP_NEGATIVE_Z", 0x851A},
        {"MAX_CUBE_MAP_TEXTURE_SIZE", 0x851C},
        {"TEXTURE0", 0x84C0},
        {"TEXTURE1", 0x84C1},
        {"TEXTURE2", 0x84C2},
        {"TEXTURE3", 0x84C3},
        {"TEXTURE4", 0x84C4},
        {"TEXTURE5", 0x84C5},
        {"TEXTURE6", 0x84C6},
        {"TEXTURE7", 0x84C7},
        {"TEXTURE8", 0x84C8},
        {"TEXTURE9", 0x84C9},
        {"TEXTURE10", 0x84CA},
        {"TEXTURE11", 0x84CB},
        {"TEXTURE12", 0x84CC},
        {"TEXTURE13", 0x84CD},
        {"TEXTURE14", 0x84CE},
        {"TEXTURE15", 0x84CF},
        {"TEXTURE16", 0x84D0},
        {"TEXTURE17", 0x84D1},
        {"TEXTURE18", 0x84D2},
        {"TEXTURE19", 0x84D3},
        {"TEXTURE20", 0x84D4},
        {"TEXTURE21", 0x84D5},
        {"TEXTURE22", 0x84D6},
        {"TEXTURE23", 0x84D7},
        {"TEXTURE24", 0x84D8},
        {"TEXTURE25", 0x84D9},
        {"TEXTURE26", 0x84DA},
        {"TEXTURE27", 0x84DB},
        {"TEXTURE28", 0x84DC},
        {"TEXTURE29", 0x84DD},
        {"TEXTURE30", 0x84DE},
        {"TEXTURE31", 0x84DF},
        {"ACTIVE_TEXTURE", 0x84E0},
        {"REPEAT", 0x2901},
        {"CLAMP_TO_EDGE", 0x812F},
        {"MIRRORED_REPEAT", 0x8370},
        {"FLOAT_VEC2", 0x8B50},
        {"FLOAT_VEC3", 0x8B51},
        {"FLOAT_VEC4", 0x8B52},
        {"INT_VEC2", 0x8B53},
        {"INT_VEC3", 0x8B54},
        {"INT_VEC4", 0x8B55},
        {"BOOL", 0x8B56},
        {"BOOL_VEC2", 0x8B57},
        {"BOOL_VEC3", 0x8B58},
        {"BOOL_VEC4", 0x8B59},
        {"FLOAT_MAT2", 0x8B5A},
        {"FLOAT_MAT3", 0x8B5B},
        {"FLOAT_MAT4", 0x8B5C},
        {"SAMPLER_2D", 0x8B5E},
        {"SAMPLER_CUBE", 0x8B60},
        {"VERTEX_ATTRIB_ARRAY_ENABLED", 0x8622},
        {"VERTEX_ATTRIB_ARRAY_SIZE", 0x8623},
        {"VERTEX_ATTRIB_ARRAY_STRIDE", 0x8624},
        {"VERTEX_ATTRIB_ARRAY_TYPE", 0x8625},
        {"VERTEX_ATTRIB_ARRAY_NORMALIZED", 0x886A},
        {"VERTEX_ATTRIB_ARRAY_POINTER", 0x8645},
        {"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", 0x889F},
        {"IMPLEMENTATION_COLOR_READ_TYPE", 0x8B9A},
        {"IMPLEMENTATION_COLOR_READ_FORMAT", 0x8B9B},
        {"COMPILE_STATUS", 0x8B81},
        {"LOW_FLOAT", 0x8DF0},
        {"MEDIUM_FLOAT", 0x8DF1},
        {"HIGH_FLOAT", 0x8DF2},
        {"LOW_INT", 0x8DF3},
        {"MEDIUM_INT", 0x8DF4},
        {"HIGH_INT", 0x8DF5},
        {"FRAMEBUFFER", 0x8D40},
        {"RENDERBUFFER", 0x8D41},
        {"RGBA4", 0x8056},
        {"RGB5_A1", 0x8057},
        {"RGB565", 0x8D62},
        {"DEPTH_COMPONENT16", 0x81A5},
        {"STENCIL_INDEX", 0x1901},
        {"STENCIL_INDEX8", 0x8D48},
        {"DEPTH_STENCIL", 0x84F9},
        {"RENDERBUFFER_WIDTH", 0x8D42},
        {"RENDERBUFFER_HEIGHT", 0x8D43},
        {"RENDERBUFFER_INTERNAL_FORMAT", 0x8D44},
        {"RENDERBUFFER_RED_SIZE", 0x8D50},
        {"RENDERBUFFER_GREEN_SIZE", 0x8D51},
        {"RENDERBUFFER_BLUE_SIZE", 0x8D52},
        {"RENDERBUFFER_ALPHA_SIZE", 0x8D53},
        {"RENDERBUFFER_DEPTH_SIZE", 0x8D54},
        {"RENDERBUFFER_STENCIL_SIZE", 0x8D55},
        {"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", 0x8CD0},
        {"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", 0x8CD1},
        {"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", 0x8CD2},
        {"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", 0x8CD3},
        {"COLOR_ATTACHMENT0", 0x8CE0},
        {"DEPTH_ATTACHMENT", 0x8D00},
        {"STENCIL_ATTACHMENT", 0x8D20},
        {"DEPTH_STENCIL_ATTACHMENT", 0x821A},
        {"NONE", 0},
        {"FRAMEBUFFER_COMPLETE", 0x8CD5},
        {"FRAMEBUFFER_INCOMPLETE_ATTACHMENT", 0x8CD6},
        {"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", 0x8CD7},
        {"FRAMEBUFFER_INCOMPLETE_DIMENSIONS", 0x8CD9},
        {"FRAMEBUFFER_UNSUPPORTED", 0x8CDD},
        {"FRAMEBUFFER_BINDING", 0x8CA6},
        {"RENDERBUFFER_BINDING", 0x8CA7},
        {"MAX_RENDERBUFFER_SIZE", 0x84E8},
        {"INVALID_FRAMEBUFFER_OPERATION", 0x0506},
        {"UNPACK_FLIP_Y_WEBGL", 0x9240},
        {"UNPACK_PREMULTIPLY_ALPHA_WEBGL", 0x9241},
        {"CONTEXT_LOST_WEBGL", 0x9242},
        {"UNPACK_COLORSPACE_CONVERSION_WEBGL", 0x9243},
        {"BROWSER_DEFAULT_WEBGL", 0x9244},
    };
    V8DOMConfiguration::installConstants(functionTemplate, prototypeTemplate, V8WebGLRenderingContextConstants, WTF_ARRAY_LENGTH(V8WebGLRenderingContextConstants), isolate);

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Handle<v8::FunctionTemplate> V8WebGLRenderingContext::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), configureV8WebGLRenderingContextTemplate);
}

bool V8WebGLRenderingContext::hasInstance(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Handle<v8::Object> V8WebGLRenderingContext::findInstanceInPrototypeChain(v8::Handle<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

WebGLRenderingContext* V8WebGLRenderingContext::toNativeWithTypeCheck(v8::Isolate* isolate, v8::Handle<v8::Value> value)
{
    return hasInstance(value, isolate) ? fromInternalPointer(v8::Handle<v8::Object>::Cast(value)->GetAlignedPointerFromInternalField(v8DOMWrapperObjectIndex)) : 0;
}

v8::Handle<v8::Object> wrap(WebGLRenderingContext* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8WebGLRenderingContext>(impl, isolate));
    return V8WebGLRenderingContext::createWrapper(impl, creationContext, isolate);
}

v8::Handle<v8::Object> V8WebGLRenderingContext::createWrapper(PassRefPtrWillBeRawPtr<WebGLRenderingContext> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl);
    ASSERT(!DOMDataStore::containsWrapper<V8WebGLRenderingContext>(impl.get(), isolate));
    if (ScriptWrappable::wrapperCanBeStoredInObject(impl.get())) {
        const WrapperTypeInfo* actualInfo = ScriptWrappable::fromObject(impl.get())->typeInfo();
        // Might be a XXXConstructor::wrapperTypeInfo instead of an XXX::wrapperTypeInfo. These will both have
        // the same object de-ref functions, though, so use that as the basis of the check.
        RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(actualInfo->derefObjectFunction == wrapperTypeInfo.derefObjectFunction);
    }

    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &wrapperTypeInfo, toInternalPointer(impl.get()), isolate);
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    installPerContextEnabledProperties(wrapper, impl.get(), isolate);
    V8DOMWrapper::associateObjectWithWrapper<V8WebGLRenderingContext>(impl, &wrapperTypeInfo, wrapper, isolate, WrapperConfiguration::Independent);
    return wrapper;
}

void V8WebGLRenderingContext::derefObject(void* object)
{
#if !ENABLE(OILPAN)
    fromInternalPointer(object)->deref();
#endif // !ENABLE(OILPAN)
}

template<>
v8::Handle<v8::Value> toV8NoInline(WebGLRenderingContext* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    return toV8(impl, creationContext, isolate);
}

} // namespace WebCore
